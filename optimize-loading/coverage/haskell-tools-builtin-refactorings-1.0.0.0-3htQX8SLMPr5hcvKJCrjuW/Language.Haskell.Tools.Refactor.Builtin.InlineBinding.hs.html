<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ConstraintKinds, FlexibleContexts, LambdaCase, MultiWayIf, RankNTypes, ScopedTypeVariables, TypeApplications, TypeFamilies #-}
<span class="lineno">    2 </span>-- | Defines the inline binding refactoring that removes a value binding and replaces all occurences
<span class="lineno">    3 </span>-- with an expression equivalent to the body of the binding.
<span class="lineno">    4 </span>module Language.Haskell.Tools.Refactor.Builtin.InlineBinding
<span class="lineno">    5 </span>  (inlineBinding, tryItOut, inlineBindingRefactoring) where
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>import Control.Monad.State
<span class="lineno">    8 </span>import Control.Reference
<span class="lineno">    9 </span>import Data.Generics.Uniplate.Data ()
<span class="lineno">   10 </span>import Data.Generics.Uniplate.Operations (Uniplate(..), Biplate(..))
<span class="lineno">   11 </span>import Data.List (nub)
<span class="lineno">   12 </span>import Data.Maybe (Maybe(..), catMaybes)
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>import Name as GHC (NamedThing(..), Name, occNameString)
<span class="lineno">   15 </span>import SrcLoc as GHC (SrcSpan(..), RealSrcSpan)
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>import Language.Haskell.Tools.Refactor as AST
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>inlineBindingRefactoring :: RefactoringChoice
<span class="lineno">   20 </span><span class="decl"><span class="istickedoff">inlineBindingRefactoring = SelectionRefactoring &quot;InlineBinding&quot; inlineBinding</span></span>
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>tryItOut :: String -&gt; String -&gt; IO ()
<span class="lineno">   23 </span><span class="decl"><span class="nottickedoff">tryItOut = tryRefactor inlineBinding</span></span>
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>inlineBinding :: RealSrcSpan -&gt; Refactoring
<span class="lineno">   27 </span><span class="decl"><span class="istickedoff">inlineBinding span namedMod@(_,mod) mods</span>
<span class="lineno">   28 </span><span class="spaces">  </span><span class="istickedoff">= let topLevel :: Simple Traversal Module DeclList</span>
<span class="lineno">   29 </span><span class="spaces">        </span><span class="istickedoff">topLevel = nodesContaining span</span>
<span class="lineno">   30 </span><span class="spaces">        </span><span class="istickedoff">local :: Simple Traversal Module LocalBindList</span>
<span class="lineno">   31 </span><span class="spaces">        </span><span class="istickedoff">local = nodesContaining span</span>
<span class="lineno">   32 </span><span class="spaces">        </span><span class="istickedoff">exprs :: Simple Traversal Module Expr</span>
<span class="lineno">   33 </span><span class="spaces">        </span><span class="istickedoff">exprs = nodesContaining span</span>
<span class="lineno">   34 </span><span class="spaces">        </span><span class="istickedoff">elemAccess :: (BindingElem d) =&gt; AnnList d -&gt; Maybe ValueBind</span>
<span class="lineno">   35 </span><span class="spaces">        </span><span class="istickedoff">elemAccess = getValBindInList span</span>
<span class="lineno">   36 </span><span class="spaces">        </span><span class="istickedoff">removed = catMaybes $ map elemAccess (mod ^? topLevel) ++ map elemAccess (mod ^? local)</span>
<span class="lineno">   37 </span><span class="spaces">     </span><span class="istickedoff">in case reverse removed of</span>
<span class="lineno">   38 </span><span class="spaces">          </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">refactError &quot;No binding is selected.&quot;</span></span>
<span class="lineno">   39 </span><span class="spaces">          </span><span class="istickedoff">removedBinding:_ -&gt;</span>
<span class="lineno">   40 </span><span class="spaces">           </span><span class="istickedoff">let [removedBindingName] = nub $ catMaybes $ map semanticsName (removedBinding ^? bindingName)</span>
<span class="lineno">   41 </span><span class="spaces">            </span><span class="istickedoff">in if | any (containInlined removedBindingName) mods</span>
<span class="lineno">   42 </span><span class="spaces">                    </span><span class="istickedoff">-&gt; refactError <span class="nottickedoff">&quot;Cannot inline the definition, it is used in other modules.&quot;</span></span>
<span class="lineno">   43 </span><span class="spaces">                  </span><span class="istickedoff">| _:_ &lt;- mod ^? modHead &amp; annJust &amp; mhExports &amp; annJust &amp; biplateRef</span>
<span class="lineno">   44 </span><span class="spaces">                                          </span><span class="istickedoff">&amp; filtered (\n -&gt; semanticsName (n :: QualifiedName) == Just removedBindingName)</span>
<span class="lineno">   45 </span><span class="spaces">                    </span><span class="istickedoff">-&gt; refactError <span class="nottickedoff">&quot;Cannot inline the definition, it is present in the export list.&quot;</span></span>
<span class="lineno">   46 </span><span class="spaces">                  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; localRefactoring (inlineBinding' topLevel local exprs removedBinding removedBindingName) namedMod <span class="nottickedoff">mods</span></span></span>
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>-- | Performs the inline binding on a single module.
<span class="lineno">   49 </span>inlineBinding' :: Simple Traversal Module DeclList -&gt; Simple Traversal Module LocalBindList 
<span class="lineno">   50 </span>                    -&gt; Simple Traversal Module Expr -&gt; ValueBind -&gt; GHC.Name -&gt; LocalRefactoring
<span class="lineno">   51 </span><span class="decl"><span class="istickedoff">inlineBinding' topLevelRef localRef exprRef removedBinding removedBindingName mod</span>
<span class="lineno">   52 </span><span class="spaces">  </span><span class="istickedoff">= do replacement &lt;- createReplacement removedBinding</span>
<span class="lineno">   53 </span><span class="spaces">       </span><span class="istickedoff">let RealSrcSpan bindingSpan = <span class="nottickedoff">getRange removedBinding</span></span>
<span class="lineno">   54 </span><span class="spaces">       </span><span class="istickedoff">mod' &lt;- removeBindingAndSig topLevelRef localRef exprRef removedBindingName mod</span>
<span class="lineno">   55 </span><span class="spaces">       </span><span class="istickedoff">(mod'', used) &lt;- runStateT (descendBiM (replaceInvocations <span class="nottickedoff">bindingSpan</span> removedBindingName replacement) mod') False</span>
<span class="lineno">   56 </span><span class="spaces">       </span><span class="istickedoff">if not used</span>
<span class="lineno">   57 </span><span class="spaces">         </span><span class="istickedoff">then refactError <span class="nottickedoff">&quot;The selected definition is not used, it can be safely deleted.&quot;</span></span>
<span class="lineno">   58 </span><span class="spaces">         </span><span class="istickedoff">else return mod''</span></span>
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>-- | True if the given module contains the name of the inlined definition.
<span class="lineno">   61 </span>containInlined :: GHC.Name -&gt; ModuleDom -&gt; Bool
<span class="lineno">   62 </span><span class="decl"><span class="istickedoff">containInlined name (_,mod)</span>
<span class="lineno">   63 </span><span class="spaces">  </span><span class="istickedoff">= any (\qn -&gt; semanticsName qn == Just name) $ (mod ^? biplateRef :: [QualifiedName])</span></span>
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>-- | Removes the inlined binding and the accompanying type and fixity signatures.
<span class="lineno">   66 </span>removeBindingAndSig :: Simple Traversal Module DeclList -&gt; Simple Traversal Module LocalBindList
<span class="lineno">   67 </span>                         -&gt; Simple Traversal Module Expr -&gt; GHC.Name -&gt; LocalRefactoring
<span class="lineno">   68 </span><span class="decl"><span class="istickedoff">removeBindingAndSig topLevelRef localRef exprRef name</span>
<span class="lineno">   69 </span><span class="spaces">  </span><span class="istickedoff">= (return . removeEmptyBnds (topLevelRef &amp; annList &amp; declValBind &amp;+&amp; localRef &amp; annList &amp; localVal) exprRef)</span>
<span class="lineno">   70 </span><span class="spaces">      </span><span class="istickedoff">&lt;=&lt; (topLevelRef !~ removeBindingAndSig' name)</span>
<span class="lineno">   71 </span><span class="spaces">      </span><span class="istickedoff">&lt;=&lt; (localRef !~ removeBindingAndSig' name)</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>removeBindingAndSig' :: (SourceInfoTraversal d, BindingElem d) 
<span class="lineno">   74 </span>                     =&gt; GHC.Name -&gt; AnnList d -&gt; LocalRefactor (AnnList d)
<span class="lineno">   75 </span><span class="decl"><span class="istickedoff">removeBindingAndSig' name ls = do</span>
<span class="lineno">   76 </span><span class="spaces">   </span><span class="istickedoff">bnds &lt;- mapM notThatBindOrSig (ls ^? annList)</span>
<span class="lineno">   77 </span><span class="spaces">   </span><span class="istickedoff">return $ (annList .- removeNameFromSigBind) (filterListIndexed (\i _ -&gt; bnds !! i) ls)</span>
<span class="lineno">   78 </span><span class="spaces">  </span><span class="istickedoff">where notThatBindOrSig e</span>
<span class="lineno">   79 </span><span class="spaces">          </span><span class="istickedoff">| Just sb &lt;- e ^? sigBind = return $ nub (map semanticsName (sb ^? tsName &amp; annList &amp; simpleName)) /= [Just name]</span>
<span class="lineno">   80 </span><span class="spaces">          </span><span class="istickedoff">| Just vb &lt;- e ^? valBind = do</span>
<span class="lineno">   81 </span><span class="spaces">             </span><span class="istickedoff">let isThat = nub (map semanticsName (vb ^? bindingName)) == [Just name]</span>
<span class="lineno">   82 </span><span class="spaces">             </span><span class="istickedoff">when isThat (void $ accessRhs !| checkForRecursion name $ vb)</span>
<span class="lineno">   83 </span><span class="spaces">             </span><span class="istickedoff">return $ not isThat</span>
<span class="lineno">   84 </span><span class="spaces">          </span><span class="istickedoff">| Just fs &lt;- e ^? fixitySig = return $ nub (map semanticsName (fs ^? fixityOperators &amp; annList &amp; operatorName)) /= [Just name]</span>
<span class="lineno">   85 </span><span class="spaces">          </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">return True</span></span>
<span class="lineno">   86 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   87 </span><span class="spaces">        </span><span class="istickedoff">removeNameFromSigBind</span>
<span class="lineno">   88 </span><span class="spaces">          </span><span class="istickedoff">= (sigBind &amp; tsName .- filterList (\n -&gt; semanticsName (n ^. simpleName) /= Just name))</span>
<span class="lineno">   89 </span><span class="spaces">             </span><span class="istickedoff">. (fixitySig &amp; fixityOperators .- filterList (\n -&gt; semanticsName (n ^. operatorName) /= Just name))</span>
<span class="lineno">   90 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   91 </span><span class="spaces">        </span><span class="istickedoff">accessRhs = valBindRhs</span>
<span class="lineno">   92 </span><span class="spaces">                      </span><span class="istickedoff">&amp;+&amp; valBindLocals &amp; accessLocalRhs</span>
<span class="lineno">   93 </span><span class="spaces">                      </span><span class="istickedoff">&amp;+&amp; funBindMatches &amp; annList &amp; matchRhs</span>
<span class="lineno">   94 </span><span class="spaces">                      </span><span class="istickedoff">&amp;+&amp; funBindMatches &amp; annList &amp; (matchRhs &amp;+&amp; matchBinds &amp; accessLocalRhs)</span>
<span class="lineno">   95 </span><span class="spaces">        </span><span class="istickedoff">accessLocalRhs = annJust &amp; localBinds &amp; annList &amp; localVal &amp; accessRhs</span></span>
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- | Check the extracted bindings right-hand-side for possible recursion
<span class="lineno">   98 </span>checkForRecursion :: GHC.Name -&gt; Rhs -&gt; LocalRefactor ()
<span class="lineno">   99 </span><span class="decl"><span class="istickedoff">checkForRecursion n = void . (biplateRef !| checkNameForRecursion n)</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>checkNameForRecursion :: GHC.Name -&gt; AST.Name -&gt; LocalRefactor ()
<span class="lineno">  102 </span><span class="decl"><span class="istickedoff">checkNameForRecursion name n</span>
<span class="lineno">  103 </span><span class="spaces">  </span><span class="istickedoff">| semanticsName (n ^. simpleName) == Just name</span>
<span class="lineno">  104 </span><span class="spaces">  </span><span class="istickedoff">= refactError $ <span class="nottickedoff">&quot;Cannot inline definitions containing direct recursion. Recursive call at: &quot;</span></span>
<span class="lineno">  105 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">++ shortShowSpanWithFile (getRange n)</span></span>
<span class="lineno">  106 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return <span class="nottickedoff">()</span></span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- | As a top-down transformation, replaces the occurrences of the binding with generated expressions. This method passes
<span class="lineno">  109 </span>-- the captured arguments of the function call to generate simpler results.
<span class="lineno">  110 </span>replaceInvocations :: RealSrcSpan -&gt; GHC.Name -&gt; ([[GHC.Name]] -&gt; [Expr] -&gt; Expr) -&gt; Expr 
<span class="lineno">  111 </span>                        -&gt; StateT Bool LocalRefactor Expr
<span class="lineno">  112 </span><span class="decl"><span class="istickedoff">replaceInvocations bindingRange name replacement expr</span>
<span class="lineno">  113 </span><span class="spaces">  </span><span class="istickedoff">| (Var n, args) &lt;- splitApps expr</span>
<span class="lineno">  114 </span><span class="spaces">  </span><span class="istickedoff">, semanticsName (n ^. simpleName) == Just name</span>
<span class="lineno">  115 </span><span class="spaces">  </span><span class="istickedoff">= do put True</span>
<span class="lineno">  116 </span><span class="spaces">       </span><span class="istickedoff">replacement (map (map (^. _1)) $ semanticsScope expr)</span>
<span class="lineno">  117 </span><span class="spaces">         </span><span class="istickedoff">&lt;$&gt; mapM (descendM (replaceInvocations <span class="nottickedoff">bindingRange</span> name replacement)) args</span>
<span class="lineno">  118 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span></span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="istickedoff">= descendM (replaceInvocations <span class="nottickedoff">bindingRange</span> name replacement) expr</span></span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>-- | Splits an application into function and arguments. Works also for operators.
<span class="lineno">  122 </span>splitApps :: Expr -&gt; (Expr, [Expr])
<span class="lineno">  123 </span><span class="decl"><span class="istickedoff">splitApps (App f a) = case splitApps f of (fun, args) -&gt; (fun, args ++ [a])</span>
<span class="lineno">  124 </span><span class="spaces"></span><span class="istickedoff">splitApps (InfixApp l (NormalOp qn) r) = (mkVar (mkParenName qn), [l,r])</span>
<span class="lineno">  125 </span><span class="spaces"></span><span class="istickedoff">splitApps (InfixApp l (BacktickOp qn) r) = <span class="nottickedoff">(mkVar (mkNormalName qn), [l,r])</span></span>
<span class="lineno">  126 </span><span class="spaces"></span><span class="istickedoff">splitApps (Paren expr) = splitApps expr</span>
<span class="lineno">  127 </span><span class="spaces"></span><span class="istickedoff">splitApps expr = (expr, [])</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- | Rejoins the function and the arguments as an expression.
<span class="lineno">  130 </span>joinApps :: Expr -&gt; [Expr] -&gt; Expr
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">joinApps f [] = f</span>
<span class="lineno">  132 </span><span class="spaces"></span><span class="istickedoff">joinApps f args = parenIfNeeded (foldl mkApp f args)</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- | Create an expression that is equivalent to calling the given bind.
<span class="lineno">  135 </span>createReplacement :: ValueBind -&gt; LocalRefactor ([[GHC.Name]] -&gt; [Expr] -&gt; Expr)
<span class="lineno">  136 </span><span class="decl"><span class="istickedoff">createReplacement (SimpleBind (VarPat _) (UnguardedRhs e) locals)</span>
<span class="lineno">  137 </span><span class="spaces">  </span><span class="istickedoff">= return $ \_ args -&gt; joinApps (parenIfNeeded $ wrapLocals locals e) args</span>
<span class="lineno">  138 </span><span class="spaces"></span><span class="istickedoff">createReplacement (SimpleBind _ _ _)</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="istickedoff">= <span class="nottickedoff">refactError &quot;Cannot inline, illegal simple bind. Only variable left-hand sides and unguarded right-hand sides are accepted.&quot;</span></span>
<span class="lineno">  140 </span><span class="spaces"></span><span class="istickedoff">createReplacement (FunctionBind (AnnList [Match lhs (UnguardedRhs expr) locals]))</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="istickedoff">= return $ \_ args -&gt; let (argReplacement, matchedPats, appliedArgs) = matchArguments (getArgsOf lhs) args</span>
<span class="lineno">  142 </span><span class="spaces">                         </span><span class="istickedoff">in joinApps (parenIfNeeded (createLambda matchedPats (wrapLocals locals (replaceExprs argReplacement expr)))) appliedArgs</span>
<span class="lineno">  143 </span><span class="spaces">  </span><span class="istickedoff">where getArgsOf (MatchLhs _ (AnnList args)) = args</span>
<span class="lineno">  144 </span><span class="spaces">        </span><span class="istickedoff">getArgsOf (InfixLhs lhs _ rhs (AnnList more)) = lhs:rhs:more</span>
<span class="lineno">  145 </span><span class="spaces"></span><span class="istickedoff">createReplacement (FunctionBind matches)</span>
<span class="lineno">  146 </span><span class="spaces">                                                 </span><span class="istickedoff">-- function bind has at least one match</span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">= return $ \sc args -&gt; let numArgs = getArgNum (head (matches ^? annList &amp; matchLhs)) - length args</span>
<span class="lineno">  148 </span><span class="spaces">                             </span><span class="istickedoff">newArgs = take numArgs $ map mkName $ filter notInScope $ map ((&quot;x&quot; ++ ) . show @Int) [1..]</span>
<span class="lineno">  149 </span><span class="spaces">                             </span><span class="istickedoff">notInScope str = not $ any (any ((== str) . occNameString . getOccName)) sc</span>
<span class="lineno">  150 </span><span class="spaces">                          </span><span class="istickedoff">in parenIfNeeded $ createLambda (map mkVarPat newArgs)</span>
<span class="lineno">  151 </span><span class="spaces">                                           </span><span class="istickedoff">$ mkCase (mkTuple $ map mkVar newArgs ++ args)</span>
<span class="lineno">  152 </span><span class="spaces">                                           </span><span class="istickedoff">$ map replaceMatch (matches ^? annList)</span>
<span class="lineno">  153 </span><span class="spaces">  </span><span class="istickedoff">where getArgNum (MatchLhs _ (AnnList args)) = length args</span>
<span class="lineno">  154 </span><span class="spaces">        </span><span class="istickedoff">getArgNum (InfixLhs _ _ _ (AnnList more)) = <span class="nottickedoff">length more + 2</span></span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>-- | Replaces names with expressions according to a mapping.
<span class="lineno">  157 </span>replaceExprs :: [(GHC.Name, Expr)] -&gt; Expr -&gt; Expr
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">replaceExprs [] = id</span>
<span class="lineno">  159 </span><span class="spaces"></span><span class="istickedoff">replaceExprs replaces = (uniplateRef .-) $ \case</span>
<span class="lineno">  160 </span><span class="spaces">    </span><span class="istickedoff">Var n | Just name &lt;- semanticsName (n ^. simpleName)</span>
<span class="lineno">  161 </span><span class="spaces">          </span><span class="istickedoff">, Just replace &lt;- lookup name replaces</span>
<span class="lineno">  162 </span><span class="spaces">          </span><span class="istickedoff">-&gt; replace</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="istickedoff">e -&gt; e</span></span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>-- | Matches a pattern list with an expression list and generates bindings. Matches until an argument cannot be matched.
<span class="lineno">  166 </span>matchArguments :: [Pattern] -&gt; [Expr] -&gt; ([(GHC.Name, Expr)], [Pattern], [Expr])
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff">matchArguments (ParenPat p : pats) exprs = matchArguments (p:pats) exprs</span>
<span class="lineno">  168 </span><span class="spaces"></span><span class="istickedoff">matchArguments (p:pats) (e:exprs)</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="istickedoff">| Just replacement &lt;- staticPatternMatch p e</span>
<span class="lineno">  170 </span><span class="spaces">  </span><span class="istickedoff">= case matchArguments pats exprs of (replacements, patterns, expressions) -&gt; (replacement ++ replacements, patterns, expressions)</span>
<span class="lineno">  171 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span></span>
<span class="lineno">  172 </span><span class="spaces">  </span><span class="istickedoff">= ([], p:pats, e:exprs)</span>
<span class="lineno">  173 </span><span class="spaces"></span><span class="istickedoff">matchArguments pats [] = ([], pats, [])</span>
<span class="lineno">  174 </span><span class="spaces"></span><span class="istickedoff">matchArguments [] exprs = <span class="nottickedoff">([], [], exprs)</span></span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>-- | Matches a pattern with an expression. Generates a mapping of names to expressions.
<span class="lineno">  177 </span>staticPatternMatch :: Pattern -&gt; Expr -&gt; Maybe [(GHC.Name, Expr)]
<span class="lineno">  178 </span><span class="decl"><span class="istickedoff">staticPatternMatch (VarPat n) e</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">| Just name &lt;- semanticsName $ n ^. simpleName</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">= Just [(name, e)]</span>
<span class="lineno">  181 </span><span class="spaces"></span><span class="istickedoff">staticPatternMatch (AppPat n (AnnList args)) e</span>
<span class="lineno">  182 </span><span class="spaces">  </span><span class="istickedoff">| (Var n', exprs) &lt;- splitApps e</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="istickedoff">, length args == length exprs</span>
<span class="lineno">  184 </span><span class="spaces">      </span><span class="istickedoff">&amp;&amp; semanticsName (n ^. simpleName) == semanticsName (n' ^. simpleName)</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="istickedoff">, Just subs &lt;- sequence $ zipWith staticPatternMatch args exprs</span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">= Just $ concat subs</span>
<span class="lineno">  187 </span><span class="spaces"></span><span class="istickedoff">staticPatternMatch (TuplePat (AnnList pats)) (Tuple (AnnList args))</span>
<span class="lineno">  188 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">length pats == length args</span></span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="istickedoff">, Just subs &lt;- <span class="nottickedoff">sequence $ zipWith staticPatternMatch pats args</span></span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">= <span class="nottickedoff">Just $ concat subs</span></span>
<span class="lineno">  191 </span><span class="spaces"></span><span class="istickedoff">staticPatternMatch _ _ = Nothing</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>replaceMatch :: Match -&gt; Alt
<span class="lineno">  194 </span><span class="decl"><span class="istickedoff">replaceMatch (Match lhs rhs locals) = mkAlt (toPattern lhs) (toAltRhs rhs) (locals ^? annJust)</span>
<span class="lineno">  195 </span><span class="spaces">  </span><span class="istickedoff">where toPattern (MatchLhs _ (AnnList pats)) = mkTuplePat pats</span>
<span class="lineno">  196 </span><span class="spaces">        </span><span class="istickedoff">toPattern (InfixLhs lhs _ rhs (AnnList more)) = <span class="nottickedoff">mkTuplePat (lhs:rhs:more)</span></span>
<span class="lineno">  197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  198 </span><span class="spaces">        </span><span class="istickedoff">toAltRhs (UnguardedRhs expr) = mkCaseRhs expr</span>
<span class="lineno">  199 </span><span class="spaces">        </span><span class="istickedoff">toAltRhs (GuardedRhss (AnnList rhss)) = mkGuardedCaseRhss (map toAltGuardedRhs rhss)</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  201 </span><span class="spaces">        </span><span class="istickedoff">toAltGuardedRhs (GuardedRhs (AnnList guards) expr) = mkGuardedCaseRhs guards expr</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>wrapLocals :: MaybeLocalBinds -&gt; Expr -&gt; Expr
<span class="lineno">  204 </span><span class="decl"><span class="istickedoff">wrapLocals bnds = case bnds ^? annJust &amp; localBinds &amp; annList of</span>
<span class="lineno">  205 </span><span class="spaces">                    </span><span class="istickedoff">[] -&gt; id</span>
<span class="lineno">  206 </span><span class="spaces">                    </span><span class="istickedoff">localBinds -&gt; mkLet localBinds</span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | True for patterns that need to be parenthesized if in a lambda
<span class="lineno">  209 </span>compositePat :: Pattern -&gt; Bool
<span class="lineno">  210 </span><span class="decl"><span class="istickedoff">compositePat (AppPat {}) = True</span>
<span class="lineno">  211 </span><span class="spaces"></span><span class="istickedoff">compositePat (InfixAppPat {}) = <span class="nottickedoff">True</span></span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff">compositePat (TypeSigPat {}) = <span class="nottickedoff">True</span></span>
<span class="lineno">  213 </span><span class="spaces"></span><span class="istickedoff">compositePat (ViewPat {}) = <span class="nottickedoff">True</span></span>
<span class="lineno">  214 </span><span class="spaces"></span><span class="istickedoff">compositePat _ = False</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>parenIfNeeded :: Expr -&gt; Expr
<span class="lineno">  217 </span><span class="decl"><span class="istickedoff">parenIfNeeded e = if compositeExprs e then mkParen e else e</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>-- | True for expresssions that need to be parenthesized if in application
<span class="lineno">  220 </span>compositeExprs :: Expr -&gt; Bool
<span class="lineno">  221 </span><span class="decl"><span class="istickedoff">compositeExprs (App {}) = True</span>
<span class="lineno">  222 </span><span class="spaces"></span><span class="istickedoff">compositeExprs (InfixApp {}) = True</span>
<span class="lineno">  223 </span><span class="spaces"></span><span class="istickedoff">compositeExprs (Lambda {}) = True</span>
<span class="lineno">  224 </span><span class="spaces"></span><span class="istickedoff">compositeExprs (Let {}) = True</span>
<span class="lineno">  225 </span><span class="spaces"></span><span class="istickedoff">compositeExprs (If {}) = <span class="nottickedoff">True</span></span>
<span class="lineno">  226 </span><span class="spaces"></span><span class="istickedoff">compositeExprs (Case {}) = True</span>
<span class="lineno">  227 </span><span class="spaces"></span><span class="istickedoff">compositeExprs (Do {}) = <span class="nottickedoff">True</span></span>
<span class="lineno">  228 </span><span class="spaces"></span><span class="istickedoff">compositeExprs _ = False</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>createLambda :: [Pattern] -&gt; Expr -&gt; Expr
<span class="lineno">  231 </span><span class="decl"><span class="istickedoff">createLambda [] = id</span>
<span class="lineno">  232 </span><span class="spaces"></span><span class="istickedoff">createLambda pats = mkLambda (map (\p -&gt; if compositePat p then mkParenPat p else p) pats)</span></span>

</pre>
</body>
</html>
