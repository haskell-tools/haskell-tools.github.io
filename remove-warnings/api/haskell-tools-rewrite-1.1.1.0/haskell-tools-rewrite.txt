-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Facilities for generating new parts of the Haskell-Tools AST
--   
--   Contains utility functions to generate parts of the Haskell-Tools AST.
--   Generates these elements to be compatible with the source annotations
--   that are already present on the AST. The package is divided into
--   modules based on which language elements can the given module
--   generate. This packages should be used during the transformations to
--   generate parts of the new AST.
@package haskell-tools-rewrite
@version 1.1.1.0

module Language.Haskell.Tools.Rewrite.ElementTypes
type AnnList node = AnnListG node IdDom SrcTemplateStage
type AnnMaybe node = AnnMaybeG node IdDom SrcTemplateStage

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
type Module = Ann UModule IdDom SrcTemplateStage

-- | Module declaration with name and (optional) exports
type ModuleHead = Ann UModuleHead IdDom SrcTemplateStage

-- | A list of export specifications surrounded by parentheses
type ExportSpecs = Ann UExportSpecs IdDom SrcTemplateStage

-- | Export specifier
type ExportSpec = Ann UExportSpec IdDom SrcTemplateStage

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
type IESpec = Ann UIESpec IdDom SrcTemplateStage

-- | Specifies the imported element
type ImportModifier = Ann UImportModifier IdDom SrcTemplateStage

-- | Marks how related names will be imported or exported with a given name
type SubSpec = Ann USubSpec IdDom SrcTemplateStage

-- | Pragmas that must be used after the module head
type ModulePragma = Ann UModulePragma IdDom SrcTemplateStage

-- | Pragmas that must be used before defining the module
type FilePragma = Ann UFilePragma IdDom SrcTemplateStage

-- | An import declaration: <tt>import Module.Name</tt>
type ImportDecl = Ann UImportDecl IdDom SrcTemplateStage

-- | Restriction on the imported names
type ImportSpec = Ann UImportSpec IdDom SrcTemplateStage

-- | Marks the import as qualified: <tt>qualified</tt>
type ImportQualified = Ann UImportQualified IdDom SrcTemplateStage

-- | Marks the import as source: <tt>{-# SOURCE #-}</tt>
type ImportSource = Ann UImportSource IdDom SrcTemplateStage

-- | Marks the import as safe: <tt>safe</tt>
type ImportSafe = Ann UImportSafe IdDom SrcTemplateStage

-- | Marks an imported name to belong to the type namespace: <tt>type</tt>
type TypeNamespace = Ann UTypeNamespace IdDom SrcTemplateStage

-- | Renaming imports (<tt> as A </tt>)
type ImportRenaming = Ann UImportRenaming IdDom SrcTemplateStage

-- | The name of a module
type ModuleName = Ann UModuleName IdDom SrcTemplateStage

-- | The name of the enabled language extension, for example (<tt>
--   LambdaCase </tt>)
type LanguageExtension = Ann ULanguageExtension IdDom SrcTemplateStage

-- | Haskell declaration
type Decl = Ann UDecl IdDom SrcTemplateStage

-- | The list of declarations that can appear in a typeclass
type ClassBody = Ann UClassBody IdDom SrcTemplateStage

-- | Members of a class declaration
type ClassElement = Ann UClassElement IdDom SrcTemplateStage
type DeclHead = Ann UDeclHead IdDom SrcTemplateStage

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
type InstBody = Ann UInstBody IdDom SrcTemplateStage

-- | Declarations inside an instance declaration.
type InstBodyDecl = Ann UInstBodyDecl IdDom SrcTemplateStage

-- | GADT constructor declaration (<tt> D1 :: { val :: Int } -&gt; T String
--   </tt>)
type GadtConDecl = Ann UGadtConDecl IdDom SrcTemplateStage

-- | Type of GADT constructors (can be record types: <tt>{ val :: Int
--   }</tt>)
type GadtConType = Ann UGadtConType IdDom SrcTemplateStage

-- | Marker for a field wildcard. Only needed to attach semantic
--   information in a type-safe way.
type FieldWildcard = Ann UFieldWildcard IdDom SrcTemplateStage

-- | A list of functional dependencies: <tt> | a -&gt; b, c -&gt; d </tt>
--   separated by commas
type FunDeps = Ann UFunDeps IdDom SrcTemplateStage

-- | A functional dependency, given on the form <tt>l1 ... ln -&gt; r1 ...
--   rn</tt>
type FunDep = Ann UFunDep IdDom SrcTemplateStage

-- | A constructor declaration for a datatype
type ConDecl = Ann UConDecl IdDom SrcTemplateStage

-- | The <tt>data</tt> or the <tt>newtype</tt> keyword to define ADTs.
type DataOrNewtypeKeyword = Ann UDataOrNewtypeKeyword IdDom SrcTemplateStage

-- | Field declaration (<tt> fld :: Int </tt>)
type FieldDecl = Ann UFieldDecl IdDom SrcTemplateStage

-- | A deriving clause following a data type declaration. (<tt> deriving
--   Show </tt> or <tt> deriving (Show, Eq) </tt>)
type Deriving = Ann UDeriving IdDom SrcTemplateStage

-- | A deriving strategy (<tt>stock</tt>, <tt>newtype</tt> or
--   <tt>anyclass</tt>)
type DeriveStrategy = Ann UDeriveStrategy IdDom SrcTemplateStage

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the where keyword.
type InstanceRule = Ann UInstanceRule IdDom SrcTemplateStage

-- | The specification of the class instance declaration
type InstanceHead = Ann UInstanceHead IdDom SrcTemplateStage

-- | Specialize pragma (<tt> {--} </tt>)
type SpecializePragma = Ann USpecializePragma IdDom SrcTemplateStage

-- | Overlap pragmas. Can be applied to class declarations and class
--   instance declarations.
type OverlapPragma = Ann UOverlapPragma IdDom SrcTemplateStage

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
type TypeEqn = Ann UTypeEqn IdDom SrcTemplateStage

-- | Top level pragmas
type TopLevelPragma = Ann UTopLevelPragma IdDom SrcTemplateStage

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
type Rule = Ann URule IdDom SrcTemplateStage

-- | A variable for a rewrite rule. With or without type signature.
type RuleVar = Ann URuleVar IdDom SrcTemplateStage

-- | Annotation allows you to connect an expression to any declaration.
type AnnotationSubject = Ann UAnnotationSubject IdDom SrcTemplateStage

-- | Formulas of minimal annotations declaring which functions should be
--   defined.
type MinimalFormula = Ann UMinimalFormula IdDom SrcTemplateStage

-- | In-AST source ranges (for generated pragmas)
type SourceRange = Ann USourceRange IdDom SrcTemplateStage

-- | Open type and data families
type TypeFamily = Ann UTypeFamily IdDom SrcTemplateStage

-- | Type family specification with kinds specification and injectivity.
type TypeFamilySpec = Ann UTypeFamilySpec IdDom SrcTemplateStage

-- | Injectivity annotation for type families (<tt> = r | r -&gt; a </tt>)
type InjectivityAnn = Ann UInjectivityAnn IdDom SrcTemplateStage

-- | Pattern synonyms: <tt> pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
--   </tt>
type PatternSynonym = Ann UPatternSynonym IdDom SrcTemplateStage

-- | Right-hand side of pattern synonym
type PatSynRhs = Ann UPatSynRhs IdDom SrcTemplateStage

-- | Left hand side of a pattern synonym
type PatSynLhs = Ann UPatSynLhs IdDom SrcTemplateStage

-- | Where clause of pattern synonym (explicit expression direction)
type PatSynWhere = Ann UPatSynWhere IdDom SrcTemplateStage

-- | Pattern type signature declaration (<tt> pattern Succ :: Int -&gt; Int
--   </tt>)
type PatternSignature = Ann UPatternTypeSignature IdDom SrcTemplateStage

-- | Role annotations for types
type Role = Ann URole IdDom SrcTemplateStage

-- | Call conventions of foreign functions
type CallConv = Ann UCallConv IdDom SrcTemplateStage

-- | Safety annotations for foreign calls
type Safety = Ann USafety IdDom SrcTemplateStage

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
type ConlikeAnnot = Ann UConlikeAnnot IdDom SrcTemplateStage

-- | Controls the activation of a rewrite rule (<tt> [1] </tt>)
type PhaseControl = Ann UPhaseControl IdDom SrcTemplateStage

-- | Value binding for top-level and local bindings
type ValueBind = Ann UValueBind IdDom SrcTemplateStage

-- | Clause of function binding
type Match = Ann UMatch IdDom SrcTemplateStage

-- | Something on the left side of the match
type MatchLhs = Ann UMatchLhs IdDom SrcTemplateStage

-- | Right hand side of a value binding (possible with guards): (<tt> = 3
--   </tt> or <tt> | x == 1 = 3; | otherwise = 4 </tt>)
type Rhs = Ann URhs IdDom SrcTemplateStage

-- | A guarded right-hand side of a value binding (<tt> | x &gt; 3 = 2
--   </tt>)
type GuardedRhs = Ann UGuardedRhs IdDom SrcTemplateStage

-- | Guards for value bindings and pattern matches (<tt> Just v <a>x, v</a>
--   1 </tt>)
type RhsGuard = Ann URhsGuard IdDom SrcTemplateStage

-- | Bindings that are enabled in local blocks (where or let).
type LocalBind = Ann ULocalBind IdDom SrcTemplateStage

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
type LocalBinds = Ann ULocalBinds IdDom SrcTemplateStage

-- | A fixity signature (<tt> infixl 5 +, - </tt>).
type FixitySignature = Ann UFixitySignature IdDom SrcTemplateStage

-- | A type signature (<tt> f :: Int -&gt; Int </tt>)
type TypeSignature = Ann UTypeSignature IdDom SrcTemplateStage

-- | Haskell types
type Type = Ann UType IdDom SrcTemplateStage

-- | Type variable declarations (with possible kind annotation)
type TyVar = Ann UTyVar IdDom SrcTemplateStage
type Context = Ann UContext IdDom SrcTemplateStage

-- | A single assertion in the context
type Assertion = Ann UAssertion IdDom SrcTemplateStage

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
type KindConstraint = Ann UKindConstraint IdDom SrcTemplateStage

-- | Haskell kinds
type Kind = Ann UKind IdDom SrcTemplateStage

-- | Values promoted to the kind level
type PromotedKind = Ann (UPromoted UKind) IdDom SrcTemplateStage

-- | Haskell expressions
type Expr = Ann UExpr IdDom SrcTemplateStage

-- | Clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
type Alt = Ann UAlt IdDom SrcTemplateStage

-- | Right hand side of a match (possible with guards): (<tt> -&gt; 3 </tt>
--   or <tt> | x == 1 -&gt; 3; | otherwise -&gt; 4 </tt>)
type CaseRhs = Ann UCaseRhs IdDom SrcTemplateStage

-- | A guarded right-hand side of pattern matches binding (<tt> | x &gt; 3
--   -&gt; 2 </tt>)
type GuardedCaseRhs = Ann UGuardedCaseRhs IdDom SrcTemplateStage

-- | Field update expressions
type FieldUpdate = Ann UFieldUpdate IdDom SrcTemplateStage

-- | An element of a tuple section that can be an expression or missing
--   (indicating a value from a parameter)
type TupSecElem = Ann UTupSecElem IdDom SrcTemplateStage

-- | Pragmas that can be applied to expressions
type ExprPragma = Ann UExprPragma IdDom SrcTemplateStage

-- | Special expressions for arrows
type Cmd = Ann UCmd IdDom SrcTemplateStage

-- | Clause of case expression for commands
type CmdAlt = Ann UCmdAlt IdDom SrcTemplateStage

-- | Arrow directions
type ArrowApp = Ann UArrowAppl IdDom SrcTemplateStage

-- | A statement in a do-notation
type Stmt = Ann UStmt IdDom SrcTemplateStage

-- | Keywords <tt>do</tt> or <tt>mdo</tt> to start a do-block
type DoKind = Ann UDoKind IdDom SrcTemplateStage

-- | List comprehension statement
type CompStmt = Ann UCompStmt IdDom SrcTemplateStage

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
type ListCompBody = Ann UListCompBody IdDom SrcTemplateStage

-- | A do-notation for arrows
type CmdStmt = Ann UCmdStmt IdDom SrcTemplateStage

-- | Representation of patterns for pattern bindings
type Pattern = Ann UPattern IdDom SrcTemplateStage
type PatternField = Ann UPatternField IdDom SrcTemplateStage

-- | A template haskell splice
type Splice = Ann USplice IdDom SrcTemplateStage

-- | Template Haskell bracket expressions
type Bracket = Ann UBracket IdDom SrcTemplateStage

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
type QuasiQuote = Ann UQuasiQuote IdDom SrcTemplateStage

-- | Haskell literals
type Literal = Ann ULiteral IdDom SrcTemplateStage

-- | A definition that functions as an operator
type Operator = Ann UOperator IdDom SrcTemplateStage

-- | A definition that functions as a name
type Name = Ann UName IdDom SrcTemplateStage

-- | Possible qualified names. Contains also implicit names. Linear
--   implicit parameter: <tt>%x</tt>. Non-linear implicit parameter:
--   <tt>?x</tt>.
type QualifiedName = Ann UQualifiedName IdDom SrcTemplateStage

-- | Parts of a qualified name.
type NamePart = Ann UNamePart IdDom SrcTemplateStage

-- | Program elements formatted as string literals (import packages, pragma
--   texts)
type StringNode = Ann UStringNode IdDom SrcTemplateStage
type MaybeContext = AnnMaybe UContext
type MaybeDeriving = AnnMaybe UDeriving
type MaybeDeriveStrategy = AnnMaybe UDeriveStrategy
type MaybeLocalBinds = AnnMaybe ULocalBinds
type MaybeTypeFamilySpec = AnnMaybe UTypeFamilySpec
type MaybeKindConstraint = AnnMaybe UKindConstraint
type MaybeClassBody = AnnMaybe UClassBody
type MaybeInstBody = AnnMaybe UInstBody
type MaybeExpr = AnnMaybe UExpr
type MaybeExportSpecs = AnnMaybe UExportSpecs
type MaybeImportQualified = AnnMaybe UImportQualified
type MaybeImportSource = AnnMaybe UImportSource
type MaybeImportSafe = AnnMaybe UImportSafe
type MaybeImportSpec = AnnMaybe UImportSpec
type MaybeModuleHead = AnnMaybe UModuleHead
type MaybeImportModifier = AnnMaybe UImportModifier
type MaybeModulePragma = AnnMaybe UModulePragma
type MaybeSubSpec = AnnMaybe USubSpec
type MaybeStringNode = AnnMaybe UStringNode
type MaybeImportRenaming = AnnMaybe UImportRenaming
type MaybeSafety = AnnMaybe USafety
type MaybePhaseControl = AnnMaybe UPhaseControl
type MaybeConlikeAnnot = AnnMaybe UConlikeAnnot
type MaybeFunDeps = AnnMaybe UFunDeps
type MatchList = AnnList UMatch
type DeclList = AnnList UDecl
type PatternList = AnnList UPattern
type OperatorList = AnnList UOperator
type NameList = AnnList UName
type LocalBindList = AnnList ULocalBind
type IESpecList = AnnList UIESpec
type RhsGuardList = AnnList URhsGuard
type GuardedRhsList = AnnList UGuardedRhs
type GuardedCaseRhsList = AnnList UGuardedCaseRhs
type ConDeclList = AnnList UConDecl
type TypeEqnList = AnnList UTypeEqn
type TypeList = AnnList UType
type FieldDeclList = AnnList UFieldDecl
type ExprList = AnnList UExpr
type FieldUpdateList = AnnList UFieldUpdate
type GadtConDeclList = AnnList UGadtConDecl
type ClassElementList = AnnList UClassElement
type InstBodyDeclList = AnnList UInstBodyDecl
type InstanceHeadList = AnnList UInstanceHead
type AltList = AnnList UAlt
type StmtList = AnnList UStmt
type KindList = AnnList UKind
type TyVarList = AnnList UTyVar
type ListCompBodyList = AnnList UListCompBody
type ExportSpecList = AnnList UExportSpec
type FilePragmaList = AnnList UFilePragma
type ImportDeclList = AnnList UImportDecl
type PatternFieldList = AnnList UPatternField
type AssertionList = AnnList UAssertion
type CompStmtList = AnnList UCompStmt
type RuleList = AnnList URule
type RuleVarList = AnnList URuleVar
type RoleList = AnnList URole
type MinimalFormulaList = AnnList UMinimalFormula
type FunDepList = AnnList UFunDep
type TupSecElemList = AnnList UTupSecElem
type CmdList = AnnList UCmd
type CmdAltList = AnnList UCmdAlt
type CmdStmtList = AnnList UCmdStmt
type LanguageExtensionList = AnnList ULanguageExtension
type StringNodeList = AnnList UStringNode
type NamePartList = AnnList UNamePart
type DerivingList = AnnList UDeriving


-- | Generation of Template Haskell AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Create.TH

-- | A simple name splice: <tt>$generateX</tt>
mkIdSplice :: Name -> Splice

-- | A splice with parentheses: <tt>$(generate input)</tt>
mkParenSplice :: Expr -> Splice

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
mkQuasiQuote :: Name -> String -> QuasiQuote

-- | Expression bracket (<tt> [| x + y |] </tt>)
mkExprBracket :: Expr -> Bracket

-- | Pattern bracket (<tt> [p| Point x y |] </tt>)
mkPatternBracket :: Pattern -> Bracket

-- | Type bracket (<tt> [t| (Int,Int) |] </tt>)
mkTypeBracket :: Type -> Bracket

-- | Declaration bracket (<tt> [d| f :: Int -&gt; Int; f x = x*x |] </tt>)
mkDeclsBracket :: [Decl] -> Bracket


-- | Generation of statement-level AST fragments for refactorings. The
--   bindings defined here are the AST constructor names with an "mk"
--   prefix.
module Language.Haskell.Tools.Rewrite.Create.Stmts

-- | Creates a binding statement (<tt> x &lt;- action </tt>)
mkBindStmt :: Pattern -> Expr -> Stmt

-- | Creates a non-binding statement (<tt> action </tt>)
mkExprStmt :: Expr -> Stmt

-- | Creates a let statement (<tt> let x = 3; y = 4 </tt>)
mkLetStmt :: [LocalBind] -> Stmt

-- | Creates a recursive binding statement with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
mkRecStmt :: [Stmt] -> Stmt

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
mkListCompBody :: [CompStmt] -> ListCompBody

-- | Normal monadic statement of a list comprehension
mkCompStmt :: Stmt -> CompStmt

-- | Then statements by <tt>TransformListComp</tt> (<tt> then sortWith by
--   (x + y) </tt>)
mkThenStmt :: Expr -> Maybe Expr -> CompStmt

-- | Grouping statements by <tt>TransformListComp</tt> (<tt> then group by
--   (x + y) using groupWith </tt>)
mkGroupStmt :: Maybe Expr -> Maybe Expr -> CompStmt

-- | Creates a binding command (<tt> x &lt;- action </tt>)
mkBindCmd :: Pattern -> Cmd -> CmdStmt

-- | Creates a non-binding command (<tt> action </tt>)
mkExprCmd :: Cmd -> CmdStmt

-- | Creates a let command (<tt> let x = 3; y = 4 </tt>)
mkLetStmtCmd :: [LocalBind] -> CmdStmt

-- | Creates a recursive binding command with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
mkRecCmd :: [CmdStmt] -> CmdStmt


-- | Generation of pattern-level AST fragments for refactorings. The
--   bindings defined here create a the annotated version of the AST
--   constructor with the same name. For example, <tt>mkVarPat</tt> creates
--   the annotated version of the <tt>VarPat</tt> AST constructor.
module Language.Haskell.Tools.Rewrite.Create.Patterns

-- | Pattern name binding
mkVarPat :: Name -> Pattern

-- | Literal pattern
mkLitPat :: Literal -> Pattern

-- | Infix constructor application pattern (<tt> a :+: b </tt>)
mkInfixAppPat :: Pattern -> Operator -> Pattern -> Pattern

-- | Constructor application pattern (<tt> Point x y </tt>)
mkAppPat :: Name -> [Pattern] -> Pattern

-- | Tuple pattern (<tt> (x,y) </tt>)
mkTuplePat :: [Pattern] -> Pattern

-- | Unboxed tuple pattern (<tt> (# x, y #) </tt>)
mkUnboxTuplePat :: [Pattern] -> Pattern

-- | List pattern (<tt> [1,2,a,x] </tt>)
mkListPat :: [Pattern] -> Pattern

-- | Parallel array pattern (<tt> [:1,2,a,x:] </tt>)
mkParArrayPat :: [Pattern] -> Pattern

-- | Parenthesised patterns
mkParenPat :: Pattern -> Pattern

-- | Record pattern (<tt> Point { x = 3, y } </tt>)
mkRecPat :: Name -> [PatternField] -> Pattern

-- | As-pattern (explicit name binding) (<tt> ls@(hd:_) </tt>)
mkAsPat :: Name -> Pattern -> Pattern

-- | Wildcard pattern: (<tt> _ </tt>)
mkWildPat :: Pattern

-- | Irrefutable pattern (<tt> ~(x:_) </tt>)
mkIrrefutablePat :: Pattern -> Pattern

-- | Bang pattern (<tt> !x </tt>)
mkBangPat :: Pattern -> Pattern

-- | Pattern with explicit type signature (<tt> x :: Int </tt>)
mkTypeSigPat :: Pattern -> Type -> Pattern

-- | View pattern (<tt> f -&gt; Just 1 </tt>)
mkViewPat :: Expr -> Pattern -> Pattern

-- | Splice patterns: <tt>$(generateX inp)</tt>
mkSplicePat :: Splice -> Pattern

-- | Quasi-quoted patterns: <tt>[| 1 + 2 |]</tt>
mkQuasiQuotePat :: QuasiQuote -> Pattern

-- | Named field pattern (<tt> p = Point 3 2 </tt>)
mkPatternField :: Name -> Pattern -> PatternField

-- | Named field pun (<tt> p </tt>)
mkFieldPunPattern :: Name -> PatternField

-- | Wildcard field pattern (<tt> .. </tt>)
mkFieldWildcardPattern :: PatternField


-- | Generation of names for refactorings
module Language.Haskell.Tools.Rewrite.Create.Names

-- | Creates a simple, unqualified name
mkName :: String -> Name
mkQualOp :: [String] -> String -> Operator
mkBacktickOp :: [String] -> String -> Operator

-- | Creates an annotated qualified operator: <tt>A.B.+</tt> or
--   <tt>`A.B.mod`</tt>.
mkQualOp' :: [String] -> Name -> Operator

-- | Creates an annotated unqualified operator: <tt>+</tt> or
--   <tt>`mod`</tt>.
mkUnqualOp' :: Name -> Operator
mkUnqualOp :: String -> Operator

-- | Creates an annotated qualified (non-operator) binding name:
--   <tt>A.B.f</tt> or <tt>(A.B.+)</tt>
mkQualName' :: [String] -> Name -> Name

-- | Creates an annotated unqualified (non-operator) binding name:
--   <tt>f</tt> or <tt>(+)</tt>
mkUnqualName' :: Name -> Name
mkNormalName :: QualifiedName -> Name

-- | Creates a parenthesized name: <tt> foldl (+) 0 </tt>
mkParenName :: QualifiedName -> Name

-- | Creates an implicit name: <tt> ?var </tt>
mkImplicitName :: QualifiedName -> Name

-- | Creates an annotated qualified simple name
mkQualifiedName' :: [String] -> Name -> QualifiedName
mkQualifiedName :: [String] -> String -> QualifiedName

-- | Creates a part of a qualified name.
mkNamePart :: String -> NamePart

-- | Creates a simple (unqualified) name
mkSimpleName' :: Name -> QualifiedName

-- | Creates a simple (unqualified) name
mkSimpleName :: String -> QualifiedName

-- | Creates a quoted text
mkStringNode :: String -> StringNode


-- | Generation of UModule-level AST fragments for refactorings. The
--   bindings defined here create a the annotated version of the AST
--   constructor with the same name. For example, <tt>mkModule</tt> creates
--   the annotated version of the <tt>UModule</tt> AST constructor.
module Language.Haskell.Tools.Rewrite.Create.Modules

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
mkModule :: [FilePragma] -> Maybe ModuleHead -> [ImportDecl] -> [Decl] -> Module

-- | Module declaration with name and (optional) exports
mkModuleHead :: ModuleName -> Maybe ModulePragma -> Maybe ExportSpecs -> ModuleHead

-- | A list of export specifications surrounded by parentheses
mkExportSpecs :: [ExportSpec] -> ExportSpecs

-- | Export a name and related names
mkExportSpec :: IESpec -> ExportSpec

-- | The export of an imported module (<tt> module A </tt>)
mkModuleExport :: ModuleName -> ExportSpec

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
mkIESpec :: Name -> Maybe SubSpec -> IESpec

-- | Marks a pattern synonym to be imported or exported
mkPatternIESpec :: Name -> IESpec

-- | <tt>(a,b,c)</tt>: a class exported with some of its methods, or a
--   datatype exported with some of its constructors.
mkSubList :: [Name] -> SubSpec

-- | <tt>(..)</tt>: a class exported with all of its methods, or a datatype
--   exported with all of its constructors.
mkSubAll :: SubSpec

-- | An import declaration: <tt>import Module.Name</tt>
mkImportDecl :: Bool -> Bool -> Bool -> Maybe String -> ModuleName -> Maybe ModuleName -> Maybe ImportSpec -> ImportDecl

-- | Restrict the import definition to ONLY import the listed names
mkImportSpecList :: [IESpec] -> ImportSpec

-- | Restrict the import definition to DONT import the listed names
mkImportHidingList :: [IESpec] -> ImportSpec

-- | The name of a module
mkModuleName :: String -> ModuleName
mkFilePragmas :: [FilePragma] -> FilePragmaList

-- | <tt>LANGUAGE</tt> pragma, listing the enabled language extensions in
--   that file
mkLanguagePragma :: [String] -> FilePragma

-- | <tt>OPTIONS</tt> pragma, possibly qualified with a tool, e.g.
--   OPTIONS_GHC
mkOptionsGHC :: String -> FilePragma

-- | A warning pragma attached to the module
mkModuleWarningPragma :: [String] -> ModulePragma

-- | A deprecated pragma attached to the module
mkModuleDeprecatedPragma :: [String] -> ModulePragma


-- | Generation of literals for refactorings. The bindings defined here are
--   the AST constructor names with an "mk" prefix.
module Language.Haskell.Tools.Rewrite.Create.Literals

-- | Character literal: <tt><tt>c</tt></tt>
mkCharLit :: Char -> Literal

-- | String literal: <tt>"abc"</tt>
mkStringLit :: String -> Literal

-- | Integer literal: <tt>12</tt>
mkIntLit :: Integer -> Literal

-- | Fractional literal: <tt>3.14</tt>
mkFracLit :: Rational -> Literal

-- | Primitive integer literal (of type <tt>Int#</tt>): <tt>32#</tt>
mkPrimIntLit :: Integer -> Literal

-- | Primitive word literal (of type <tt>Word#</tt>): <tt>32##</tt>
mkPrimWordLit :: Integer -> Literal

-- | Primitive float literal (of type <tt>Float#</tt>): <tt>3.14#</tt>
mkPrimFloatLit :: Rational -> Literal

-- | Primitive double literal (of type <tt>Double#</tt>): <tt>3.14##</tt>
mkPrimDoubleLit :: Rational -> Literal

-- | Primitive character literal (of type <tt>Char#</tt>):
--   <tt><tt>c</tt>#</tt>
mkPrimCharLit :: Char -> Literal

-- | Primitive string literal (of type <tt>Addr#</tt>): <tt>"xxx"#</tt>
mkPrimStringLit :: String -> Literal


-- | Generation of statement-level AST fragments for refactorings. The
--   bindings defined here are the AST constructor names with an "mk"
--   prefix.
module Language.Haskell.Tools.Rewrite.Create.Kinds

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
mkKindConstraint :: Kind -> KindConstraint

-- | <tt>*</tt>, the kind of types
mkKindStar :: Kind

-- | <tt>#</tt>, the kind of unboxed types
mkKindUnbox :: Kind

-- | <tt>-&gt;</tt>, the kind of type constructor
mkKindFun :: Kind -> Kind -> Kind

-- | A parenthesised kind
mkKindParen :: Kind -> Kind

-- | Kind variable (using <tt>PolyKinds</tt> extension)
mkKindVar :: Name -> Kind

-- | Kind application (<tt> k1 k2 </tt>)
mkKindApp :: Kind -> Kind -> Kind

-- | A list kind (<tt> [k] </tt>)
mkKindList :: Kind -> Kind

-- | Numeric value promoted to the kind level.
mkIntKind :: Integer -> Kind

-- | String value promoted to the kind level.
mkStringKind :: String -> Kind

-- | A data constructor value promoted to the kind level.
mkConKind :: Name -> Kind

-- | A list of elements as a kind.
mkListKind :: [Kind] -> Kind

-- | A tuple of elements as a kind.
mkTupleKind :: [Kind] -> Kind

-- | Kind of the unit value <tt>()</tt>.
mkUnitKind :: Kind


-- | Generation of type-level AST fragments for refactorings. The bindings
--   defined here create a the annotated version of the AST constructor
--   with the same name. For example, <tt>mkTyForall</tt> creates the
--   annotated version of the <tt>TyForall</tt> AST constructor.
module Language.Haskell.Tools.Rewrite.Create.Types

-- | Forall types (<tt> forall x y . type </tt>)
mkForallType :: [TyVar] -> Type -> Type

-- | Simplified creation of type variables
mkTypeVar' :: Name -> TyVar

-- | Type with a context (<tt> forall x y . type </tt>)
mkCtxType :: Context -> Type -> Type

-- | Function types (<tt> a -&gt; b </tt>)
mkFunctionType :: Type -> Type -> Type

-- | Tuple types (<tt> (a,b) </tt>)
mkTupleType :: [Type] -> Type

-- | Unboxed tuple types (<tt> (#a,b#) </tt>)
mkUnboxedTupleType :: [Type] -> Type

-- | List type with special syntax (<tt> [a] </tt>)
mkListType :: Type -> Type

-- | Parallel array type (<tt> [:a:] </tt>)
mkParArrayType :: Type -> Type

-- | Type application (<tt> F a </tt>)
mkTypeApp :: Type -> Type -> Type

-- | Infix type constructor (<tt> (a &lt;: b) </tt>)
mkInfixTypeApp :: Type -> Operator -> Type -> Type

-- | Type surrounded by parentheses (<tt> (T a) </tt>)
mkParenType :: Type -> Type

-- | Creates a simple type variable
mkTypeVar :: Name -> TyVar

-- | Creates a type variable with kind specification (<tt> t :: * </tt>)
mkKindedTypeVar :: Name -> Kind -> TyVar

-- | Type variable or constructor (<tt> a </tt>)
mkVarType :: Name -> Type

-- | Type with explicit kind signature (<tt> a :: * </tt>)
mkKindedType :: Type -> Kind -> Type

-- | Strict type marked with <tt>!</tt>.
mkBangType :: Type -> Type

-- | Lazy type marked with <tt>~</tt>. (Should only be used if
--   <tt>Strict</tt> or <tt>StrictData</tt> language extension is used)
mkLazyType :: Type -> Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
mkUnpackType :: Type -> Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
mkNoUnpackType :: Type -> Type

-- | A wildcard type (<tt> _ </tt>) with <tt>-XPartialTypeSignatures</tt>
mkWildcardType :: Type

-- | A named wildcard type (<tt> _t </tt>) with
--   <tt>-XPartialTypeSignatures</tt>
mkNamedWildcardType :: Name -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
mkSpliceType :: Splice -> Type

-- | A Template Haskell quasi-quote type (<tt> [quoter| ... ] </tt>).
mkQuasiQuoteType :: QuasiQuote -> Type

-- | Numeric value promoted to the kind level.
mkPromotedIntType :: Integer -> Type

-- | String value promoted to the kind level.
mkPromotedStringType :: String -> Type

-- | A data constructor value promoted to the kind level.
mkPromotedConType :: Name -> Type

-- | A list of elements as a kind.
mkPromotedListType :: [Type] -> Type

-- | A tuple of elements as a kind.
mkPromotedTupleType :: [Type] -> Type

-- | Kind of the unit value <tt>()</tt>.
mkPromotedUnitType :: Type

-- | Creates a context of assertions (<tt> C a =&gt; ... </tt>)
mkContext :: Assertion -> Context

-- | Class assertion (<tt>Cls x</tt>)
mkClassAssert :: Name -> [Type] -> Assertion

-- | Infix class assertion, also contains type equations (<tt> a ~ X y
--   </tt>)
mkInfixAssert :: Type -> Operator -> Type -> Assertion

-- | Creates an assertion for implicit parameter binding (<tt> ?cmp :: a
--   -&gt; a -&gt; Bool </tt>)
mkImplicitAssert :: Name -> Type -> Assertion

-- | Creates a list of assertions (<tt> (Eq a, Show a) </tt>)
mkTupleAssertion :: [Assertion] -> Assertion


-- | Generation of expression-level AST fragments for refactorings. The
--   bindings defined here create a the annotated version of the AST
--   constructor with the same name. For example, <tt>mkApp</tt> creates
--   the annotated version of the <tt>App</tt> AST constructor.
module Language.Haskell.Tools.Rewrite.Create.Exprs

-- | Create a expression for a variable or a data constructor (<tt> a
--   </tt>)
mkVar :: Name -> Expr

-- | Create a literal expression (<tt> 42 </tt>)
mkLit :: Literal -> Expr

-- | Create a infix operator application expression (<tt> a + b </tt>)
mkInfixApp :: Expr -> Operator -> Expr -> Expr

-- | Create a prefix operator application expression (<tt> -x </tt>)
mkPrefixApp :: Operator -> Expr -> Expr

-- | Create a function application expression (<tt> f 4 </tt>)
mkApp :: Expr -> Expr -> Expr

-- | Create a lambda expression (<tt> \a b -&gt; a + b </tt>)
mkLambda :: [Pattern] -> Expr -> Expr

-- | Create a local binding (<tt> let x = 2; y = 3 in e x y </tt>)
mkLet :: [LocalBind] -> Expr -> Expr

-- | Create a if expression (<tt> if a then b else c </tt>)
mkIf :: Expr -> Expr -> Expr -> Expr

-- | Create a multi way if expressions with <tt>MultiWayIf</tt> extension
--   (<tt> if | guard1 -&gt; expr1; guard2 -&gt; expr2 </tt>)
mkMultiIf :: [GuardedCaseRhs] -> Expr

-- | Create a pattern matching expression (<tt> case expr of pat1 -&gt;
--   expr1; pat2 -&gt; expr2 </tt>)
mkCase :: Expr -> [Alt] -> Expr

-- | Create a do-notation expressions (<tt> do x &lt;- act1; act2 </tt>)
mkDoBlock :: [Stmt] -> Expr

-- | Create a mdo-notation expressions (<tt> mdo x &lt;- act1; act2 </tt>)
mkMDoBlock :: [Stmt] -> Expr

-- | Create a tuple expression (<tt> (e1, e2, e3) </tt>)
mkTuple :: [Expr] -> Expr

-- | Create a unboxed tuple expression (<tt> (# e1, e2, e3 #) </tt>)
mkUnboxedTuple :: [Expr] -> Expr

-- | Create a tuple section, enabled with <tt>TupleSections</tt> (<tt>
--   (a,,b) </tt>). One of the elements must be missing.
mkTupleSection :: [Maybe Expr] -> Expr

-- | Create a unboxed tuple section, enabled with <tt>TupleSections</tt>
--   (<tt> (#a,,b#) </tt>). One of the elements must be missing.
mkTupleUnboxedSection :: [Maybe Expr] -> Expr

-- | Create a list expression: <tt>[1,2,3]</tt>
mkList :: [Expr] -> Expr

-- | Create a parallel array expression: <tt>[: 1,2,3 :]</tt>
mkParArray :: [Expr] -> Expr

-- | Create a parenthesized expression: <tt>( a + b )</tt>
mkParen :: Expr -> Expr

-- | Create a left operator section: <tt>(1+)</tt>
mkLeftSection :: Expr -> Operator -> Expr

-- | Create a right operator section: <tt>(+1)</tt>
mkRightSection :: Operator -> Expr -> Expr

-- | Create a record value construction: <tt>Point { x = 3, y = -2 }</tt>
mkRecCon :: Name -> [FieldUpdate] -> Expr

-- | Create a record value update: <tt>p1 { x = 3, y = -2 }</tt>
mkRecUpdate :: Expr -> [FieldUpdate] -> Expr

-- | Create a enumeration expression (<tt> [1,3..10] </tt>)
mkEnum :: Expr -> Maybe Expr -> Maybe Expr -> Expr

-- | Create a parallel array enumeration (<tt> [: 1,3 .. 10 :] </tt>)
mkParArrayEnum :: Expr -> Maybe Expr -> Expr -> Expr

-- | Create a list comprehension (<tt> [ (x, y) | x &lt;- xs | y &lt;- ys ]
--   </tt>)
mkListComp :: Expr -> [ListCompBody] -> Expr

-- | Create a parallel array comprehensions <tt> [: (x, y) | x &lt;- xs , y
--   &lt;- ys :] </tt> enabled by <tt>ParallelArrays</tt>
mkParArrayComp :: Expr -> [ListCompBody] -> Expr

-- | Create a explicit type signature (<tt> x :: Int </tt>)
mkExprTypeSig :: Expr -> Type -> Expr

-- | Create a explicit type application (<tt> show @Integer (read "5")
--   </tt>)
mkExplicitTypeApp :: Expr -> Type -> Expr

-- | <tt>'x</tt> for template haskell reifying of expressions
mkVarQuote :: Name -> Expr

-- | <tt>''T</tt> for template haskell reifying of types
mkTypeQuote :: Name -> Expr

-- | Create a template haskell bracket expression
mkBracketExpr :: Bracket -> Expr

-- | Create a template haskell splice expression, for example: <tt>$(gen
--   a)</tt> or <tt>$x</tt>
mkSpliceExpr :: Splice -> Expr

-- | Create a template haskell quasi quote expression, for example:
--   <tt>[quoter| a + b ]</tt>
mkQuasiQuoteExpr :: QuasiQuote -> Expr

-- | Creates a pragma that marks an expression.
mkExprPragma :: ExprPragma -> Expr -> Expr

-- | Create a arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
mkProcExpr :: Pattern -> Cmd -> Expr

-- | Create a arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
mkArrowApp :: Expr -> ArrowApp -> Expr -> Expr

-- | Create a lambda case ( <tt>case 0 -&gt; 1; 1 -&gt; 2</tt> )
mkLambdaCase :: [Alt] -> Expr

-- | Create a static pointer expression (<tt> static e </tt>). The inner
--   expression must be closed (cannot have variables bound outside)
mkStaticPointer :: Expr -> Expr

-- | Create a update of a field (<tt> x = 1 </tt>)
mkFieldUpdate :: Name -> Expr -> FieldUpdate

-- | Create a update the field to the value of the same name (<tt> x </tt>)
mkFieldPun :: Name -> FieldUpdate

-- | Create a update the fields of the bounded names to their values (<tt>
--   .. </tt>). Must be the last initializer. Cannot be used in a record
--   update expression.
mkFieldWildcard :: FieldUpdate

-- | Create a clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
mkAlt :: Pattern -> CaseRhs -> Maybe LocalBinds -> Alt

-- | Create a unguarded right-hand side a pattern match (<tt> -&gt; 3
--   </tt>)
mkCaseRhs :: Expr -> CaseRhs

-- | Create a guarded right-hand sides of a pattern match (<tt> | x == 1
--   -&gt; 3; | otherwise -&gt; 4 </tt>)
mkGuardedCaseRhss :: [GuardedCaseRhs] -> CaseRhs

-- | Creates a guarded right-hand side of pattern matches binding (<tt> | x
--   &gt; 3 -&gt; 2 </tt>)
mkGuardedCaseRhs :: [RhsGuard] -> Expr -> GuardedCaseRhs

-- | Creates a <tt>CORE</tt> pragma for adding notes to expressions.
mkCorePragma :: String -> ExprPragma

-- | Creates an <tt>SCC</tt> pragma for defining cost centers for profiling
mkSccPragma :: String -> ExprPragma

-- | Creates a pragma that describes if an expression was generated from a
--   code fragment by an external tool (<tt> {-# GENERATED "Happy.y"
--   1:15-1:25 #-} </tt>)
mkGeneratedPragma :: SourceRange -> ExprPragma

-- | Create a in-AST source ranges (for generated pragmas)
mkSourceRange :: String -> Integer -> Integer -> Integer -> Integer -> SourceRange

-- | An arrow application command (<tt> f -&lt; x + 1 </tt>)
mkArrowAppCmd :: Expr -> ArrowApp -> Expr -> Cmd

-- | A form command (<tt> (|untilA (increment -&lt; x+y) (within 0.5 -&lt;
--   x)|) </tt>)
mkArrowFromCmd :: Expr -> [Cmd] -> Cmd

-- | A function application command
mkAppCmd :: Cmd -> Expr -> Cmd

-- | An infix command application
mkInfixCmd :: Cmd -> Name -> Cmd -> Cmd

-- | A lambda command
mkLambdaCmd :: [Pattern] -> Cmd -> Cmd

-- | A parenthesized command
mkParenCmd :: Cmd -> Cmd

-- | A pattern match command
mkCaseCmd :: Expr -> [CmdAlt] -> Cmd

-- | An if command (<tt> if f x y then g -&lt; x+1 else h -&lt; y+2 </tt>)
mkIfCmd :: Expr -> Cmd -> Cmd -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
mkLetCmd :: [LocalBind] -> Cmd -> Cmd

-- | A do-notation in a command
mkDoCmd :: [CmdStmt] -> Cmd

-- | Left arrow application: <tt>-&lt;</tt>
mkLeftAppl :: ArrowApp

-- | Right arrow application: <tt>&gt;-</tt>
mkRightAppl :: ArrowApp

-- | Left arrow high application: <tt>-&lt;&lt;</tt>
mkLeftHighAppl :: ArrowApp

-- | Right arrow high application: <tt>&gt;&gt;-</tt>
mkRightHighAppl :: ArrowApp

-- | A hole expression <tt>_</tt>
mkHole :: Expr


-- | Generation of declaration-level AST fragments for refactorings. The
--   bindings defined here create a the annotated version of the AST
--   constructor with the same name. For example, <tt>mkTypeSignature</tt>
--   creates the annotated version of the <tt>UTypeSignature</tt> AST
--   constructor.
module Language.Haskell.Tools.Rewrite.Create.Decls

-- | Creates a type synonym ( <tt>type String = [Char]</tt> )
mkTypeDecl :: DeclHead -> Type -> Decl

-- | Creates a standalone deriving declaration (<tt> deriving instance X T
--   </tt>)
mkStandaloneDeriving :: Maybe DeriveStrategy -> Maybe OverlapPragma -> InstanceRule -> Decl

-- | Creates a fixity declaration (<tt> infixl 5 +, - </tt>)
mkFixityDecl :: FixitySignature -> Decl

-- | Creates default types (<tt> default (T1, T2) </tt>)
mkDefaultDecl :: [Type] -> Decl

-- | Creates type signature declaration (<tt> f :: Int -&gt; Int </tt>)
mkTypeSigDecl :: TypeSignature -> Decl

-- | Creates a function or value binding (<tt> f x = 12 </tt>)
mkValueBinding :: ValueBind -> Decl

-- | Creates a Template Haskell splice declaration (<tt> $(generateDecls)
--   </tt>)
mkSpliceDecl :: Splice -> Decl

-- | Creates a data or newtype declaration.
mkDataDecl :: DataOrNewtypeKeyword -> Maybe Context -> DeclHead -> [ConDecl] -> [Deriving] -> Decl

-- | Creates a GADT-style data or newtype declaration.
mkGADTDataDecl :: DataOrNewtypeKeyword -> Maybe Context -> DeclHead -> Maybe KindConstraint -> [GadtConDecl] -> [Deriving] -> Decl

-- | Creates a GADT constructor declaration (<tt> D1 :: Int -&gt; T String
--   </tt>)
mkGadtConDecl :: [Name] -> Type -> GadtConDecl

-- | Creates a GADT constructor declaration with record syntax (<tt> D1 ::
--   { val :: Int } -&gt; T String </tt>)
mkGadtRecordConDecl :: [Name] -> [FieldDecl] -> Type -> GadtConDecl

-- | Creates an ordinary data constructor (<tt> C t1 t2 </tt>)
mkConDecl :: Name -> [Type] -> ConDecl

-- | Creates a record data constructor (<tt> Point { x :: Double, y ::
--   Double } </tt>)
mkRecordConDecl :: Name -> [FieldDecl] -> ConDecl

-- | Creates an infix data constructor (<tt> t1 :+: t2 </tt>)
mkInfixConDecl :: Type -> Operator -> Type -> ConDecl

-- | Creates a field declaration (<tt> fld :: Int </tt>) for a constructor
mkFieldDecl :: [Name] -> Type -> FieldDecl

-- | Creates a deriving clause following a data type declaration. (<tt>
--   deriving Show </tt> or <tt> deriving (Show, Eq) </tt>)
mkDeriving :: [InstanceHead] -> Deriving

-- | The <tt>data</tt> keyword in a type definition
mkDataKeyword :: DataOrNewtypeKeyword

-- | The <tt>newtype</tt> keyword in a type definition
mkNewtypeKeyword :: DataOrNewtypeKeyword

-- | Creates a type class declaration (<tt> class X a where f = ... </tt>)
mkClassDecl :: Maybe Context -> DeclHead -> [FunDep] -> Maybe ClassBody -> Decl

-- | Creates the list of declarations that can appear in a typeclass
mkClassBody :: [ClassElement] -> ClassBody

-- | Creates a type signature as class element: <tt> f :: A -&gt; B </tt>
mkClassElemSig :: TypeSignature -> ClassElement

-- | Creates a default binding as class element: <tt> f x = "aaa" </tt>
mkClassElemDef :: ValueBind -> ClassElement

-- | Creates an associated type synonym in class: <tt> type T y :: * </tt>
mkClassElemTypeFam :: DeclHead -> Maybe TypeFamilySpec -> ClassElement

-- | Creates an associated data synonym in class: <tt> data T y :: * </tt>
mkClassElemDataFam :: DeclHead -> Maybe KindConstraint -> ClassElement

-- | Creates a default choice for type synonym in class: <tt> type T x = TE
--   </tt> or <tt> type instance T x = TE </tt>
mkClsDefaultType :: DeclHead -> Type -> ClassElement

-- | Creates a default signature (by using <tt>DefaultSignatures</tt>) in
--   class: <tt> default enum :: (Generic a, GEnum (Rep a)) =&gt; [a] </tt>
mkClsDefaultSig :: Name -> Type -> ClassElement

-- | Creates a functional dependency, given on the form <tt>l1 ... ln -&gt;
--   r1 ... rn</tt>
mkFunDep :: [Name] -> [Name] -> FunDep

-- | Minimal pragma: <tt> {-# MINIMAL (==) | (/=) #-} </tt> in a class
mkClsMinimal :: MinimalFormula -> ClassElement
mkMinimalName :: Name -> MinimalFormula
mkMinimalParen :: MinimalFormula -> MinimalFormula

-- | One of the minimal formulas are needed (<tt> min1 | min2 </tt>)
mkMinimalOr :: [MinimalFormula] -> MinimalFormula

-- | Both of the minimal formulas are needed (<tt> min1 , min2 </tt>)
mkMinimalAnd :: [MinimalFormula] -> MinimalFormula

-- | Type or class name as a declaration head
mkNameDeclHead :: Name -> DeclHead

-- | Parenthesized type as a declaration head
mkParenDeclHead :: DeclHead -> DeclHead

-- | Application in a declaration head
mkDeclHeadApp :: DeclHead -> TyVar -> DeclHead

-- | Infix application of the type/class name to the left operand in a
--   declaration head
mkInfixDeclHead :: TyVar -> Operator -> TyVar -> DeclHead

-- | Creates a type class instance declaration (<tt> instance X T [where f
--   = ...] </tt>)
mkInstanceDecl :: Maybe OverlapPragma -> InstanceRule -> Maybe InstBody -> Decl

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the where keyword.
mkInstanceRule :: Maybe Context -> InstanceHead -> InstanceRule

-- | Type or class name as a part of the instance declaration
mkInstanceHead :: Name -> InstanceHead

-- | Infix application of the type/class name to the left operand as a part
--   of the instance declaration
mkInfixInstanceHead :: Type -> Operator -> InstanceHead

-- | Parenthesized instance head as a part of the instance declaration
mkParenInstanceHead :: InstanceHead -> InstanceHead

-- | Application to one more type as a part of the instance declaration
mkAppInstanceHead :: InstanceHead -> Type -> InstanceHead

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
mkInstanceBody :: [InstBodyDecl] -> InstBody

-- | A normal declaration (<tt> f x = 12 </tt>) in a type class instance
mkInstanceBind :: ValueBind -> InstBodyDecl

-- | Type signature in instance definition with <tt>InstanceSigs</tt>
mkInstanceTypeSig :: TypeSignature -> InstBodyDecl

-- | An associated type definition (<tt> type A X = B </tt>) in a type
--   class instance
mkInstanceTypeFamilyDef :: TypeEqn -> InstBodyDecl

-- | An associated data type implementation (<tt> data A X = C1 | C2 </tt>)
--   int a type class instance
mkInstanceDataFamilyDef :: DataOrNewtypeKeyword -> InstanceRule -> [ConDecl] -> [Deriving] -> InstBodyDecl

-- | An associated data type implemented using GADT style int a type class
--   instance
mkInstanceDataFamilyGADTDef :: DataOrNewtypeKeyword -> InstanceRule -> Maybe KindConstraint -> [GadtConDecl] -> [Deriving] -> InstBodyDecl

-- | Specialize instance pragma (no phase selection is allowed) in a type
--   class instance
mkInstanceSpecializePragma :: Type -> InstBodyDecl

-- | <tt>OVERLAP</tt> pragma for type instance definitions
mkEnableOverlap :: OverlapPragma

-- | <tt>NO_OVERLAP</tt> pragma for type instance definitions
mkDisableOverlap :: OverlapPragma

-- | <tt>OVERLAPPABLE</tt> pragma for type instance definitions
mkOverlappable :: OverlapPragma

-- | <tt>OVERLAPPING</tt> pragma for type instance definitions
mkOverlapping :: OverlapPragma

-- | <tt>OVERLAPS</tt> pragma for type instance definitions
mkOverlaps :: OverlapPragma

-- | <tt>INCOHERENT</tt> pragma for type instance definitions
mkIncoherentOverlap :: OverlapPragma

-- | Creates a role annotations (<tt> type role Ptr representational </tt>)
mkRoleDecl :: QualifiedName -> [Role] -> Decl

-- | Marks a given type parameter as <tt>nominal</tt>.
mkNominalRole :: Role

-- | Marks a given type parameter as <tt>representational</tt>.
mkRepresentationalRole :: Role

-- | Marks a given type parameter as <tt>phantom</tt>.
mkPhantomRole :: Role

-- | Creates a foreign import (<tt> foreign import foo :: Int -&gt; IO Int
--   </tt>)
mkForeignImport :: CallConv -> Maybe Safety -> Name -> Type -> Decl

-- | Creates a foreign export (<tt> foreign export ccall foo :: Int -&gt;
--   IO Int </tt>)
mkForeignExport :: CallConv -> Name -> Type -> Decl

-- | Specifies <tt>stdcall</tt> calling convention for foreign
--   import/export.
mkStdCall :: CallConv

-- | Specifies <tt>ccall</tt> calling convention for foreign import/export.
mkCCall :: CallConv

-- | Specifies <tt>capi</tt> calling convention for foreign import/export.
mkCApi :: CallConv

-- | Specifies that the given foreign import is <tt>unsafe</tt>.
mkUnsafe :: Safety

-- | Creates a type family declaration ( <tt>type family F x</tt> )
mkTypeFamily :: DeclHead -> Maybe TypeFamilySpec -> Decl

-- | Creates a closed type family declaration ( <tt>type family F x where F
--   Int = (); F a = Int</tt> )
mkClosedTypeFamily :: DeclHead -> Maybe TypeFamilySpec -> [TypeEqn] -> Decl

-- | Creates a data family declaration (<tt> data family A a :: * -&gt; *
--   </tt>)
mkDataFamily :: DeclHead -> Maybe KindConstraint -> Decl

-- | Specifies the kind of a type family (<tt> :: * -&gt; * </tt>)
mkTypeFamilyKindSpec :: KindConstraint -> TypeFamilySpec

-- | Specifies the injectivity of a type family (<tt> = r | r -&gt; a
--   </tt>)
mkTypeFamilyInjectivitySpec :: TyVar -> [Name] -> TypeFamilySpec

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
mkTypeEqn :: Type -> Type -> TypeEqn

-- | Creates a type family instance declaration (<tt> type instance Fam T =
--   AssignedT </tt>)
mkTypeInstance :: InstanceRule -> Type -> Decl

-- | Creates a data instance declaration (<tt> data instance Fam T = Con1 |
--   Con2 </tt>)
mkDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> [ConDecl] -> [Deriving] -> Decl

-- | Creates a GADT-style data instance declaration (<tt> data instance Fam
--   T where ... </tt>)
mkGadtDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> Maybe KindConstraint -> [GadtConDecl] -> Decl

-- | Creates a pattern synonym (<tt> pattern Arrow t1 t2 = App "-&gt;" [t1,
--   t2] </tt>)
mkPatternSynonym :: PatSynLhs -> PatSynRhs -> Decl

-- | Creates a left hand side of a pattern synonym with a constructor name
--   and arguments (<tt> Arrow t1 t2 </tt>)
mkConPatSyn :: Name -> [Name] -> PatSynLhs

-- | Creates an infix pattern synonym left-hand side (<tt> t1 :+: t2 </tt>)
mkInfixPatSyn :: Name -> Operator -> Name -> PatSynLhs

-- | Creates a record-style pattern synonym left-hand side (<tt> Arrow {
--   arrowFrom, arrowTo } </tt>)
mkRecordPatSyn :: Name -> [Name] -> PatSynLhs

-- | Creates an automatically two-way pattern synonym (<tt> = App "Int" []
--   </tt>)
mkSymmetricPatSyn :: Pattern -> PatSynRhs

-- | Creates a pattern synonym that can be only used for pattenr matching
--   but not for combining (<tt> &lt;- App "Int" [] </tt>)
mkOneWayPatSyn :: Pattern -> PatSynRhs

-- | Creates a pattern synonym with the other direction explicitly
--   specified (<tt> &lt;- App "Int" [] where Int = App "Int" [] </tt>)
mkTwoWayPatSyn :: Pattern -> [Match] -> PatSynRhs

-- | Creates a pattern type signature declaration (<tt> pattern Succ :: Int
--   -&gt; Int </tt>)
mkPatternSignatureDecl :: PatternSignature -> Decl
mkPatternSignature :: [Name] -> Type -> PatternSignature

-- | Creates a top-level pragmas
mkPragmaDecl :: TopLevelPragma -> Decl

-- | A pragma that introduces source rewrite rules (<tt> {-# RULES
--   "map/map" [2] forall f g xs. map f (map g xs) = map (f.g) xs #-}
--   </tt>)
mkRulePragma :: [Rule] -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# DEPRECATED f
--   "f will be replaced by g" #-} </tt>)
mkDeprPragma :: [Name] -> String -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# WARNING
--   unsafePerformIO "you should know what you are doing" #-} </tt>)
mkWarningPragma :: [Name] -> String -> TopLevelPragma

-- | A pragma that annotates a definition with an arbitrary value (<tt> {-#
--   ANN f 42 #-} </tt>)
mkAnnPragma :: AnnotationSubject -> Expr -> TopLevelPragma

-- | A pragma that marks a function for inlining to the compiler (<tt> {-#
--   INLINE thenUs #-} </tt>)
mkInlinePragma :: Maybe ConlikeAnnot -> Maybe PhaseControl -> Name -> TopLevelPragma

-- | A pragma that forbids a function from being inlined by the compiler
--   (<tt> {-# NOINLINE f #-} </tt>)
mkNoInlinePragma :: Name -> TopLevelPragma

-- | A pragma that marks a function that it may be inlined by the compiler
--   (<tt> {-# INLINABLE thenUs #-} </tt>)
mkInlinablePragma :: Maybe PhaseControl -> Name -> TopLevelPragma

-- | A pragma for maintaining line numbers in generated sources (<tt> {-#
--   LINE 123 "somefile" #-} </tt>)
mkLinePragma :: Int -> Maybe StringNode -> TopLevelPragma

-- | A pragma that tells the compiler that a polymorph function should be
--   optimized for a given type (<tt> {-# SPECIALISE f :: Int -&gt; b -&gt;
--   b #-} </tt>)
mkSpecializePragma :: Maybe PhaseControl -> Name -> [Type] -> TopLevelPragma

-- | Marks that the pragma should be applied from a given compile phase
--   (<tt> [2] </tt>)
mkPhaseControlFrom :: Integer -> PhaseControl

-- | Marks that the pragma should be applied until a given compile phase
--   (<tt> [~2] </tt>)
mkPhaseControlUntil :: Integer -> PhaseControl

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
mkRewriteRule :: String -> Maybe PhaseControl -> [RuleVar] -> Expr -> Expr -> Rule
mkRuleVar :: Name -> RuleVar

-- | The definition with the given name is annotated
mkNameAnnotation :: Name -> AnnotationSubject

-- | A type with the given name is annotated
mkTypeAnnotation :: Name -> AnnotationSubject

-- | The whole module is annotated
mkModuleAnnotation :: AnnotationSubject

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
mkConlikeAnnotation :: ConlikeAnnot


-- | Generation of binding-level AST fragments for refactorings. The
--   bindings defined here create a the annotated version of the AST
--   constructor with the same name. For example, <tt>mkMatch</tt> creates
--   the annotated version of the <tt>UMatch</tt> constructor.
module Language.Haskell.Tools.Rewrite.Create.Binds

-- | A simplified function to generate simple value bindings without local
--   definitions, guards or complex lhs.
mkSimpleBind' :: Name -> Expr -> ValueBind

-- | Creates a value binding (<tt> v = "12" </tt>).
mkSimpleBind :: Pattern -> Rhs -> Maybe LocalBinds -> ValueBind

-- | Creates a function binding (<tt> f 0 = 1; f x = x </tt>). All matches
--   must have the same name.
mkFunctionBind :: [Match] -> ValueBind

-- | A simplified function for creating function bindings without local
--   definitions or guards.
mkFunctionBind' :: Name -> [([Pattern], Expr)] -> ValueBind

-- | Creates a clause of function binding
mkMatch :: MatchLhs -> Rhs -> Maybe LocalBinds -> Match

-- | Creates a match lhs with the function name and parameter names (<tt> f
--   a b </tt>)
mkMatchLhs :: Name -> [Pattern] -> MatchLhs

-- | Creates an infix match lhs for an operator (<tt> a + b </tt>)
mkInfixLhs :: Pattern -> Operator -> Pattern -> [Pattern] -> MatchLhs

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
mkLocalBinds :: [LocalBind] -> MaybeLocalBinds
mkLocalBinds' :: [LocalBind] -> LocalBinds

-- | Creates a local binding for a value
mkLocalValBind :: ValueBind -> LocalBind

-- | Creates a local type signature
mkLocalTypeSig :: TypeSignature -> LocalBind

-- | Creates a local fixity declaration
mkLocalFixity :: FixitySignature -> LocalBind

-- | Creates a type signature (<tt> f :: Int -&gt; Int </tt>)
mkTypeSignature :: Name -> Type -> TypeSignature

-- | Creates a left-associative fixity declaration (<tt> infixl 5 +, -
--   </tt>).
mkInfixL :: Int -> Operator -> FixitySignature

-- | Creates a right-associative fixity declaration (<tt> infixr 5 +, -
--   </tt>).
mkInfixR :: Int -> Operator -> FixitySignature

-- | Creates a non-associative fixity declaration (<tt> infix 5 +, -
--   </tt>).
mkInfix :: Int -> Operator -> FixitySignature

-- | Creates an unguarded right-hand-side (<tt> = 3 </tt>)
mkUnguardedRhs :: Expr -> Rhs

-- | Creates an unguarded right-hand-side (<tt> | x == 1 = 3; | otherwise =
--   4 </tt>)
mkGuardedRhss :: [GuardedRhs] -> Rhs

-- | Creates a guarded right-hand side of a value binding (<tt> | x &gt; 3
--   = 2 </tt>)
mkGuardedRhs :: [RhsGuard] -> Expr -> GuardedRhs

-- | Creates a bind statement in a pattern guard (<tt> Just v &lt;- x
--   </tt>)
mkGuardBind :: Pattern -> Expr -> RhsGuard

-- | Creates a let statement in a pattern guard (<tt> let x = 3 </tt>)
mkGuardLet :: [LocalBind] -> RhsGuard

-- | Creates an expression to check for a pattern guard
mkGuardCheck :: Expr -> RhsGuard


-- | Public interface for the modules that can be used to generate parts
--   the AST.
module Language.Haskell.Tools.Rewrite.Create


-- | UPattern matching on binding-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Binds

-- | Non-function binding (<tt> v = "12" </tt>)
pattern SimpleBind :: Pattern -> Rhs -> MaybeLocalBinds -> ValueBind

-- | Function binding (<tt> f 0 = 1; f x = x </tt>). All matches must have
--   the same name.
pattern FunctionBind :: MatchList -> ValueBind

-- | Clause of function binding
pattern Match :: MatchLhs -> Rhs -> MaybeLocalBinds -> Match

-- | A match lhs with the function name and parameter names (<tt> f a b
--   </tt>)
pattern MatchLhs :: Name -> PatternList -> MatchLhs

-- | An infix match lhs for an operator (<tt> a + b </tt>)
pattern InfixLhs :: Pattern -> Operator -> Pattern -> PatternList -> MatchLhs

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
pattern LocalBinds :: LocalBindList -> LocalBinds

-- | A local binding for a value
pattern LocalValBind :: ValueBind -> LocalBind

-- | A local type signature
pattern LocalTypeSig :: TypeSignature -> LocalBind

-- | A local fixity declaration
pattern LocalFixity :: FixitySignature -> LocalBind

-- | A type signature (<tt> f :: Int -&gt; Int </tt>)
pattern TypeSignature :: NameList -> Type -> TypeSignature

-- | A left-associative fixity declaration (<tt> infixl 5 +, - </tt>).
pattern InfixL :: OperatorList -> FixitySignature

-- | A right-associative fixity declaration (<tt> infixr 5 +, - </tt>).
pattern InfixR :: OperatorList -> FixitySignature

-- | A non-associative fixity declaration (<tt> infix 5 +, - </tt>).
pattern Infix :: OperatorList -> FixitySignature

-- | An unguarded right-hand-side (<tt> = 3 </tt>)
pattern UnguardedRhs :: Expr -> Rhs

-- | An unguarded right-hand-side (<tt> | x == 1 = 3; | otherwise = 4
--   </tt>)
pattern GuardedRhss :: GuardedRhsList -> Rhs

-- | A guarded right-hand side of a value binding (<tt> | x &gt; 3 = 2
--   </tt>)
pattern GuardedRhs :: RhsGuardList -> Expr -> GuardedRhs

-- | A bind statement in a pattern guard (<tt> Just v &lt;- x </tt>)
pattern GuardBind :: Pattern -> Expr -> RhsGuard

-- | A let statement in a pattern guard (<tt> let x = 3 </tt>)
pattern GuardLet :: LocalBindList -> RhsGuard

-- | An expression to check for a pattern guard
pattern GuardCheck :: Expr -> RhsGuard


-- | UPattern matching on declaration-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Decls

-- | A type synonym ( <tt>type String = [Char]</tt> )
pattern TypeDecl :: DeclHead -> Type -> Decl

-- | Standalone deriving declaration (<tt> deriving instance X T </tt>)
pattern StandaloneDeriving :: Maybe DeriveStrategy -> Maybe OverlapPragma -> InstanceRule -> Decl

-- | Fixity declaration (<tt> infixl 5 +, - </tt>)
pattern FixityDecl :: FixitySignature -> Decl

-- | Default types (<tt> default (T1, T2) </tt>)
pattern DefaultDecl :: TypeList -> Decl

-- | Type signature declaration (<tt> f :: Int -&gt; Int </tt>)
pattern TypeSigDecl :: TypeSignature -> Decl

-- | Function or value binding (<tt> f x = 12 </tt>)
pattern ValueBinding :: ValueBind -> Decl

-- | A Template Haskell splice declaration (<tt> $(generateDecls) </tt>)
pattern SpliceDecl :: Splice -> Decl

-- | A data or newtype declaration. Empty data type declarations without
--   where keyword are always belong to DataDecl.
pattern DataDecl :: DataOrNewtypeKeyword -> MaybeContext -> DeclHead -> ConDeclList -> DerivingList -> Decl

-- | A GADT-style data or newtype declaration.
pattern GADTDataDecl :: DataOrNewtypeKeyword -> MaybeContext -> DeclHead -> MaybeKindConstraint -> AnnList UGadtConDecl -> DerivingList -> Decl

-- | GADT constructor declaration (<tt> D1 :: Int -&gt; T String </tt>)
pattern GadtConDecl :: NameList -> Type -> GadtConDecl

-- | GADT constructor declaration with record syntax (<tt> D1 :: { val ::
--   Int } -&gt; T String </tt>)
pattern GadtRecordConDecl :: NameList -> FieldDeclList -> Type -> GadtConDecl

-- | Ordinary data constructor (<tt> C t1 t2 </tt>)
pattern ConDecl :: Name -> TypeList -> ConDecl

-- | Creates a record data constructor (<tt> Point { x :: Double, y ::
--   Double } </tt>)
pattern RecordConDecl :: Name -> FieldDeclList -> ConDecl

-- | Infix data constructor (<tt> t1 :+: t2 </tt>)
pattern InfixConDecl :: Type -> Operator -> Type -> ConDecl

-- | Field declaration (<tt> fld :: Int </tt>)
pattern FieldDecl :: NameList -> Type -> FieldDecl

-- | A deriving clause without parentheses (<tt> deriving Show </tt>.
pattern DerivingOne :: InstanceHead -> Deriving

-- | A deriving clause without parentheses, with/witohut strategy (<tt>
--   deriving stock Show </tt>.
pattern DerivingOne' :: MaybeDeriveStrategy -> InstanceHead -> Deriving

-- | A deriving clause with parentheses <tt> deriving (Show, Eq) </tt>)
pattern DerivingMulti :: InstanceHeadList -> Deriving

-- | A deriving clause with parentheses, with/witohut strategy (<tt>
--   deriving stock (Show, Eq) </tt>.
pattern DerivingMulti' :: MaybeDeriveStrategy -> InstanceHeadList -> Deriving
pattern DataKeyword :: DataOrNewtypeKeyword
pattern NewtypeKeyword :: DataOrNewtypeKeyword

-- | A list of functional dependencies: <tt> | a -&gt; b, c -&gt; d </tt>
--   separated by commas
pattern FunDeps :: FunDepList -> FunDeps

-- | A functional dependency, given on the form <tt>l1 ... ln -&gt; r1 ...
--   rn</tt>
pattern FunDep :: NameList -> NameList -> FunDep

-- | Type class declaration (<tt> class X a [where f = ...] </tt>)
pattern ClassDecl :: MaybeContext -> DeclHead -> MaybeFunDeps -> MaybeClassBody -> Decl

-- | The list of declarations that can appear in a typeclass
pattern ClassBody :: ClassElementList -> ClassBody

-- | Type signature: <tt> f :: A -&gt; B </tt> as a class member
pattern ClassElemSig :: TypeSignature -> ClassElement

-- | Default binding: <tt> f x = "aaa" </tt> as a class member
pattern ClassElemDef :: ValueBind -> ClassElement

-- | Declaration of an associated type synonym: <tt> type T x :: * </tt> in
--   a class
pattern ClassElemTypeFam :: DeclHead -> MaybeTypeFamilySpec -> ClassElement

-- | Declaration of an associated data synonym: <tt> data T x :: * </tt> in
--   a class
pattern ClassElemDataFam :: DeclHead -> MaybeKindConstraint -> ClassElement

-- | Default choice for type synonym: <tt> type T x = TE </tt> or <tt> type
--   instance T x = TE </tt> in a class
pattern ClsDefaultType :: DeclHead -> Type -> ClassElement

-- | Default signature (by using <tt>DefaultSignatures</tt>): <tt> default
--   enum :: (Generic a, GEnum (Rep a)) =&gt; [a] </tt>
pattern ClsDefaultSig :: Name -> Type -> ClassElement

-- | Minimal pragma: <tt> {-# MINIMAL (==) | (/=) #-} </tt> in a class
pattern ClsMinimal :: MinimalFormula -> ClassElement
pattern MinimalName :: Name -> MinimalFormula
pattern MinimalParen :: MinimalFormula -> MinimalFormula

-- | One of the minimal formulas are needed (<tt> min1 | min2 </tt>)
pattern MinimalOr :: MinimalFormulaList -> MinimalFormula

-- | Both of the minimal formulas are needed (<tt> min1 , min2 </tt>)
pattern MinimalAnd :: MinimalFormulaList -> MinimalFormula

-- | Type or class name as a declaration head
pattern NameDeclHead :: Name -> DeclHead

-- | Parenthesized type as a declaration head
pattern ParenDeclHead :: DeclHead -> DeclHead

-- | Type application as a declaration head
pattern DeclHeadApp :: DeclHead -> TyVar -> DeclHead

-- | Infix type application as a declaration head
pattern InfixDeclHead :: TyVar -> Operator -> TyVar -> DeclHead

-- | Instance declaration (<tt> instance X T [where f = ...] </tt>)
pattern InstanceDecl :: InstanceRule -> MaybeInstBody -> Decl

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
pattern InstanceBody :: InstBodyDeclList -> InstBody

-- | A normal value binding (<tt> f x = 12 </tt>) inside a class instance
pattern InstanceBind :: ValueBind -> InstBodyDecl

-- | Type signature in instance definition with <tt>InstanceSigs</tt>
pattern InstanceTypeSig :: TypeSignature -> InstBodyDecl

-- | An associated type definition (<tt> type A X = B </tt>) in a class
--   instance
pattern InstanceTypeFamilyDef :: TypeEqn -> InstBodyDecl

-- | An associated data definition (<tt> data A X = B Int | C </tt>) in a
--   class instance
pattern InstanceDataFamilyDef :: DataOrNewtypeKeyword -> InstanceRule -> ConDeclList -> DerivingList -> InstBodyDecl

-- | An associated data definition as a GADT (<tt> data A X where B :: Int
--   -&gt; A X </tt>) in a class instance
pattern InstanceDataFamilyGADTDef :: DataOrNewtypeKeyword -> InstanceRule -> MaybeKindConstraint -> AnnList UGadtConDecl -> DerivingList -> InstBodyDecl

-- | Specialize instance pragma in a class instance (no phase selection is
--   allowed)
pattern InstanceSpecializePragma :: Type -> InstBodyDecl

-- | Instance head as an instance rule (<tt> X a =&gt; Y a </tt>)
pattern InstanceRule :: AnnMaybe (AnnListG UTyVar) -> MaybeContext -> InstanceHead -> InstanceRule

-- | Type or class name as an instance head
pattern InstanceHead :: Name -> InstanceHead

-- | Infix application of the type/class name to the left operand as an
--   instance head
pattern InfixInstanceHead :: Type -> Operator -> InstanceHead

-- | Parenthesized instance head
pattern ParenInstanceHead :: InstanceHead -> InstanceHead

-- | Type application as an instance head
pattern AppInstanceHead :: InstanceHead -> Type -> InstanceHead

-- | <tt>OVERLAP</tt> pragma
pattern EnableOverlap :: OverlapPragma

-- | <tt>NO_OVERLAP</tt> pragma
pattern DisableOverlap :: OverlapPragma

-- | <tt>OVERLAPPABLE</tt> pragma
pattern Overlappable :: OverlapPragma

-- | <tt>OVERLAPPING</tt> pragma
pattern Overlapping :: OverlapPragma

-- | <tt>OVERLAPS</tt> pragma
pattern Overlaps :: OverlapPragma

-- | <tt>INCOHERENT</tt> pragma
pattern IncoherentOverlap :: OverlapPragma

-- | Role annotations (<tt> type role Ptr representational </tt>)
pattern RoleDecl :: QualifiedName -> RoleList -> Decl
pattern NominalRole :: Role
pattern RepresentationalRole :: Role
pattern PhantomRole :: Role

-- | Foreign import (<tt> foreign import foo :: Int -&gt; IO Int </tt>)
pattern ForeignImport :: CallConv -> MaybeSafety -> Name -> Type -> Decl

-- | Foreign export (<tt> foreign export ccall foo :: Int -&gt; IO Int
--   </tt>)
pattern ForeignExport :: CallConv -> Name -> Type -> Decl

-- | Specifies <tt>stdcall</tt> calling convention for foreign
--   import/export.
pattern StdCall :: CallConv

-- | Specifies <tt>ccall</tt> calling convention for foreign import/export.
pattern CCall :: CallConv

-- | Specifies <tt>capi</tt> calling convention for foreign import/export.
pattern CApi :: CallConv

-- | Specifies that the given foreign import is <tt>unsafe</tt>.
pattern Unsafe :: Safety

-- | Pattern synonyms (<tt> pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
--   </tt>)
pattern PatternSynonym :: PatSynLhs -> PatSynRhs -> Decl

-- | A left hand side with a constructor name and arguments (<tt> Arrow t1
--   t2 </tt>)
pattern ConPatSyn :: Name -> NameList -> PatSynLhs

-- | An infix pattern synonym left-hand side (<tt> t1 :+: t2 </tt>)
pattern InfixPatSyn :: Name -> Operator -> Name -> PatSynLhs

-- | A record-style pattern synonym left-hand side (<tt> Arrow { arrowFrom,
--   arrowTo } </tt>)
pattern RecordPatSyn :: Name -> NameList -> PatSynLhs

-- | An automatically two-way pattern synonym (<tt> = App "Int" [] </tt>)
pattern SymmetricPatSyn :: Pattern -> PatSynRhs

-- | A pattern synonym that can be only used for pattenr matching but not
--   for combining (<tt> &lt;- App "Int" [] </tt>)
pattern OneWayPatSyn :: Pattern -> PatSynRhs

-- | A pattern synonym with the other direction explicitly specified (<tt>
--   &lt;- App "Int" [] where Int = App "Int" [] </tt>)
pattern TwoWayPatSyn :: Pattern -> MatchList -> PatSynRhs

-- | Pattern type signature declaration (<tt> pattern Succ :: Int -&gt; Int
--   </tt>)
pattern PatternSignatureDecl :: PatternSignature -> Decl
pattern PatternSignature :: NameList -> Type -> PatternSignature

-- | Type family declaration (<tt> type family A a :: * -&gt; * </tt>)
pattern TypeFamily :: DeclHead -> MaybeTypeFamilySpec -> Decl

-- | Data family declaration (<tt> data family A a :: * -&gt; * </tt>)
pattern DataFamily :: DeclHead -> MaybeKindConstraint -> Decl

-- | Type family instance declaration (<tt> type instance Fam T = AssignedT
--   </tt>)
pattern TypeInstance :: InstanceRule -> Type -> Decl

-- | Data instance declaration (<tt> data instance Fam T = Con1 | Con2
--   </tt>)
pattern DataInstance :: DataOrNewtypeKeyword -> InstanceRule -> ConDeclList -> DerivingList -> Decl

-- | GADT-style data instance declaration (<tt> data instance Fam T where
--   ... </tt>)
pattern GadtDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> MaybeKindConstraint -> GadtConDeclList -> Decl

-- | A closed type family declaration
pattern ClosedTypeFamily :: DeclHead -> MaybeTypeFamilySpec -> TypeEqnList -> Decl

-- | Specifies the kind of a type family (<tt> :: * -&gt; * </tt>)
pattern TypeFamilyKindSpec :: KindConstraint -> TypeFamilySpec

-- | Specifies the injectivity of a type family (<tt> = r | r -&gt; a
--   </tt>)
pattern TypeFamilyInjectivitySpec :: TyVar -> NameList -> TypeFamilySpec

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
pattern TypeEqn :: Type -> Type -> TypeEqn

-- | Top-level pragmas
pattern PragmaDecl :: TopLevelPragma -> Decl

-- | A pragma that introduces source rewrite rules (<tt> {-# RULES
--   "map/map" [2] forall f g xs. map f (map g xs) = map (f.g) xs #-}
--   </tt>)
pattern RulePragma :: RuleList -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# DEPRECATED f
--   "f will be replaced by g" #-} </tt>)
pattern DeprPragma :: NameList -> String -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# WARNING
--   unsafePerformIO "you should know what you are doing" #-} </tt>)
pattern WarningPragma :: NameList -> String -> TopLevelPragma

-- | A pragma that annotates a definition with an arbitrary value (<tt> {-#
--   ANN f 42 #-} </tt>)
pattern AnnPragma :: AnnotationSubject -> Expr -> TopLevelPragma

-- | A pragma that marks a function for inlining to the compiler (<tt> {-#
--   INLINE thenUs #-} </tt>)
pattern InlinePragma :: MaybeConlikeAnnot -> MaybePhaseControl -> Name -> TopLevelPragma

-- | A pragma that forbids a function from being inlined by the compiler
--   (<tt> {-# NOINLINE f #-} </tt>)
pattern NoInlinePragma :: Name -> TopLevelPragma

-- | A pragma that marks a function that it may be inlined by the compiler
--   (<tt> {-# INLINABLE thenUs #-} </tt>)
pattern InlinablePragma :: MaybePhaseControl -> Name -> TopLevelPragma

-- | A pragma for maintaining line numbers in generated sources (<tt> {-#
--   LINE 123 "somefile" #-} </tt>)
pattern LinePragma :: Int -> MaybeStringNode -> TopLevelPragma

-- | A pragma that tells the compiler that a polymorph function should be
--   optimized for a given type (<tt> {-# SPECIALISE f :: Int -&gt; b -&gt;
--   b #-} </tt>)
pattern SpecializePragma :: MaybePhaseControl -> Name -> TypeList -> TopLevelPragma

-- | Marks that the pragma should be applied from a given compile phase
--   (<tt> [2] </tt>)
pattern PhaseControlFrom :: Integer -> PhaseControl

-- | Marks that the pragma should be applied until a given compile phase
--   (<tt> [~2] </tt>)
pattern PhaseControlUntil :: Integer -> PhaseControl

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
pattern RewriteRule :: String -> MaybePhaseControl -> RuleVarList -> Expr -> Expr -> Rule

-- | The definition with the given name is annotated
pattern NameAnnotation :: Name -> AnnotationSubject

-- | A type with the given name is annotated
pattern TypeAnnotation :: Name -> AnnotationSubject

-- | The whole module is annotated
pattern ModuleAnnotation :: AnnotationSubject

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
pattern ConlikeAnnotation :: ConlikeAnnot


-- | UPattern matching on statement-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Kinds

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
pattern KindConstraint :: Kind -> KindConstraint

-- | <tt>*</tt>, the kind of types
pattern StarKind :: Kind

-- | <tt>#</tt>, the kind of unboxed types
pattern UnboxKind :: Kind

-- | <tt>-&gt;</tt>, the kind of type constructor
pattern FunKind :: Kind -> Kind -> Kind

-- | A parenthesised kind
pattern ParenKind :: Kind -> Kind

-- | Kind variable (using <tt>PolyKinds</tt> extension)
pattern VarKind :: Name -> Kind

-- | Kind application (<tt> k1 k2 </tt>)
pattern AppKind :: Kind -> Kind -> Kind

-- | A list kind (<tt> [k] </tt>)
pattern ListKind :: Kind -> Kind

-- | Numeric value promoted to the kind level.
pattern IntKind :: Integer -> Kind

-- | String value promoted to the kind level.
pattern StringKind :: String -> Kind

-- | A data constructor value promoted to the kind level.
pattern ConKind :: Name -> Kind

-- | A list of elements as a kind.
pattern ListKindPromoted :: KindList -> Kind

-- | A tuple of elements as a kind.
pattern TupleKind :: KindList -> Kind

-- | Kind of the unit value <tt>()</tt>.
pattern UnitKind :: Kind


-- | UPattern matching on literals for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Literals

-- | Character literal: <tt><tt>c</tt></tt>
pattern CharLit :: Char -> Literal

-- | String literal: <tt>"abc"</tt>
pattern StringLit :: String -> Literal

-- | Integer literal: <tt>12</tt>
pattern IntLit :: Integer -> Literal

-- | Fractional literal: <tt>3.14</tt>
pattern FracLit :: Rational -> Literal

-- | Primitive integer literal (of type <tt>Int#</tt>): <tt>32#</tt>
pattern PrimIntLit :: Integer -> Literal

-- | Primitive word literal (of type <tt>Word#</tt>): <tt>32##</tt>
pattern PrimWordLit :: Integer -> Literal

-- | Primitive float literal (of type <tt>Float#</tt>): <tt>3.14#</tt>
pattern PrimFloatLit :: Rational -> Literal

-- | Primitive double literal (of type <tt>Double#</tt>): <tt>3.14##</tt>
pattern PrimDoubleLit :: Rational -> Literal

-- | Primitive character literal (of type <tt>Char#</tt>):
--   <tt><tt>c</tt>#</tt>
pattern PrimCharLit :: Char -> Literal

-- | Primitive string literal (of type <tt>Addr#</tt>): <tt>"xxx"#</tt>
pattern PrimStringLit :: String -> Literal


-- | UPattern matching on UModule-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Modules

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
pattern Module :: FilePragmaList -> MaybeModuleHead -> ImportDeclList -> DeclList -> Module

-- | Module declaration with name and (optional) exports
pattern ModuleHead :: ModuleName -> MaybeModulePragma -> MaybeExportSpecs -> ModuleHead

-- | A list of export specifications surrounded by parentheses
pattern ExportSpecs :: ExportSpecList -> ExportSpecs

-- | Export a name and related names
pattern ExportSpec :: IESpec -> ExportSpec

-- | The export of an imported module (<tt> module A </tt>)
pattern ModuleExport :: ModuleName -> ExportSpec

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
pattern IESpec :: MaybeImportModifier -> Name -> MaybeSubSpec -> IESpec

-- | <tt>(..)</tt>: a class exported with all of its methods, or a datatype
--   exported with all of its constructors.
pattern SubAll :: SubSpec

-- | <tt>(a,b,c)</tt>: a class exported with some of its methods, or a
--   datatype exported with some of its constructors.
pattern SubList :: NameList -> SubSpec
pattern ImportDecl :: MaybeImportSource -> MaybeImportQualified -> MaybeImportSafe -> MaybeStringNode -> ModuleName -> MaybeImportRenaming -> MaybeImportSpec -> ImportDecl
pattern ImportRenaming :: ModuleName -> ImportRenaming
pattern ImportSpecList :: IESpecList -> ImportSpec
pattern ImportHidingList :: IESpecList -> ImportSpec
pattern ModuleName :: String -> ModuleName

-- | <tt>LANGUAGE</tt> pragma, listing the enabled language extensions in
--   that file
pattern LanguagePragma :: LanguageExtensionList -> FilePragma

-- | <tt>OPTIONS</tt> pragma, possibly qualified with a tool, e.g.
--   OPTIONS_GHC
pattern OptionsPragma :: String -> FilePragma

-- | The name of the enabled language extension, for example (<tt>
--   LambdaCase </tt>)
pattern LanguageExtension :: String -> LanguageExtension

-- | A warning pragma attached to the module
pattern ModuleWarningPragma :: StringNodeList -> ModulePragma

-- | A deprecated pragma attached to the module
pattern ModuleDeprecatedPragma :: StringNodeList -> ModulePragma


-- | Generation of basic AST fragments (names for example) for refactorings
module Language.Haskell.Tools.Rewrite.Match.Names

-- | A normal operator used as an operator.
pattern NormalOp :: QualifiedName -> Operator

-- | A normal name used as an operator with backticks: <tt> a `mod` b </tt>
pattern BacktickOp :: QualifiedName -> Operator

-- | A normal, non-operator name.
pattern NormalName :: QualifiedName -> Name

-- | Parenthesized name: <tt> foldl (+) 0 </tt>
pattern ParenName :: QualifiedName -> Name

-- | Creates an implicit name: <tt> ?var </tt>
pattern ImplicitName :: QualifiedName -> Name

-- | Program elements formatted as string literals (import packages, pragma
--   texts)
pattern StringNode :: String -> StringNode

-- | Possibly qualified name.
pattern QualifiedName :: NamePartList -> NamePart -> QualifiedName

-- | Parts of a qualified name.
pattern NamePart :: String -> NamePart


-- | UPattern matching on pattern-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Patterns

-- | Pattern name binding
pattern VarPat :: Name -> Pattern

-- | Literal pattern
pattern LitPat :: Literal -> Pattern

-- | Infix constructor application pattern (<tt> a :+: b </tt>)
pattern InfixAppPat :: Pattern -> Operator -> Pattern -> Pattern

-- | Constructor application pattern (<tt> Point x y </tt>)
pattern AppPat :: Name -> PatternList -> Pattern

-- | Tuple pattern (<tt> (x,y) </tt>)
pattern TuplePat :: PatternList -> Pattern

-- | Unboxed tuple pattern (<tt> (# x, y #) </tt>)
pattern UnboxTuplePat :: PatternList -> Pattern

-- | List pattern (<tt> [1,2,a,x] </tt>)
pattern ListPat :: PatternList -> Pattern

-- | Parallel array pattern (<tt> [:1,2,a,x:] </tt>)
pattern ParArrayPat :: PatternList -> Pattern

-- | Parenthesised patterns
pattern ParenPat :: Pattern -> Pattern

-- | Record pattern (<tt> Point { x = 3, y } </tt>)
pattern RecPat :: Name -> PatternFieldList -> Pattern

-- | As-pattern (explicit name binding) (<tt> ls@(hd:_) </tt>)
pattern AsPat :: Name -> Pattern -> Pattern

-- | Wildcard pattern: (<tt> _ </tt>)
pattern WildPat :: Pattern

-- | Irrefutable pattern (<tt> ~(x:_) </tt>)
pattern IrrefutablePat :: Pattern -> Pattern

-- | Bang pattern (<tt> !x </tt>)
pattern BangPat :: Pattern -> Pattern

-- | Pattern with explicit type signature (<tt> x :: Int </tt>)
pattern TypeSigPat :: Pattern -> Type -> Pattern

-- | View pattern (<tt> f -&gt; Just 1 </tt>)
pattern ViewPat :: Expr -> Pattern -> Pattern

-- | Splice patterns: <tt>$(generateX inp)</tt>
pattern SplicePat :: Splice -> Pattern

-- | Quasi-quoted patterns: <tt>[| 1 + 2 |]</tt>
pattern QuasiQuotePat :: QuasiQuote -> Pattern
pattern NPlusKPat :: Name -> Literal -> Pattern

-- | Named field pattern (<tt> p = Point 3 2 </tt>)
pattern FieldPattern :: Name -> Pattern -> PatternField

-- | Named field pun (<tt> p </tt>)
pattern FieldPunPattern :: Name -> PatternField

-- | Wildcard field pattern (<tt> .. </tt>)
pattern FieldWildcardPattern :: FieldWildcard -> PatternField


-- | UPattern matching on statement-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Stmts

-- | Binding statement (<tt> x &lt;- action </tt>)
pattern BindStmt :: Pattern -> Expr -> Stmt

-- | Non-binding statement (<tt> action </tt>)
pattern ExprStmt :: Expr -> Stmt

-- | Let statement (<tt> let x = 3; y = 4 </tt>)
pattern LetStmt :: LocalBindList -> Stmt

-- | A recursive binding statement with (<tt> rec b &lt;- f a c; c &lt;- f
--   b a </tt>)
pattern RecStmt :: StmtList -> Stmt
pattern DoKeyword :: DoKind
pattern MDoKeyword :: DoKind

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
pattern ListCompBody :: CompStmtList -> ListCompBody

-- | Normal monadic statement of a list comprehension
pattern CompStmt :: Stmt -> CompStmt

-- | Then statements by <tt>TransformListComp</tt> (<tt> then sortWith by
--   (x + y) </tt>)
pattern ThenStmt :: Expr -> MaybeExpr -> CompStmt

-- | Grouping statements by <tt>TransformListComp</tt> (<tt> then group by
--   (x + y) using groupWith </tt>)
pattern GroupStmt :: MaybeExpr -> MaybeExpr -> CompStmt

-- | Binding statement command (<tt> x &lt;- action </tt>)
pattern BindStmtCmd :: Pattern -> Cmd -> CmdStmt

-- | Non-binding statement command (<tt> action </tt>)
pattern ExprStmtCmd :: Cmd -> CmdStmt

-- | Let statement command (<tt> let x = 3; y = 4 </tt>)
pattern LetStmtCmd :: LocalBindList -> CmdStmt

-- | A recursive binding statement command with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
pattern RecStmtCmd :: CmdStmtList -> CmdStmt


-- | UPattern matching expression-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Exprs

-- | An expression for a variable or a data constructor (<tt> a </tt>)
pattern Var :: Name -> Expr

-- | A literal expression (<tt> 42 </tt>)
pattern Lit :: Literal -> Expr

-- | An infix operator application (<tt> a + b </tt>)
pattern InfixApp :: Expr -> Operator -> Expr -> Expr

-- | Prefix operator application (<tt> -x </tt>)
pattern PrefixApp :: Operator -> Expr -> Expr

-- | Function application (<tt> f 4 </tt>)
pattern App :: Expr -> Expr -> Expr

-- | Lambda expression (<tt> \a b -&gt; a + b </tt>)
pattern Lambda :: PatternList -> Expr -> Expr

-- | Local binding (<tt> let x = 2; y = 3 in e x y </tt>)
pattern Let :: LocalBindList -> Expr -> Expr

-- | If expression (<tt> if a then b else c </tt>)
pattern If :: Expr -> Expr -> Expr -> Expr

-- | Multi way if expressions with <tt>MultiWayIf</tt> extension (<tt> if |
--   guard1 -&gt; expr1; guard2 -&gt; expr2 </tt>)
pattern MultiIf :: GuardedCaseRhsList -> Expr

-- | Pattern matching expression (<tt> case expr of pat1 -&gt; expr1; pat2
--   -&gt; expr2 </tt>)
pattern Case :: Expr -> AltList -> Expr

-- | Do-notation expressions (<tt> do x &lt;- act1; act2 </tt>)
pattern Do :: StmtList -> Expr

-- | MDo-notation expressions (<tt> mdo x &lt;- act1; act2 </tt>)
pattern MDo :: StmtList -> Expr
pattern ParArrayComp :: Expr -> ListCompBodyList -> Expr

-- | Tuple expression (<tt> (e1, e2, e3) </tt>)
pattern Tuple :: ExprList -> Expr

-- | Unboxed tuple expression (<tt> (# e1, e2, e3 #) </tt>)
pattern UnboxedTuple :: ExprList -> Expr

-- | Tuple section, enabled with <tt>TupleSections</tt> (<tt> (a,,b)
--   </tt>). One of the elements must be missing.
pattern TupleSection :: TupSecElemList -> Expr

-- | Unboxed tuple section enabled with <tt>TupleSections</tt> (<tt> ()
--   </tt>). One of the elements must be missing.
pattern UnboxedTupleSection :: TupSecElemList -> Expr

-- | List expression: <tt>[1,2,3]</tt>
pattern List :: ExprList -> Expr

-- | Parallel array expression: <tt>[: 1,2,3 :]</tt>
pattern ParArray :: ExprList -> Expr

-- | Parenthesized expression: <tt>( a + b )</tt>
pattern Paren :: Expr -> Expr

-- | Left operator section: <tt>(1+)</tt>
pattern LeftSection :: Expr -> Operator -> Expr

-- | Right operator section: <tt>(+1)</tt>
pattern RightSection :: Operator -> Expr -> Expr

-- | Record value construction: <tt>Point { x = 3, y = -2 }</tt>
pattern RecCon :: Name -> FieldUpdateList -> Expr

-- | Record value update: <tt>p1 { x = 3, y = -2 }</tt>
pattern RecUpdate :: Expr -> FieldUpdateList -> Expr

-- | Enumeration expression (<tt> [1,3..10] </tt>)
pattern Enum :: Expr -> MaybeExpr -> MaybeExpr -> Expr

-- | Parallel array enumeration (<tt> [: 1,3 .. 10 :] </tt>)
pattern ParArrayEnum :: Expr -> MaybeExpr -> Expr -> Expr

-- | List comprehension (<tt> [ (x, y) | x &lt;- xs | y &lt;- ys ] </tt>)
pattern ListComp :: Expr -> ListCompBodyList -> Expr

-- | Parallel array comprehensions <tt> [: (x, y) | x &lt;- xs , y &lt;- ys
--   :] </tt> enabled by <tt>ParallelArrays</tt>
pattern ParArrayListComp :: Expr -> ListCompBodyList -> Expr

-- | Explicit type signature (<tt> x :: Int </tt>)
pattern TypeSig :: Expr -> Type -> Expr

-- | Explicit type application (<tt> show @Integer (read "5") </tt>)
pattern ExplicitTypeApp :: Expr -> Type -> Expr

-- | <tt>'x</tt> for template haskell reifying of expressions
pattern VarQuote :: Name -> Expr

-- | <tt>''T</tt> for template haskell reifying of types
pattern TypeQuote :: Name -> Expr

-- | Template haskell bracket expression
pattern BracketExpr :: Bracket -> Expr

-- | Template haskell splice expression, for example: <tt>$(gen a)</tt> or
--   <tt>$x</tt>
pattern SpliceExpr :: Splice -> Expr

-- | Template haskell quasi-quotation: <tt>[$quoter|str]</tt>
pattern QuasiQuoteExpr :: QuasiQuote -> Expr

-- | Template haskell quasi-quotation: <tt>[$quoter|str]</tt>
pattern ExprPragma :: ExprPragma -> Expr -> Expr

-- | Arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
pattern Proc :: Pattern -> Cmd -> Expr

-- | Arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
pattern ArrowApp :: Expr -> ArrowApp -> Expr -> Expr

-- | Lambda case ( <tt>case 0 -&gt; 1; 1 -&gt; 2</tt> )
pattern LambdaCase :: AltList -> Expr

-- | Static pointer expression (<tt> static e </tt>). The inner expression
--   must be closed (cannot have variables bound outside)
pattern StaticPointer :: Expr -> Expr

-- | Update of a field (<tt> x = 1 </tt>)
pattern NormalFieldUpdate :: Name -> Expr -> FieldUpdate

-- | Update the field to the value of the same name (<tt> x </tt>)
pattern FieldPun :: Name -> FieldUpdate

-- | Update the fields of the bounded names to their values (<tt> ..
--   </tt>). Must be the last initializer. Cannot be used in a record
--   update expression.
pattern FieldWildcard :: FieldWildcard -> FieldUpdate

-- | An existing element in a tuple section
pattern TupSecPresent :: Expr -> TupSecElem

-- | A missing element in a tuple section
pattern TupSecMissing :: TupSecElem

-- | Clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
pattern Alt :: Pattern -> CaseRhs -> MaybeLocalBinds -> Alt

-- | Unguarded right-hand side a pattern match (<tt> -&gt; 3 </tt>)
pattern CaseRhs :: Expr -> CaseRhs

-- | Guarded right-hand sides of a pattern match (<tt> | x == 1 -&gt; 3; |
--   otherwise -&gt; 4 </tt>)
pattern GuardedCaseRhss :: GuardedCaseRhsList -> CaseRhs

-- | A guarded right-hand side of pattern matches binding (<tt> | x &gt; 3
--   -&gt; 2 </tt>)
pattern GuardedCaseRhs :: RhsGuardList -> Expr -> GuardedCaseRhs

-- | A <tt>CORE</tt> pragma for adding notes to expressions.
pattern CorePragma :: String -> ExprPragma

-- | An <tt>SCC</tt> pragma for defining cost centers for profiling
pattern SccPragma :: String -> ExprPragma

-- | A pragma that describes if an expression was generated from a code
--   fragment by an external tool (<tt> {--} </tt>)
pattern GeneratedPragma :: SourceRange -> ExprPragma

-- | In-AST source ranges (for generated pragmas)
pattern SourceRange :: String -> Integer -> Integer -> Integer -> Integer -> SourceRange

-- | An arrow application command (<tt> f -&lt; x + 1 </tt>)
pattern ArrowAppCmd :: Expr -> ArrowApp -> Expr -> Cmd

-- | A form command (<tt> (|untilA (increment -&lt; x+y) (within 0.5 -&lt;
--   x)|) </tt>)
pattern ArrowFormCmd :: Expr -> CmdList -> Cmd

-- | A function application command
pattern AppCmd :: Cmd -> Expr -> Cmd

-- | An infix command application
pattern InfixCmd :: Cmd -> Name -> Cmd -> Cmd

-- | An infix command application
pattern LambdaCmd :: PatternList -> Cmd -> Cmd

-- | A parenthesized command
pattern ParenCmd :: Cmd -> Cmd

-- | A pattern match command
pattern CaseCmd :: Expr -> CmdAltList -> Cmd

-- | An if command (<tt> if f x y then g -&lt; x+1 else h -&lt; y+2 </tt>)
pattern IfCmd :: Expr -> Cmd -> Cmd -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
pattern LetCmd :: LocalBindList -> Cmd -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
pattern DoCmd :: CmdStmtList -> Cmd

-- | Left arrow application: <tt>-&lt;</tt>
pattern LeftAppl :: ArrowApp

-- | Right arrow application: <tt>&gt;-</tt>
pattern RightAppl :: ArrowApp

-- | Left arrow high application: <tt>-&lt;&lt;</tt>
pattern LeftHighApp :: ArrowApp

-- | Right arrow high application: <tt>&gt;&gt;-</tt>
pattern RightHighApp :: ArrowApp

-- | A hole expression <tt>_</tt>
pattern Hole :: Expr


-- | Pattern matching on Template Haskell AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.TH

-- | A simple name splice: <tt>$generateX</tt>
pattern IdSplice :: Name -> Splice

-- | A splice with parentheses: <tt>$(generate input)</tt>
pattern ParenSplice :: Expr -> Splice

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
pattern QuasiQuote :: Name -> String -> QuasiQuote

-- | Expression bracket (<tt> [| x + y |] </tt>)
pattern ExprBracket :: Expr -> Bracket

-- | Pattern bracket (<tt> [p| Point x y |] </tt>)
pattern PatternBracket :: Pattern -> Bracket

-- | Type bracket (<tt> [t| (Int,Int) |] </tt>)
pattern TypeBracket :: Type -> Bracket

-- | Declaration bracket (<tt> [d| f :: Int -&gt; Int; f x = x*x |] </tt>)
pattern DeclsBracket :: DeclList -> Bracket


-- | UPattern matching on type-level AST fragments for refactorings.
module Language.Haskell.Tools.Rewrite.Match.Types

-- | Forall types (<tt> forall x y . type </tt>)
pattern ForallType :: TyVarList -> Type -> Type

-- | Type with a context (<tt> C a =&gt; type </tt>)
pattern CtxType :: Context -> Type -> Type

-- | Function types (<tt> a -&gt; b </tt>)
pattern FunctionType :: Type -> Type -> Type

-- | Tuple types (<tt> (a,b) </tt>)
pattern TupleType :: TypeList -> Type

-- | Unboxed tuple types (<tt> (#a,b#) </tt>)
pattern UnboxedTupleType :: TypeList -> Type

-- | List type with special syntax (<tt> [a] </tt>)
pattern ListType :: Type -> Type

-- | Parallel array type (<tt> [:a:] </tt>)
pattern ParArrayType :: Type -> Type

-- | Type application (<tt> F a </tt>)
pattern TypeApp :: Type -> Type -> Type

-- | Infix type constructor (<tt> (a &lt;: b) </tt>)
pattern InfixTypeApp :: Type -> Operator -> Type -> Type

-- | Type surrounded by parentheses (<tt> (T a) </tt>)
pattern ParenType :: Type -> Type

-- | Type variable or constructor (<tt> a </tt>)
pattern VarType :: Name -> Type

-- | Type with explicit kind signature (<tt> a :: * </tt>)
pattern KindedType :: Type -> Kind -> Type

-- | Strict type marked with <tt>!</tt>.
pattern BangType :: Type -> Type

-- | Lazy type marked with <tt>~</tt>. (Should only be used if
--   <tt>Strict</tt> or <tt>StrictData</tt> language extension is used)
pattern LazyType :: Type -> Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
pattern UnpackType :: Type -> Type

-- | Strict type marked with NOUNPACK pragma. (Usually contains the bang
--   mark.)
pattern NoUnpackType :: Type -> Type

-- | A wildcard type (<tt> _ </tt>) with <tt>-XPartialTypeSignatures</tt>
pattern WildcardType :: Type

-- | A named wildcard type (<tt> _t </tt>) with
--   <tt>-XPartialTypeSignatures</tt>
pattern NamedWildcardType :: Name -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
pattern SpliceType :: Splice -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
pattern QuasiQuoteType :: QuasiQuote -> Type

-- | Numeric value promoted to the type level.
pattern PromotedIntType :: Integer -> Type

-- | String value promoted to the type level.
pattern PromotedStringType :: String -> Type

-- | A data constructor value promoted to the type level.
pattern PromotedConType :: Name -> Type

-- | A list of elements as a type.
pattern PromotedListType :: TypeList -> Type

-- | A tuple of elements as a type.
pattern PromotedTupleType :: TypeList -> Type

-- | Kind of the unit value <tt>()</tt>.
pattern PromotedUnitType :: Type

-- | An unboxed sum type.
pattern UnboxedSumType :: TypeList -> Type

-- | Type variable declaration
pattern TyVarDecl :: Name -> TyVar

-- | Kinded type variable declaration (<tt> v :: * </tt>)
pattern KindedTyVarDecl :: Name -> Kind -> TyVar

-- | A context of assertions (<tt> C a =&gt; ... </tt>)
pattern Context :: Assertion -> Context

-- | Class assertion (<tt>Cls x</tt>)
pattern ClassAssert :: Name -> TypeList -> Assertion

-- | Infix class assertion, also contains type equations (<tt> a ~ X y
--   </tt>)
pattern InfixAssert :: Type -> Operator -> Type -> Assertion

-- | Assertion for implicit parameter binding (<tt> ?cmp :: a -&gt; a -&gt;
--   Bool </tt>)
pattern ImplicitAssert :: Name -> Type -> Assertion

-- | A list of assertions (<tt> (Eq a, Show a) </tt>)
pattern TupleAssert :: [Assertion] -> Assertion


-- | Public interface for the modules that can be used to pattern match on
--   the AST.
module Language.Haskell.Tools.Rewrite.Match


-- | Public interface for the modules that can be used to rewrite the AST.
--   Contains modules for constructing parts of the AST and modules for
--   pattern matching (deconstructing) parts of the AST.
module Language.Haskell.Tools.Rewrite
