<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings
<span class="lineno">    2 </span>           , DeriveGeneric
<span class="lineno">    3 </span>           , TypeApplications
<span class="lineno">    4 </span>           , TupleSections
<span class="lineno">    5 </span>           , ScopedTypeVariables
<span class="lineno">    6 </span>           , LambdaCase
<span class="lineno">    7 </span>           , TemplateHaskell
<span class="lineno">    8 </span>           , PatternGuards
<span class="lineno">    9 </span>           , FlexibleContexts
<span class="lineno">   10 </span>           #-}
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>module Language.Haskell.Tools.Demo where
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>import Control.Concurrent.MVar
<span class="lineno">   15 </span>import Control.Exception
<span class="lineno">   16 </span>import Control.Monad
<span class="lineno">   17 </span>import Control.Monad.State
<span class="lineno">   18 </span>import Data.Aeson hiding ((.=))
<span class="lineno">   19 </span>import Data.ByteString.Lazy (ByteString)
<span class="lineno">   20 </span>import qualified Data.ByteString.Lazy.Char8 as BS
<span class="lineno">   21 </span>import Data.IORef
<span class="lineno">   22 </span>import Data.List hiding (insert)
<span class="lineno">   23 </span>import qualified Data.Map as Map
<span class="lineno">   24 </span>import Data.Maybe
<span class="lineno">   25 </span>import Data.Tuple
<span class="lineno">   26 </span>import GHC.Generics
<span class="lineno">   27 </span>import Network.HTTP.Types
<span class="lineno">   28 </span>import Network.Wai
<span class="lineno">   29 </span>import Network.Wai.Handler.Warp
<span class="lineno">   30 </span>import Network.Wai.Handler.WebSockets
<span class="lineno">   31 </span>import Network.WebSockets
<span class="lineno">   32 </span>import System.Directory
<span class="lineno">   33 </span>import System.Environment
<span class="lineno">   34 </span>import System.FilePath
<span class="lineno">   35 </span>import System.IO
<span class="lineno">   36 </span>import System.IO.Error
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>import Bag (bagToList)
<span class="lineno">   39 </span>import ErrUtils (errMsgSpan)
<span class="lineno">   40 </span>import FastString (unpackFS)
<span class="lineno">   41 </span>import GHC hiding (loadModule)
<span class="lineno">   42 </span>import GHC.Paths ( libdir )
<span class="lineno">   43 </span>import GhcMonad (GhcMonad(..), Session(..), reflectGhc)
<span class="lineno">   44 </span>import HscTypes (SourceError, srcErrorMessages)
<span class="lineno">   45 </span>import SrcLoc (realSrcSpanStart)
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>import Control.Reference
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>import Language.Haskell.Tools.AST
<span class="lineno">   50 </span>import Language.Haskell.Tools.ASTDebug
<span class="lineno">   51 </span>import Language.Haskell.Tools.ASTDebug.Instances ()
<span class="lineno">   52 </span>import Language.Haskell.Tools.PrettyPrint
<span class="lineno">   53 </span>import Language.Haskell.Tools.Refactor hiding (initSession)
<span class="lineno">   54 </span>import Language.Haskell.Tools.Refactor.Builtin
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>type ClientId = Int
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>data RefactorSessionState
<span class="lineno">   59 </span>  = RefactorSessionState { <span class="istickedoff"><span class="decl"><span class="istickedoff">_refSessMods</span></span></span> :: Map.Map (String, String, FilePath) (UnnamedModule IdDom)
<span class="lineno">   60 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_actualMod</span></span></span> :: Maybe (String, String, FilePath)
<span class="lineno">   61 </span>                         , <span class="istickedoff"><span class="decl"><span class="istickedoff">_isDisconnecting</span></span></span> :: Bool
<span class="lineno">   62 </span>                         }
<span class="lineno">   63 </span>
<span class="lineno">   64 </span><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeReferences ''RefactorSessionState</span></span></span></span></span></span></span></span>
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>initSession :: RefactorSessionState
<span class="lineno">   67 </span><span class="decl"><span class="istickedoff">initSession = RefactorSessionState Map.empty <span class="nottickedoff">Nothing</span> False</span></span>
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>runFromCLI :: IO ()
<span class="lineno">   70 </span><span class="decl"><span class="nottickedoff">runFromCLI = getArgs &gt;&gt;= runDemo</span></span>
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>runDemo :: [String] -&gt; IO ()
<span class="lineno">   73 </span><span class="decl"><span class="istickedoff">runDemo args = do</span>
<span class="lineno">   74 </span><span class="spaces">  </span><span class="istickedoff">wd &lt;- case args of dir:_ -&gt; <span class="nottickedoff">return dir</span></span>
<span class="lineno">   75 </span><span class="spaces">                     </span><span class="istickedoff">[] -&gt; return &quot;.&quot;</span>
<span class="lineno">   76 </span><span class="spaces">  </span><span class="istickedoff">counter &lt;- newMVar []</span>
<span class="lineno">   77 </span><span class="spaces">  </span><span class="istickedoff">let settings = setPort 8206 $ setTimeout 20 $ defaultSettings</span>
<span class="lineno">   78 </span><span class="spaces">  </span><span class="istickedoff">runSettings settings (app counter wd)</span></span>
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>-- | The application that is evoked for each incoming request
<span class="lineno">   81 </span>app :: MVar [Int] -&gt; FilePath -&gt; Application
<span class="lineno">   82 </span><span class="decl"><span class="istickedoff">app sessions wd = websocketsOr defaultConnectionOptions wsApp <span class="nottickedoff">backupApp</span></span>
<span class="lineno">   83 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="istickedoff">wsApp :: ServerApp</span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">wsApp conn = do</span>
<span class="lineno">   86 </span><span class="spaces">        </span><span class="istickedoff">conn &lt;- acceptRequest conn</span>
<span class="lineno">   87 </span><span class="spaces">        </span><span class="istickedoff">newind &lt;- modifyMVar sessions (\sess -&gt; let smallest = head (filter (not . (`elem` sess)) [0..])</span>
<span class="lineno">   88 </span><span class="spaces">                                                 </span><span class="istickedoff">in return (smallest : sess, smallest))</span>
<span class="lineno">   89 </span><span class="spaces">        </span><span class="istickedoff">ghcSess &lt;- initGhcSession (userDir wd newind)</span>
<span class="lineno">   90 </span><span class="spaces">        </span><span class="istickedoff">state &lt;- newMVar initSession</span>
<span class="lineno">   91 </span><span class="spaces">        </span><span class="istickedoff">serverLoop newind ghcSess state conn</span>
<span class="lineno">   92 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="istickedoff">serverLoop :: Int -&gt; Session -&gt; MVar RefactorSessionState -&gt; Connection -&gt; IO ()</span>
<span class="lineno">   94 </span><span class="spaces">    </span><span class="istickedoff">serverLoop sessId ghcSess state conn =</span>
<span class="lineno">   95 </span><span class="spaces">        </span><span class="istickedoff">do Text msg _ &lt;- receiveDataMessage conn</span>
<span class="lineno">   96 </span><span class="spaces">           </span><span class="istickedoff">respondTo wd sessId ghcSess state (sendTextData conn) msg</span>
<span class="lineno">   97 </span><span class="spaces">           </span><span class="istickedoff">currState &lt;- readMVar state</span>
<span class="lineno">   98 </span><span class="spaces">           </span><span class="istickedoff">if currState ^. isDisconnecting</span>
<span class="lineno">   99 </span><span class="spaces">             </span><span class="istickedoff">then sendClose conn (&quot;&quot; :: ByteString)</span>
<span class="lineno">  100 </span><span class="spaces">             </span><span class="istickedoff">else serverLoop sessId ghcSess state conn</span>
<span class="lineno">  101 </span><span class="spaces">      </span><span class="istickedoff">`catch` <span class="nottickedoff">\(_ :: ConnectionException) -&gt; do</span></span>
<span class="lineno">  102 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">modifyMVar_ sessions (return . delete sessId)</span></span>
<span class="lineno">  103 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">liftIO $ removeDirectoryIfPresent (userDir wd sessId)</span></span>
<span class="lineno">  104 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  105 </span><span class="spaces">    </span><span class="istickedoff">backupApp :: Application</span>
<span class="lineno">  106 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">backupApp _ respond = respond $ responseLBS status400 [] &quot;Not a WebSocket request&quot;</span></span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>respondTo :: FilePath -&gt; Int -&gt; Session -&gt; MVar RefactorSessionState -&gt; (ByteString -&gt; IO ()) -&gt; ByteString -&gt; IO ()
<span class="lineno">  109 </span><span class="decl"><span class="istickedoff">respondTo wd id ghcSess state next mess = case decode mess of</span>
<span class="lineno">  110 </span><span class="spaces">  </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">next $ encode (ErrorMessage $ &quot;WRONG MESSAGE FORMAT: &quot; ++ show (BS.unpack mess))</span></span>
<span class="lineno">  111 </span><span class="spaces">  </span><span class="istickedoff">Just req -&gt; handleErrors wd req (next . encode)</span>
<span class="lineno">  112 </span><span class="spaces">                </span><span class="istickedoff">$ do resp &lt;- modifyMVar state (\st -&gt; swap &lt;$&gt; reflectGhc (runStateT (updateClient (userDir wd id) req) st) ghcSess)</span>
<span class="lineno">  113 </span><span class="spaces">                     </span><span class="istickedoff">case resp of Just respMsg -&gt; next $ encode respMsg</span>
<span class="lineno">  114 </span><span class="spaces">                                  </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">()</span></span></span>
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>-- | This function does the real job of acting upon client messages in a stateful environment of a client
<span class="lineno">  117 </span>updateClient :: FilePath -&gt; ClientMessage -&gt; StateT RefactorSessionState Ghc (Maybe ResponseMsg)
<span class="lineno">  118 </span><span class="decl"><span class="istickedoff">updateClient _ KeepAlive = return Nothing</span>
<span class="lineno">  119 </span><span class="spaces"></span><span class="istickedoff">updateClient _ Disconnect = do modify $ isDisconnecting .= True</span>
<span class="lineno">  120 </span><span class="spaces">                               </span><span class="istickedoff">return $ Just Disconnected</span>
<span class="lineno">  121 </span><span class="spaces"></span><span class="istickedoff">updateClient dir (ModuleChanged name newContent) = do</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ createFileForModule dir name newContent</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="istickedoff">targets &lt;- lift getTargets</span>
<span class="lineno">  124 </span><span class="spaces">    </span><span class="istickedoff">when (isNothing . find ((\case (TargetModule n) -&gt; GHC.moduleNameString n == name; _ -&gt; <span class="nottickedoff">False</span>) . targetId) $ targets)</span>
<span class="lineno">  125 </span><span class="spaces">      </span><span class="istickedoff">$ lift $ addTarget (Target (TargetModule (GHC.mkModuleName name)) <span class="nottickedoff">True</span> Nothing)</span>
<span class="lineno">  126 </span><span class="spaces">    </span><span class="istickedoff">void $ lift $ load LoadAllTargets</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="istickedoff">reloadAllMods dir</span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="istickedoff">return Nothing</span>
<span class="lineno">  129 </span><span class="spaces"></span><span class="istickedoff">updateClient dir (ModuleDeleted name) = do</span>
<span class="lineno">  130 </span><span class="spaces">    </span><span class="istickedoff">lift $ removeTarget (TargetModule (GHC.mkModuleName name))</span>
<span class="lineno">  131 </span><span class="spaces">    </span><span class="istickedoff">modify $ refSessMods .- Map.delete (dir, name, dir &lt;/&gt; moduleSourceFile name)</span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="istickedoff">return Nothing</span>
<span class="lineno">  133 </span><span class="spaces"></span><span class="istickedoff">updateClient dir (InitialProject modules) = do</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">-- clean the workspace to remove source files from earlier sessions</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ removeDirectoryIfPresent dir</span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ createDirectoryIfMissing True dir</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ forM_ modules $ \(mod, cont) -&gt; do</span>
<span class="lineno">  138 </span><span class="spaces">      </span><span class="istickedoff">withBinaryFile (toFileName dir mod) WriteMode (`hPutStr` cont)</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">lift $ setTargets (map ((\modName -&gt; Target (TargetModule (GHC.mkModuleName modName)) <span class="nottickedoff">True</span> Nothing) . fst) modules)</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="istickedoff">reloadAllMods dir</span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="istickedoff">return Nothing</span>
<span class="lineno">  142 </span><span class="spaces"></span><span class="istickedoff">updateClient _ (PerformRefactoring &quot;UpdateAST&quot; modName _ _) = do</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="istickedoff">mod &lt;- gets (find ((modName ==) . (\(_,m,_) -&gt; m) . fst) . Map.assocs . (^. refSessMods))</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">case mod of Just (_,m) -&gt; return $ Just $ ASTViewContent $ astDebug m</span>
<span class="lineno">  145 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return $ Just $ ErrorMessage &quot;The module is not found&quot;</span></span>
<span class="lineno">  146 </span><span class="spaces"></span><span class="istickedoff">updateClient _ (PerformRefactoring &quot;TestErrorLogging&quot; _ _ _) = <span class="nottickedoff">error &quot;This is a test&quot;</span></span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="istickedoff">updateClient dir (PerformRefactoring refact modName selection args) = do</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff">mod &lt;- gets (find ((modName ==) . (\(_,m,_) -&gt; m) . fst) . Map.assocs . (^. refSessMods))</span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff">otherModules &lt;- gets (filter ((modName /=) . (^. sfkModuleName) . fst) . map moduleNameAndContent . Map.assocs . (^. refSessMods))</span>
<span class="lineno">  150 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="istickedoff">case mod of</span>
<span class="lineno">  152 </span><span class="spaces">      </span><span class="istickedoff">Just m -&gt;</span>
<span class="lineno">  153 </span><span class="spaces">        </span><span class="istickedoff">do res &lt;- lift $ performCommand builtinRefactorings</span>
<span class="lineno">  154 </span><span class="spaces">                                        </span><span class="istickedoff">([refact,selection] ++ args)</span>
<span class="lineno">  155 </span><span class="spaces">                                        </span><span class="istickedoff">(Right $ moduleNameAndContent m) otherModules</span>
<span class="lineno">  156 </span><span class="spaces">           </span><span class="istickedoff">case res of</span>
<span class="lineno">  157 </span><span class="spaces">             </span><span class="istickedoff">Right diff -&gt; do applyChanges diff</span>
<span class="lineno">  158 </span><span class="spaces">                              </span><span class="istickedoff">return $ Just $ RefactorChanges (map trfDiff diff)</span>
<span class="lineno">  159 </span><span class="spaces">             </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">return $ Just $ ErrorMessage err</span></span>
<span class="lineno">  160 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return $ Just $ ErrorMessage &quot;The module is not found&quot;</span></span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="istickedoff">where trfDiff (ContentChanged (key,cont)) = (key ^. sfkModuleName, Just (prettyPrint cont))</span>
<span class="lineno">  162 </span><span class="spaces">        </span><span class="istickedoff">trfDiff (ModuleCreated name mod _) = (name, Just (prettyPrint mod))</span>
<span class="lineno">  163 </span><span class="spaces">        </span><span class="istickedoff">trfDiff (ModuleRemoved name) = (name, Nothing)</span>
<span class="lineno">  164 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  165 </span><span class="spaces">        </span><span class="istickedoff">applyChanges diff</span>
<span class="lineno">  166 </span><span class="spaces">          </span><span class="istickedoff">= do forM_ diff $ \case</span>
<span class="lineno">  167 </span><span class="spaces">                 </span><span class="istickedoff">ModuleCreated n m _ -&gt; do</span>
<span class="lineno">  168 </span><span class="spaces">                   </span><span class="istickedoff">writeModule n m</span>
<span class="lineno">  169 </span><span class="spaces">                   </span><span class="istickedoff">lift $ addTarget (Target (TargetModule (GHC.mkModuleName n)) <span class="nottickedoff">True</span> Nothing)</span>
<span class="lineno">  170 </span><span class="spaces">                 </span><span class="istickedoff">ContentChanged (n,m) -&gt;</span>
<span class="lineno">  171 </span><span class="spaces">                   </span><span class="istickedoff">writeModule (n ^. sfkModuleName) m</span>
<span class="lineno">  172 </span><span class="spaces">                 </span><span class="istickedoff">ModuleRemoved mod -&gt; do</span>
<span class="lineno">  173 </span><span class="spaces">                   </span><span class="istickedoff">liftIO $ removeFile (toFileName dir mod)</span>
<span class="lineno">  174 </span><span class="spaces">                   </span><span class="istickedoff">modify $ refSessMods .- <span class="nottickedoff">Map.delete (dir, mod, dir &lt;/&gt; moduleSourceFile mod)</span></span>
<span class="lineno">  175 </span><span class="spaces">                   </span><span class="istickedoff">lift $ removeTarget (TargetModule (GHC.mkModuleName mod))</span>
<span class="lineno">  176 </span><span class="spaces">               </span><span class="istickedoff">reloadAllMods <span class="nottickedoff">dir</span></span>
<span class="lineno">  177 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  178 </span><span class="spaces">        </span><span class="istickedoff">writeModule n m = liftIO $ withBinaryFile (toFileName dir n) WriteMode (`hPutStr` prettyPrint m)</span></span>
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>reloadAllMods :: FilePath -&gt; StateT RefactorSessionState Ghc ()
<span class="lineno">  181 </span><span class="decl"><span class="istickedoff">reloadAllMods dir = do</span>
<span class="lineno">  182 </span><span class="spaces">  </span><span class="istickedoff">void $ lift $ load LoadAllTargets</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="istickedoff">targets &lt;- lift getTargets</span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">forM_ (map ((\case (TargetModule n) -&gt; n) . targetId) targets) $ \modName -&gt; do</span>
<span class="lineno">  185 </span><span class="spaces">      </span><span class="istickedoff">mod &lt;- lift $ getModSummary modName &gt;&gt;= parseTyped</span>
<span class="lineno">  186 </span><span class="spaces">      </span><span class="istickedoff">modify $ refSessMods .- Map.insert (dir, GHC.moduleNameString modName, dir &lt;/&gt; moduleSourceFile (GHC.moduleNameString modName)) mod</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>createFileForModule :: FilePath -&gt; String -&gt; String -&gt; IO ()
<span class="lineno">  189 </span><span class="decl"><span class="istickedoff">createFileForModule dir name newContent = do</span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">let fname = toFileName dir name</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">createDirectoryIfMissing True (takeDirectory fname)</span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="istickedoff">withBinaryFile fname WriteMode (`hPutStr` newContent)</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>removeDirectoryIfPresent :: FilePath -&gt; IO ()
<span class="lineno">  195 </span><span class="decl"><span class="istickedoff">removeDirectoryIfPresent dir = removeDirectoryRecursive dir `catch` \e -&gt; if <span class="tickonlytrue">isDoesNotExistError e</span> then return <span class="nottickedoff">()</span> else <span class="nottickedoff">throwIO e</span></span></span>
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>moduleNameAndContent :: ((String,String,FilePath), mod) -&gt; (SourceFileKey, mod)
<span class="lineno">  198 </span><span class="decl"><span class="istickedoff">moduleNameAndContent ((_,name,isBoot), mod) = (SourceFileKey <span class="nottickedoff">isBoot</span> name, mod)</span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>dataDirs :: FilePath -&gt; FilePath
<span class="lineno">  201 </span><span class="decl"><span class="istickedoff">dataDirs wd = normalise $ wd &lt;/&gt; &quot;demoSources&quot;</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>userDir :: FilePath -&gt; ClientId -&gt; FilePath
<span class="lineno">  204 </span><span class="decl"><span class="istickedoff">userDir wd id = dataDirs wd &lt;/&gt; show id</span></span>
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>initGhcSession :: FilePath -&gt; IO Session
<span class="lineno">  207 </span><span class="decl"><span class="istickedoff">initGhcSession workingDir</span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="istickedoff">= Session &lt;$&gt; (newIORef =&lt;&lt; runGhc (Just libdir) (initGhcFlagsForTest &gt;&gt; useDirs [workingDir] &gt;&gt; getSession))</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>handleErrors :: FilePath -&gt; ClientMessage -&gt; (ResponseMsg -&gt; IO ()) -&gt; IO () -&gt; IO ()
<span class="lineno">  211 </span><span class="decl"><span class="istickedoff">handleErrors wd req next io = io `catch` (next &lt;=&lt; handleException)</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="istickedoff">where handleException :: SomeException -&gt; IO ResponseMsg</span>
<span class="lineno">  213 </span><span class="spaces">        </span><span class="istickedoff">handleException e</span>
<span class="lineno">  214 </span><span class="spaces">          </span><span class="istickedoff">| Just (se :: SourceError) &lt;- fromException e</span>
<span class="lineno">  215 </span><span class="spaces">          </span><span class="istickedoff">= if <span class="tickonlyfalse">isReloading</span></span>
<span class="lineno">  216 </span><span class="spaces">              </span><span class="istickedoff">then <span class="nottickedoff">do logToFile wd (show e) req</span></span>
<span class="lineno">  217 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">return $ ErrorMessage (&quot;The generated code cannot be compiled. The problem had been reported. Please restart the demo or correct the results manually.&quot;)</span></span>
<span class="lineno">  218 </span><span class="spaces">              </span><span class="istickedoff">else return $ CompilationProblem (concatMap (\msg -&gt; showMsg msg ++ &quot;\n\n&quot;) $ bagToList $ srcErrorMessages se)</span>
<span class="lineno">  219 </span><span class="spaces">          </span><span class="istickedoff">| Just (ae :: AsyncException) &lt;- <span class="nottickedoff">fromException e</span> = <span class="nottickedoff">throw ae</span></span>
<span class="lineno">  220 </span><span class="spaces">          </span><span class="istickedoff">| Just (ge :: GhcException) &lt;- <span class="nottickedoff">fromException e</span> = <span class="nottickedoff">return $ ErrorMessage $ show ge</span></span>
<span class="lineno">  221 </span><span class="spaces">          </span><span class="istickedoff">| Just (re :: RefactorException) &lt;- <span class="nottickedoff">fromException e</span> = <span class="nottickedoff">return $ ErrorMessage $ displayException re</span></span>
<span class="lineno">  222 </span><span class="spaces">          </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">do logToFile wd (show e) req</span></span>
<span class="lineno">  223 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">return $ ErrorMessage (showInternalError e)</span></span>
<span class="lineno">  224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  225 </span><span class="spaces">        </span><span class="istickedoff">showMsg msg = showSpan (errMsgSpan msg) ++ &quot;\n&quot; ++ show msg</span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff">showSpan (RealSrcSpan sp) = showFileName (srcLocFile (realSrcSpanStart sp)) ++ &quot; &quot; ++ show (srcLocLine (realSrcSpanStart sp)) ++ &quot;:&quot; ++ show (srcLocCol (realSrcSpanStart sp))</span>
<span class="lineno">  227 </span><span class="spaces">        </span><span class="istickedoff">showSpan _ = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno">  228 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  229 </span><span class="spaces">        </span><span class="istickedoff">isReloading = case req of PerformRefactoring {} -&gt; <span class="nottickedoff">True</span>; _ -&gt; False</span>
<span class="lineno">  230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  231 </span><span class="spaces">        </span><span class="istickedoff">showFileName = joinPath . drop 2 . splitPath . makeRelative wd . unpackFS</span>
<span class="lineno">  232 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  233 </span><span class="spaces">        </span><span class="istickedoff">showInternalError :: SomeException -&gt; String</span>
<span class="lineno">  234 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">showInternalError e = &quot;An internal error happened. The report has been sent to the developers. &quot; ++ displayException e</span></span></span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>logToFile :: FilePath -&gt; String -&gt; ClientMessage -&gt; IO ()
<span class="lineno">  237 </span><span class="decl"><span class="nottickedoff">logToFile wd err input = do</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="nottickedoff">let msg = err ++ &quot;\n with input: &quot; ++ show input</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="nottickedoff">withFile logFile AppendMode $ \handle -&gt; do</span>
<span class="lineno">  240 </span><span class="spaces">      </span><span class="nottickedoff">size &lt;- hFileSize handle</span>
<span class="lineno">  241 </span><span class="spaces">      </span><span class="nottickedoff">when (size &lt; logSizeLimit) $ hPutStrLn handle (&quot;\n### &quot; ++ msg)</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="nottickedoff">`catch` \e -&gt; print (&quot;The error message cannot be logged because: &quot;</span>
<span class="lineno">  243 </span><span class="spaces">                             </span><span class="nottickedoff">++ show (e :: IOException) ++ &quot;\nHere is the message:\n&quot; ++ msg)</span>
<span class="lineno">  244 </span><span class="spaces">  </span><span class="nottickedoff">where logFile = wd &lt;/&gt; &quot;error-log.txt&quot;</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="nottickedoff">logSizeLimit = 100 * 1024 * 1024</span></span> -- 100 MB
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>data ClientMessage
<span class="lineno">  248 </span>  = KeepAlive
<span class="lineno">  249 </span>  | InitialProject { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">initialModules</span></span></span> :: [(String,String)] }
<span class="lineno">  250 </span>  | PerformRefactoring { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">refactoring</span></span></span> :: String
<span class="lineno">  251 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">moduleName</span></span></span> :: String
<span class="lineno">  252 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">editorSelection</span></span></span> :: String
<span class="lineno">  253 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">details</span></span></span> :: [String]
<span class="lineno">  254 </span>                       }
<span class="lineno">  255 </span>  | ModuleChanged { moduleName :: String
<span class="lineno">  256 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">newContent</span></span></span> :: String
<span class="lineno">  257 </span>                  }
<span class="lineno">  258 </span>  | ModuleDeleted { moduleName :: String }
<span class="lineno">  259 </span>  | Disconnect
<span class="lineno">  260 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic)
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>instance FromJSON ClientMessage
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>data ResponseMsg
<span class="lineno">  265 </span>  = RefactorChanges { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">moduleChanges</span></span></span> :: [(String, Maybe String)] }
<span class="lineno">  266 </span>  | ASTViewContent { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">astContent</span></span></span> :: String }
<span class="lineno">  267 </span>  | ErrorMessage { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">errorMsg</span></span></span> :: String }
<span class="lineno">  268 </span>  | CompilationProblem { errorMsg :: String }
<span class="lineno">  269 </span>  | Disconnected
<span class="lineno">  270 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic)
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>instance ToJSON ResponseMsg

</pre>
</body>
</html>
