-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Refactoring Tool for Haskell
--   
--   Contains a set of refactorings based on the Haskell-Tools framework to
--   easily transform a Haskell program. For the descriptions of the
--   implemented refactorings, see the homepage.
@package haskell-tools-refactor
@version 1.1.0.2


-- | Representation of modules, their collections, refactoring changes and
--   exceptions.
module Language.Haskell.Tools.Refactor.Representation

-- | A type for the input and result of refactoring a module
type UnnamedModule = Ann UModule IdDom SrcTemplateStage

-- | The name of the module and the AST
type ModuleDom = (SourceFileKey, UnnamedModule)

-- | Module name and marker to separate .hs-boot module definitions.
--   Specifies a source file in a working directory.
data SourceFileKey
SourceFileKey :: FilePath -> String -> SourceFileKey
[_sfkFileName] :: SourceFileKey -> FilePath
[_sfkModuleName] :: SourceFileKey -> String

-- | Change in the project, modification or removal of a module.
data RefactorChange
ContentChanged :: ModuleDom -> RefactorChange
[fromContentChanged] :: RefactorChange -> ModuleDom
ModuleRemoved :: String -> RefactorChange
[removedModuleName] :: RefactorChange -> String
ModuleCreated :: String -> UnnamedModule -> SourceFileKey -> RefactorChange
[createdModuleName] :: RefactorChange -> String
[createdModuleContent] :: RefactorChange -> UnnamedModule
[sameLocation] :: RefactorChange -> SourceFileKey

-- | Exceptions that can occur while loading modules or during internal
--   operations (not during performing the refactor).
data RefactorException
IllegalExtensions :: [String] -> RefactorException
SourceCodeProblem :: ErrorMessages -> RefactorException
UnknownException :: String -> RefactorException

-- | Transforms module name to a .hs file name relative to the source root
--   directory.
moduleSourceFile :: String -> FilePath

-- | Transforms a source root relative file name into module name.
sourceFileModule :: FilePath -> String
sfkModuleName :: Lens SourceFileKey SourceFileKey String String
sfkFileName :: Lens SourceFileKey SourceFileKey FilePath FilePath
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.RefactorException
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Classes.Ord Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Exception.Type.Exception Language.Haskell.Tools.Refactor.Representation.RefactorException
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.RefactorChange
instance GHC.Show.Show ErrUtils.ErrorMessages


-- | Types and instances for monadic refactorings. The refactoring monad
--   provides automatic importing, keeping important source fragments (such
--   as preprocessor pragmas), and providing contextual information for
--   refactorings.
module Language.Haskell.Tools.Refactor.Monad

-- | A monad that can be used to refactor
class Monad m => RefactorMonad m
refactError :: RefactorMonad m => String -> m a
liftGhc :: RefactorMonad m => Ghc a -> m a

-- | A refactoring that only affects one module
type LocalRefactoring = UnnamedModule -> LocalRefactor UnnamedModule

-- | The type of a refactoring
type Refactoring = ModuleDom -> [ModuleDom] -> Refactor [RefactorChange]

-- | The type of a refactoring that affects the whole project.
type ProjectRefactoring = [ModuleDom] -> Refactor [RefactorChange]

-- | The refactoring monad for a given module
type LocalRefactor = LocalRefactorT Refactor

-- | The refactoring monad for the whole project
type Refactor = ExceptT String Ghc

-- | Input and output information for the refactoring TODO: use multiple
--   states instead of Either
newtype LocalRefactorT m a
LocalRefactorT :: WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a -> LocalRefactorT m a
[fromRefactorT] :: LocalRefactorT m a -> WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a

-- | The information a refactoring can use
data RefactorCtx
RefactorCtx :: Module -> Ann UModule IdDom SrcTemplateStage -> [Ann UImportDecl IdDom SrcTemplateStage] -> RefactorCtx

-- | The name of the module being refactored. Used for accessing implicit
--   imports.
[refModuleName] :: RefactorCtx -> Module
[refCtxRoot] :: RefactorCtx -> Ann UModule IdDom SrcTemplateStage
[refCtxImports] :: RefactorCtx -> [Ann UImportDecl IdDom SrcTemplateStage]
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => Control.Monad.Writer.Class.MonadWriter [Data.Either.Either Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)] (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Language.Haskell.Tools.Refactor.Monad.RefactorCtx (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad Language.Haskell.Tools.Refactor.Monad.LocalRefactor
instance Control.Monad.Trans.Class.MonadTrans Language.Haskell.Tools.Refactor.Monad.LocalRefactorT
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad Language.Haskell.Tools.Refactor.Monad.Refactor
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad m => Language.Haskell.Tools.Refactor.Monad.RefactorMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad m => Language.Haskell.Tools.Refactor.Monad.RefactorMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GhcMonad.GhcMonad m, GHC.Base.Monoid s) => GhcMonad.GhcMonad (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (Exception.ExceptionMonad m, GHC.Base.Monoid s) => Exception.ExceptionMonad (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.State.Strict.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.State.Lazy.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.Reader.ReaderT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Reader.ReaderT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.Except.ExceptT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Except.ExceptT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Maybe.MaybeT m)


-- | Operations for changing the AST
module Language.Haskell.Tools.Refactor.Utils.AST

-- | Remove an element from the AST while keeping the textual parts of it
--   that should not be removed (like preprocessor pragmas).
removeChild :: SourceInfoTraversal e => e dom SrcTemplateStage -> LocalRefactor ()

-- | Remove a separator from the AST while keeping the textual parts of it
--   that should not be removed (like preprocessor pragmas).
removeSeparator :: ([SourceTemplateTextElem], SrcSpan) -> LocalRefactor ()


-- | Utilities for transformations that work on both top-level and local
--   definitions
module Language.Haskell.Tools.Refactor.Utils.BindingElem

-- | A type class for handling definitions that can appear as both
--   top-level and local definitions
class NamedElement d => BindingElem d

-- | Accesses a type signature definition in a local or top-level
--   definition
sigBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) TypeSignature

-- | Accesses a value or function definition in a local or top-level
--   definition
valBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) ValueBind

-- | Accesses a type signature definition in a local or top-level
--   definition
fixitySig :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) FixitySignature

-- | Creates a new definition from a type signature
createTypeSig :: BindingElem d => TypeSignature -> Ann d IdDom SrcTemplateStage

-- | Creates a new definition from a value or function definition
createBinding :: BindingElem d => ValueBind -> Ann d IdDom SrcTemplateStage

-- | Creates a new fixity signature
createFixitySig :: BindingElem d => FixitySignature -> Ann d IdDom SrcTemplateStage

-- | Checks if a given definition is a type signature
isTypeSig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a function or value binding
isBinding :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a fixity signature
isFixitySig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool
getValBindInList :: BindingElem d => RealSrcSpan -> AnnList d -> Maybe ValueBind
valBindsInList :: BindingElem d => Simple Traversal (AnnList d) ValueBind
instance Language.Haskell.Tools.Refactor.Utils.BindingElem.BindingElem Language.Haskell.Tools.AST.Representation.Decls.UDecl
instance Language.Haskell.Tools.Refactor.Utils.BindingElem.BindingElem Language.Haskell.Tools.AST.Representation.Binds.ULocalBind

module Language.Haskell.Tools.Refactor.Utils.Debug
debugM :: (Monad m, Show a) => m a -> m a
debug :: Show a => a -> a

-- | Displays True iff the wrapped value is a Just
debugMaybeT :: Monad m => MaybeT m a -> MaybeT m a
showOutputable :: Outputable a => a -> String
showName :: Name -> String
showOp :: Operator -> String

module Language.Haskell.Tools.Refactor.Utils.Extensions

-- | Expands an extension into all the extensions it implies (keeps
--   original as well)
expandExtension :: Extension -> [Extension]

-- | Replaces deprecated extensions with their new counterpart
replaceDeprecated :: Extension -> Extension
turnOn :: Bool
turnOff :: Bool
impliedXFlags :: [(Extension, Bool, Extension)]

-- | These extensions' GHC representation name differs from their actual
--   name
irregularExtensions :: [(String, String)]

-- | Canonicalize extensions. This is a helper function for parsing
--   extensions This way we can say <tt>read . canonExt</tt> to parse any
--   extension string
canonExt :: String -> String

-- | Serializes the extension's GHC name into its LANGUAGE pragma name.
--   Should be always used in composition with show (<tt>seriealizeExt .
--   show</tt>) when refactoring extensions. This function also replaces
--   depracted extensions with their new versions.
serializeExt :: String -> String

-- | Map the cabal extensions to the ones that GHC recognizes
translateExtension :: KnownExtension -> Maybe Extension

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension


-- | Utilities to modify the indentation of AST fragments
module Language.Haskell.Tools.Refactor.Utils.Indentation

-- | Set the minimal indentation recursively for a part of the AST
setMinimalIndent :: SourceInfoTraversal elem => Int -> elem dom SrcTemplateStage -> elem dom SrcTemplateStage


-- | Defines operation on AST lists. AST lists carry source information so
--   simple list modification is not enough.
module Language.Haskell.Tools.Refactor.Utils.Lists

-- | Filters the elements of the list. By default it removes the separator
--   before the element. Of course, if the first element is removed, the
--   following separator is removed as well.
filterList :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e
filterListIndexed :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e

-- | A version of filterList that cares about keeping non-removable code
--   elements (like preprocessor pragmas)
filterListSt :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | A version of filterListIndexed that cares about keeping non-removable
--   code elements (like preprocessor pragmas)
filterListIndexedSt :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | Selects the given indices from a list
sublist :: [Int] -> [a] -> [a]

-- | Selects all but the given indices from a list
notSublist :: [Int] -> [a] -> [a]

-- | Inserts the element in the places where the two positioning functions
--   (one checks the element before, one the element after) allows the
--   placement.
insertWhere :: Bool -> Ann e IdDom SrcTemplateStage -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> AnnList e -> AnnList e

-- | Checks where the element will be inserted given the two positioning
--   functions.
insertIndex :: (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> [Ann e IdDom SrcTemplateStage] -> Maybe Int

-- | Gets the elements and separators from a list. The first separator is
--   zipped to the second element. To the first element, the "" string is
--   zipped.
zipWithSeparators :: AnnList e -> [(([SourceTemplateTextElem], SrcSpan), Ann e IdDom SrcTemplateStage)]


-- | Helper functions for defining refactorings.
module Language.Haskell.Tools.Refactor.Utils.Helpers
replaceWithJust :: Ann e IdDom SrcTemplateStage -> AnnMaybe e -> AnnMaybe e
replaceWithNothing :: AnnMaybe e -> AnnMaybe e

-- | Remove the container (where or let) when the last binding is removed.
removeEmptyBnds :: Simple Traversal Module ValueBind -> Simple Traversal Module Expr -> Module -> Module

-- | Puts the elements in the orginal order and remove duplicates (elements
--   with the same source range)
normalizeElements :: [Ann e dom SrcTemplateStage] -> [Ann e dom SrcTemplateStage]

-- | Groups elements together into equivalence groups.
groupElemsBy :: Ord k => (a -> k) -> [a] -> [[a]]

-- | Chooses a representative element for each equivalence group, and pairs
--   them with their corresponding group.
reprElems :: [[a]] -> [(a, [a])]

-- | Sorts the elements of a list into equivalence groups based on a
--   function, then chooses a representative element for each group, and
--   pairs them with their corresponding group.
equivalenceGroupsBy :: Ord k => (a -> k) -> [a] -> [(a, [a])]

module Language.Haskell.Tools.Refactor.Utils.Maybe
isJustT :: Monad m => MaybeT m a -> m Bool
isNothingT :: Monad m => MaybeT m a -> m Bool
liftMaybe :: Monad m => Maybe a -> MaybeT m a
fromMaybeT :: Monad m => a -> MaybeT m a -> m a
fromMaybeTM :: Monad m => m a -> MaybeT m a -> m a
maybeT :: Monad m => b -> (a -> b) -> MaybeT m a -> m b
maybeTM :: Monad m => m b -> (a -> m b) -> MaybeT m a -> m b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT a
[runMaybeT] :: MaybeT a -> m (Maybe a)


-- | Basic utilities and types for defining refactorings.
module Language.Haskell.Tools.Refactor.Utils.Monadic

-- | Performs the given refactoring, transforming it into a Ghc action
runRefactor :: ModuleDom -> [ModuleDom] -> Refactoring -> Ghc (Either String [RefactorChange])

-- | Wraps a refactoring that only affects one module. Performs the
--   per-module finishing touches.
localRefactoring :: LocalRefactoring -> Refactoring

-- | Transform the result of the local refactoring
localRefactoringRes :: ((UnnamedModule -> UnnamedModule) -> a -> a) -> UnnamedModule -> LocalRefactor a -> Refactor a

-- | Re-inserts the elements removed from the AST that should be kept (for
--   example preprocessor directives)
insertText :: SourceInfoTraversal p => [(SrcSpan, String, String)] -> p dom SrcTemplateStage -> p dom SrcTemplateStage

-- | Adds the imports that bring names into scope that are needed by the
--   refactoring
addGeneratedImports :: [Name] -> Module -> Module
registeredNamesFromPrelude :: [Name]
otherNamesFromPrelude :: [String]
qualifiedName :: Name -> String
referenceName :: Name -> LocalRefactor (Ann UName IdDom SrcTemplateStage)
referenceOperator :: Name -> LocalRefactor (Ann UOperator IdDom SrcTemplateStage)

-- | Create a name that references the definition. Generates an import if
--   the definition is not yet imported.
referenceName' :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> LocalRefactor (Ann nt IdDom SrcTemplateStage)

-- | Reference the name by the shortest suitable import
referenceBy :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> [Ann UImportDecl IdDom SrcTemplateStage] -> Ann nt IdDom SrcTemplateStage


-- | Defines utility methods that prepare Haskell modules for refactoring
module Language.Haskell.Tools.Refactor.Prepare

-- | Type synonym for module names.
type ModuleName = String

-- | A quick function to try the refactorings
tryRefactor :: (RealSrcSpan -> Refactoring) -> String -> ModuleName -> IO ()

-- | Adjust the source range to be applied to the refactored module
correctRefactorSpan :: UnnamedModule -> RealSrcSpan -> RealSrcSpan

-- | Set the given flags for the GHC session. Also gives back a change
--   function that you can use to apply the settings to any flags. Prints
--   out errors and warnings
useFlags :: [String] -> Ghc ([String], DynFlags -> DynFlags)
pprWarning :: Warn -> SDoc
pprErr :: Err -> SDoc

-- | Reloads the package database based on the session flags
reloadPkgDb :: Ghc ()

-- | Initialize GHC flags to default values that support refactoring
initGhcFlags :: Ghc ()
initGhcFlagsForTest :: Ghc ()

-- | Sets up basic flags and settings for GHC
initGhcFlags' :: Bool -> Bool -> Ghc ()

-- | Use the given source directories when searching for imported modules
useDirs :: [FilePath] -> Ghc ()

-- | Don't use the given source directories when searching for imported
--   modules
deregisterDirs :: [FilePath] -> Ghc ()

-- | Translates module name and working directory into the name of the file
--   where the given module should be defined
toFileName :: FilePath -> ModuleName -> FilePath

-- | Translates module name and working directory into the name of the file
--   where the boot module should be defined
toBootFileName :: FilePath -> ModuleName -> FilePath

-- | Get the source directory where the module is located.
getSourceDir :: ModSummary -> IO FilePath

-- | Gets the path to the source file of the module.
getModSumOrig :: ModSummary -> FilePath
keyFromMS :: ModSummary -> SourceFileKey

-- | Gets the module name
getModSumName :: ModSummary -> String

-- | Load the AST of a module given by the working directory and module
--   name.
loadModuleAST :: FilePath -> ModuleName -> Ghc TypedModule

-- | Load the summary of a module given by the working directory and module
--   name.
loadModule :: FilePath -> ModuleName -> Ghc ModSummary

-- | The final version of our AST, with type infromation added
type TypedModule = Ann UModule IdDom SrcTemplateStage

-- | Get the typed representation of a Haskell module.
parseTyped :: ModSummary -> Ghc TypedModule
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension
trfProblem :: String -> a

-- | Modifies the dynamic flags for performing a ghc task
withAlteredDynFlags :: GhcMonad m => (DynFlags -> m DynFlags) -> m a -> m a

-- | Forces the code generation for a given module
forceCodeGen :: ModSummary -> ModSummary
codeGenDfs :: DynFlags -> DynFlags

-- | Forces ASM code generation for a given module
forceAsmGen :: ModSummary -> ModSummary

-- | Normalizes the flags for a module summary
modSumNormalizeFlags :: ModSummary -> ModSummary

-- | Removes all flags that are unintelligable for refactoring
normalizeFlags :: DynFlags -> DynFlags

-- | Read a source range from our textual format:
--   <tt>line:col-line:col</tt> or <tt>line:col</tt>
readSrcSpan :: String -> RealSrcSpan

-- | Read a source location from our format: <tt>line:col</tt>
readSrcLoc :: String -> RealSrcLoc
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Prepare.UnsupportedExtension
instance GHC.Exception.Type.Exception Language.Haskell.Tools.Refactor.Prepare.UnsupportedExtension


-- | Defines a representation to represent refactorings that can be
--   executed on the codebase. Refactorings are differentiated on their
--   signatures (inputs needed to execute).
module Language.Haskell.Tools.Refactor.Refactoring

-- | The signature and behavior of one refactoring that can be executed.
data RefactoringChoice
NamingRefactoring :: String -> (RealSrcSpan -> String -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoring] :: RefactoringChoice -> RealSrcSpan -> String -> Refactoring
NamingRefactoringIndent :: String -> (RealSrcSpan -> String -> Maybe String -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoringIndent] :: RefactoringChoice -> RealSrcSpan -> String -> Maybe String -> Refactoring
SelectionRefactoring :: String -> (RealSrcSpan -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[selectionRefactoring] :: RefactoringChoice -> RealSrcSpan -> Refactoring
ModuleRefactoring :: String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[moduleRefactoring] :: RefactoringChoice -> Refactoring
ProjectRefactoring :: String -> ProjectRefactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[projectRefactoring] :: RefactoringChoice -> ProjectRefactoring

-- | Executes a given command (choosen from the set of available
--   refactorings) on the selected module and given other modules.
performCommand :: [RefactoringChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String [RefactorChange])

-- | Gets the name of possible refactorings.
refactorCommands :: [RefactoringChoice] -> [String]

module Language.Haskell.Tools.Refactor.Querying
type QueryType = String
type QueryMonad = ExceptT String Ghc
data QueryValue
GeneralQuery :: Value -> QueryValue
MarkerQuery :: [Marker] -> QueryValue
data QueryChoice
LocationQuery :: String -> (RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue) -> QueryChoice
[queryName] :: QueryChoice -> String
[locationQuery] :: QueryChoice -> RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
GlobalQuery :: String -> (ModuleDom -> [ModuleDom] -> QueryMonad QueryValue) -> QueryChoice
[queryName] :: QueryChoice -> String
[globalQuery] :: QueryChoice -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
data Marker
Marker :: SrcSpan -> Severity -> String -> Marker
[location] :: Marker -> SrcSpan
[severity] :: Marker -> Severity
[message] :: Marker -> String
data Severity
Error :: Severity
Warning :: Severity
Info :: Severity
decompQuery :: QueryValue -> (QueryType, Value)
queryCommands :: [QueryChoice] -> [String]
queryError :: String -> QueryMonad a
performQuery :: [QueryChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String (QueryType, Value))
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Querying.QueryValue
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Querying.QueryValue
instance GHC.Generics.Generic Language.Haskell.Tools.Refactor.Querying.QueryValue
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Querying.Marker
instance GHC.Generics.Generic Language.Haskell.Tools.Refactor.Querying.Marker
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Querying.Severity
instance GHC.Generics.Generic Language.Haskell.Tools.Refactor.Querying.Severity
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Querying.Severity
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Refactor.Querying.QueryValue
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Refactor.Querying.Marker
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Querying.Marker
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Refactor.Querying.Severity
instance Data.Aeson.Types.ToJSON.ToJSON SrcLoc.SrcSpan


-- | Defines utility operations on Haskell names such as checking if a
--   given identifier is a correct name for a certain kind of Haskell
--   construct.
module Language.Haskell.Tools.Refactor.Utils.Name

-- | Different classes of definitions that have different kind of names.
data NameClass

-- | Normal value definitions: functions, variables
Variable :: NameClass

-- | Data constructors
Ctor :: NameClass

-- | Functions with operator-like names
ValueOperator :: NameClass

-- | Constructors with operator-like names
DataCtorOperator :: NameClass

-- | UType definitions with operator-like names
SynonymOperator :: NameClass

-- | Get which category does a given name belong to
classifyName :: RefactorMonad m => Name -> m NameClass

-- | Checks if a given name is a valid module name
validModuleName :: String -> Maybe String

-- | Check if a given name is valid for a given kind of definition
nameValid :: NameClass -> String -> Maybe String
isIdChar :: Char -> Bool
isOperatorChar :: Char -> Bool

module Language.Haskell.Tools.Refactor.Utils.NameLookup
opSemName :: Operator -> Maybe Name
declHeadQName :: DeclHead -> QualifiedName
declHeadSemName :: DeclHead -> Maybe Name
instHeadSemName :: InstanceHead -> Maybe Name

-- | Collects the qualified names of the class heads in an assertion.
assertionQNames :: Assertion -> [QualifiedName]

-- | Collects the semantic names of the class heads in an assertion.
assertionSemNames :: Assertion -> [Name]

-- | Extracts the name of a type. In case of a type application, it finds
--   the type being applied. It works only for unambiguous types, so it
--   won't work for tuples.
nameFromType :: Type -> Maybe Name
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Name.Name
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Language.Haskell.Tools.Rewrite.ElementTypes.Operator
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Language.Haskell.Tools.Rewrite.ElementTypes.DeclHead
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Language.Haskell.Tools.Rewrite.ElementTypes.InstanceHead

module Language.Haskell.Tools.Refactor.Utils.Type
typeExpr :: Expr -> Ghc Type
appTypeMatches :: [ClsInst] -> Type -> [Type] -> Maybe (TCvSubst, Type)
literalType :: Literal -> Ghc Type

module Language.Haskell.Tools.Refactor.Utils.TypeLookup
type ClosedTyFam = CoAxiom Branched
hasConstraintKind :: Type -> Bool

-- | Looks up the Type of an entity with an Id of any locality. If the
--   entity being scrutinised is a type variable, it fails.
lookupTypeFromId :: (HasIdInfo' id, GhcMonad m) => id -> MaybeT m Type

-- | Looks up the Type or the Kind of an entity that has an Id. Note: In
--   some cases we only get the Kind of the Id (e.g. for type constructors)
typeOrKindFromId :: HasIdInfo' id => id -> Type

-- | Extracts a Type from a TyThing when possible.
typeFromTyThing :: TyThing -> Maybe Type

-- | Looks up a GHC Type from a Haskell Tools Name (given the name is
--   global) For an identifier, it returns its type. For a data
--   constructor, it returns its type. For a pattern synonym, it returns
--   its builder's type. For a type synonym constructor, it returns its
--   right-hand side. For a coaxiom, it fails.
lookupTypeFromGlobalName :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Name corresponding to a type synonym
lookupTypeSynRhs :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type
lookupSynDef :: TyThing -> Maybe TyCon
tyconFromTyThing :: TyThing -> Maybe TyCon
tyconFromGHCType :: Type -> Maybe TyCon
isNewtype :: GhcMonad m => Type -> m Bool
lookupType :: GhcMonad m => Type -> MaybeT m TyThing

-- | Looks up a GHC.Class from something that has a type class constructor
--   in it Fails if the argument does not contain a class type constructor
lookupClassWith :: GhcMonad m => (a -> MaybeT m Name) -> a -> MaybeT m Class
lookupClass :: (GhcMonad m, HasNameInfo' n) => n -> MaybeT m Class
lookupClassFromInstance :: GhcMonad m => InstanceHead -> MaybeT m Class
lookupClassFromDeclHead :: GhcMonad m => DeclHead -> MaybeT m Class

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Type corresponding to a type synonym
semanticsTypeSynRhs :: GhcMonad m => Type -> MaybeT m Type

-- | Converts a global Haskell Tools type to a GHC type
semanticsType :: GhcMonad m => Type -> MaybeT m Type
isNewtypeTyCon :: TyThing -> Bool

-- | Looks up the given name, extracts something out of it. If the
--   extraction is not succesful, it returns False, if it is successful,
--   then checks the result against the predicate. The reasoning behind
--   this, is that the predicate can only be satisfied by a proper name.
satisfies :: (HasNameInfo' n, GhcMonad m) => (TyThing -> Maybe a) -> (a -> Bool) -> n -> MaybeT m Bool

-- | Decides whether a given name is a type family constructor. Fails if
--   the lookup is not successful.
isClassTyConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Decides whether a given name is a standard Haskell98 data constructor.
--   Fails if the lookup is not successful.
isVanillaDataConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Looks up a closed type family from a name.
lookupClosedTyFam :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m ClosedTyFam

-- | Extract the CoAxioms from a TyThing representing a closed type family.
coAxiomFromTyThing :: TyThing -> Maybe (CoAxiom Branched)

-- | Determines whether a Type itself has a type variable head.
hasTyVarHead :: Type -> Bool
instance GHC.Classes.Eq TyCoRep.Type


-- | Defines the API for refactorings
module Language.Haskell.Tools.Refactor

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: () => b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: () => Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: () => Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: () => [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: () => [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: () => (a -> Maybe b) -> [a] -> [b]

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: () => String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: () => String -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: () => String -> a -> a

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <tt>MonadIO</tt>, <tt>liftIO . traceIO</tt> may be a
--   better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   "hello
--   hello"
--   </pre>
traceId :: String -> String

putTraceMsg :: String -> IO ()

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: () => Maybe a -> a

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT a
[runMaybeT] :: MaybeT a -> m (Maybe a)
inScope :: Name -> Scope -> Bool

-- | Compares two source spans based on their lengths. Can only used for
--   NESTED spans.
compareRangeLength :: SrcSpan -> SrcSpan -> Ordering

-- | Get the shortest source range that contains the given
getNodeContaining :: (Biplate (Ann node dom stage) (Ann inner dom stage), SourceInfo stage, HasRange (Ann inner dom stage)) => RealSrcSpan -> Ann node dom stage -> Maybe (Ann inner dom stage)

-- | Get the nodes that have exactly the given range
nodesWithRange :: (Biplate (Ann node dom stage) (Ann inner dom stage), SourceInfo stage) => RealSrcSpan -> Simple Traversal (Ann node dom stage) (Ann inner dom stage)

-- | Return true if the node contains a given range
isContained :: HasRange (inner dom stage) => RealSrcSpan -> inner dom stage -> Bool

-- | Get all nodes that are contained in a given source range
nodesContained :: (HasRange (inner dom stage), Biplate (node dom stage) (inner dom stage)) => RealSrcSpan -> Simple Traversal (node dom stage) (inner dom stage)

-- | Return true if the node contains a given range
isInside :: HasRange (inner dom stage) => RealSrcSpan -> inner dom stage -> Bool

-- | Get all nodes that contain a given source range
nodesContaining :: (HasRange (inner dom stage), Biplate (node dom stage) (inner dom stage)) => RealSrcSpan -> Simple Traversal (node dom stage) (inner dom stage)

-- | Access the semantic information of an AST node.
semantics :: () => Simple Lens (Ann elem dom stage) (SemanticInfo dom elem)
valBindPats :: () => Simple Traversal (Ann UValueBind dom stage) (Ann UPattern dom stage)

-- | A reference to access type arguments to a type constructor call that
--   may be universally qualified or parenthesized.
typeParams :: () => Simple Traversal (Ann UType dom stage) (Ann UType dom stage)

-- | Accesses that name of a declaration through the declaration head.
declHeadNames :: () => Simple Traversal (Ann UDeclHead dom stage) (Ann UQualifiedName dom stage)

-- | Accesses the name of a function or value binding
bindingName :: () => Simple Traversal (Ann UValueBind dom stage) (Ann UQualifiedName dom stage)

-- | Does the import declaration import all elements that are not excluded
--   explicitly?
importIsHiding :: () => Ann UImportDecl dom stage -> Bool

-- | Does the import declaration import only the explicitly listed
--   elements?
importIsExact :: () => Ann UImportDecl dom stage -> Bool
pattern AnnList :: forall (elem :: Type -> Type -> Type) dom stage. () => () => [Ann elem dom stage] -> AnnListG elem dom stage
pattern AnnNothing :: forall (elem :: Type -> Type -> Type) dom stage. () => () => AnnMaybeG elem dom stage
pattern AnnJust :: forall (elem :: Type -> Type -> Type) dom stage. () => () => Ann elem dom stage -> AnnMaybeG elem dom stage

-- | A class to access the names of named elements. Have to locate where
--   does the AST element store its name. The returned name will be the one
--   that was marked isDefining.
class NamedElement (elem :: Type -> Type -> Type)
elementName :: NamedElement elem => Simple Traversal (Ann elem dom st) (Ann UQualifiedName dom st)
stringNodeStr :: () => Lens (Ann UStringNode dom stage) (Ann UStringNode dom stage) String String
simpleNameStr :: () => Lens (Ann UNamePart dom stage) (Ann UNamePart dom stage) String String
unqualifiedName :: () => Lens (Ann UQualifiedName dom stage) (Ann UQualifiedName dom stage) (Ann UNamePart dom stage) (Ann UNamePart dom stage)
qualifiers :: () => Lens (Ann UQualifiedName dom stage) (Ann UQualifiedName dom stage) (AnnListG UNamePart dom stage) (AnnListG UNamePart dom stage)
simpleName :: () => Lens (Ann UName dom stage) (Ann UName dom stage) (Ann UQualifiedName dom stage) (Ann UQualifiedName dom stage)
operatorName :: () => Lens (Ann UOperator dom stage) (Ann UOperator dom stage) (Ann UQualifiedName dom stage) (Ann UQualifiedName dom stage)
promotedStringValue :: () => Partial (Ann (UPromoted t) dom stage) (Ann (UPromoted t) dom stage) String String
promotedIntValue :: () => Partial (Ann (UPromoted t) dom stage) (Ann (UPromoted t) dom stage) Integer Integer
promotedElements :: () => Partial (Ann (UPromoted t) dom stage) (Ann (UPromoted t) dom stage) (AnnListG t dom stage) (AnnListG t dom stage)
promotedConName :: () => Partial (Ann (UPromoted t) dom stage) (Ann (UPromoted t) dom stage) (Ann UName dom stage) (Ann UName dom stage)
stringLitValue :: () => Partial (Ann ULiteral dom stage) (Ann ULiteral dom stage) String String
intLitValue :: () => Partial (Ann ULiteral dom stage) (Ann ULiteral dom stage) Integer Integer
fracLitValue :: () => Partial (Ann ULiteral dom stage) (Ann ULiteral dom stage) Rational Rational
floatLitValue :: () => Partial (Ann ULiteral dom stage) (Ann ULiteral dom stage) Rational Rational
charLitValue :: () => Partial (Ann ULiteral dom stage) (Ann ULiteral dom stage) Char Char
bracketType :: () => Partial (Ann UBracket dom stage) (Ann UBracket dom stage) (Ann UType dom stage) (Ann UType dom stage)
bracketPattern :: () => Partial (Ann UBracket dom stage) (Ann UBracket dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
bracketExpr :: () => Partial (Ann UBracket dom stage) (Ann UBracket dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
bracketDecl :: () => Partial (Ann UBracket dom stage) (Ann UBracket dom stage) (AnnListG UDecl dom stage) (AnnListG UDecl dom stage)
qqString :: () => Lens (Ann QQString dom stage) (Ann QQString dom stage) String String
qqExprName :: () => Lens (Ann UQuasiQuote dom stage) (Ann UQuasiQuote dom stage) (Ann UName dom stage) (Ann UName dom stage)
qqExprBody :: () => Lens (Ann UQuasiQuote dom stage) (Ann UQuasiQuote dom stage) (Ann QQString dom stage) (Ann QQString dom stage)
spliceId :: () => Partial (Ann USplice dom stage) (Ann USplice dom stage) (Ann UName dom stage) (Ann UName dom stage)
spliceExpr :: () => Partial (Ann USplice dom stage) (Ann USplice dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
fieldPatternWildcard :: () => Partial (Ann UPatternField dom stage) (Ann UPatternField dom stage) (Ann UFieldWildcard dom stage) (Ann UFieldWildcard dom stage)
fieldPatternName :: () => Partial (Ann UPatternField dom stage) (Ann UPatternField dom stage) (Ann UName dom stage) (Ann UName dom stage)
fieldPattern :: () => Partial (Ann UPatternField dom stage) (Ann UPatternField dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
patternType :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UType dom stage) (Ann UType dom stage)
patternSumPlaceholdersBefore :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage)
patternSumPlaceholdersAfter :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage)
patternSplice :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann USplice dom stage) (Ann USplice dom stage)
patternRhs :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
patternOperator :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
patternName :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UName dom stage) (Ann UName dom stage)
patternLiteral :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann ULiteral dom stage) (Ann ULiteral dom stage)
patternLit :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann ULiteral dom stage) (Ann ULiteral dom stage)
patternLhs :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
patternInner :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
patternFields :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (AnnListG UPatternField dom stage) (AnnListG UPatternField dom stage)
patternExpr :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
patternElems :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (AnnListG UPattern dom stage) (AnnListG UPattern dom stage)
patternArgs :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (AnnListG UPattern dom stage) (AnnListG UPattern dom stage)
patQQ :: () => Partial (Ann UPattern dom stage) (Ann UPattern dom stage) (Ann UQuasiQuote dom stage) (Ann UQuasiQuote dom stage)
cmdThen :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
cmdStmts :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (AnnListG UCmdStmt dom stage) (AnnListG UCmdStmt dom stage)
cmdRightCmd :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
cmdRhs :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
cmdOperator :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UName dom stage) (Ann UName dom stage)
cmdLhs :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
cmdLeftCmd :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
cmdInnerCmds :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (AnnListG UCmd dom stage) (AnnListG UCmd dom stage)
cmdInnerCmd :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
cmdInner :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
cmdExpr :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
cmdElse :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
cmdBinds :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (AnnListG ULocalBind dom stage) (AnnListG ULocalBind dom stage)
cmdBindings :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (AnnListG UPattern dom stage) (AnnListG UPattern dom stage)
cmdArrowOp :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UArrowAppl dom stage) (Ann UArrowAppl dom stage)
cmdApplied :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
cmdAlts :: () => Partial (Ann UCmd dom stage) (Ann UCmd dom stage) (AnnListG UCmdAlt dom stage) (AnnListG UCmdAlt dom stage)
compStmts :: () => Lens (Ann UListCompBody dom stage) (Ann UListCompBody dom stage) (AnnListG UCompStmt dom stage) (AnnListG UCompStmt dom stage)
usingExpr :: () => Partial (Ann UCompStmt dom stage) (Ann UCompStmt dom stage) (AnnMaybeG UExpr dom stage) (AnnMaybeG UExpr dom stage)
thenExpr :: () => Partial (Ann UCompStmt dom stage) (Ann UCompStmt dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
compStmt :: () => Partial (Ann UCompStmt dom stage) (Ann UCompStmt dom stage) (Ann UStmt dom stage) (Ann UStmt dom stage)
byExpr :: () => Partial (Ann UCompStmt dom stage) (Ann UCompStmt dom stage) (AnnMaybeG UExpr dom stage) (AnnMaybeG UExpr dom stage)
stmtPattern :: () => Partial (Ann (UStmt' expr) dom stage) (Ann (UStmt' expr) dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
stmtExpr :: () => Partial (Ann (UStmt' expr) dom stage) (Ann (UStmt' expr) dom stage) (Ann expr dom stage) (Ann expr dom stage)
stmtBinds :: () => Partial (Ann (UStmt' expr) dom stage) (Ann (UStmt' expr) dom stage) (AnnListG ULocalBind dom stage) (AnnListG ULocalBind dom stage)
cmdStmtBinds :: () => Partial (Ann (UStmt' expr) dom stage) (Ann (UStmt' expr) dom stage) (AnnListG (UStmt' expr) dom stage) (AnnListG (UStmt' expr) dom stage)
caseGuardStmts :: () => Lens (Ann (UGuardedCaseRhs' expr) dom stage) (Ann (UGuardedCaseRhs' expr) dom stage) (AnnListG URhsGuard dom stage) (AnnListG URhsGuard dom stage)
caseGuardExpr :: () => Lens (Ann (UGuardedCaseRhs' expr) dom stage) (Ann (UGuardedCaseRhs' expr) dom stage) (Ann expr dom stage) (Ann expr dom stage)
rhsCaseGuards :: () => Partial (Ann (UCaseRhs' expr) dom stage) (Ann (UCaseRhs' expr) dom stage) (AnnListG (UGuardedCaseRhs' expr) dom stage) (AnnListG (UGuardedCaseRhs' expr) dom stage)
rhsCaseExpr :: () => Partial (Ann (UCaseRhs' expr) dom stage) (Ann (UCaseRhs' expr) dom stage) (Ann expr dom stage) (Ann expr dom stage)
pragmaStr :: () => Partial (Ann UExprPragma dom stage) (Ann UExprPragma dom stage) (Ann UStringNode dom stage) (Ann UStringNode dom stage)
pragmaSrcRange :: () => Partial (Ann UExprPragma dom stage) (Ann UExprPragma dom stage) (Ann USourceRange dom stage) (Ann USourceRange dom stage)
tupSecExpr :: () => Partial (Ann UTupSecElem dom stage) (Ann UTupSecElem dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
fieldWildcard :: () => Partial (Ann UFieldUpdate dom stage) (Ann UFieldUpdate dom stage) (Ann UFieldWildcard dom stage) (Ann UFieldWildcard dom stage)
fieldValue :: () => Partial (Ann UFieldUpdate dom stage) (Ann UFieldUpdate dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
fieldUpdateName :: () => Partial (Ann UFieldUpdate dom stage) (Ann UFieldUpdate dom stage) (Ann UName dom stage) (Ann UName dom stage)
fieldName :: () => Partial (Ann UFieldUpdate dom stage) (Ann UFieldUpdate dom stage) (Ann UName dom stage) (Ann UName dom stage)
altRhs :: () => Lens (Ann (UAlt' expr) dom stage) (Ann (UAlt' expr) dom stage) (Ann (UCaseRhs' expr) dom stage) (Ann (UCaseRhs' expr) dom stage)
altPattern :: () => Lens (Ann (UAlt' expr) dom stage) (Ann (UAlt' expr) dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
altBinds :: () => Lens (Ann (UAlt' expr) dom stage) (Ann (UAlt' expr) dom stage) (AnnMaybeG ULocalBinds dom stage) (AnnMaybeG ULocalBinds dom stage)
tupleSectionElems :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UTupSecElem dom stage) (AnnListG UTupSecElem dom stage)
tupleElems :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UExpr dom stage) (AnnListG UExpr dom stage)
quotedName :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UName dom stage) (Ann UName dom stage)
procPattern :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
procExpr :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UCmd dom stage) (Ann UCmd dom stage)
listElems :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UExpr dom stage) (AnnListG UExpr dom stage)
innerExpr :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprType :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UType dom stage) (Ann UType dom stage)
exprThen :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprSumPlaceholdersBefore :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage)
exprSumPlaceholdersAfter :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage) (AnnListG UUnboxedSumPlaceHolder dom stage)
exprStmts :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UStmt dom stage) (AnnListG UStmt dom stage)
exprSplice :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann USplice dom stage) (Ann USplice dom stage)
exprSig :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UType dom stage) (Ann UType dom stage)
exprRhs :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprRecName :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UName dom stage) (Ann UName dom stage)
exprRecFields :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UFieldUpdate dom stage) (AnnListG UFieldUpdate dom stage)
exprQQ :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UQuasiQuote dom stage) (Ann UQuasiQuote dom stage)
exprPragma :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExprPragma dom stage) (Ann UExprPragma dom stage)
exprOperator :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
exprName :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UName dom stage) (Ann UName dom stage)
exprLit :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann ULiteral dom stage) (Ann ULiteral dom stage)
exprLhs :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprInner :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprIfAlts :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UGuardedCaseRhs dom stage) (AnnListG UGuardedCaseRhs dom stage)
exprFunBind :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG ULocalBind dom stage) (AnnListG ULocalBind dom stage)
exprFun :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprElse :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprCond :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprCase :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprBracket :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UBracket dom stage) (Ann UBracket dom stage)
exprBindings :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UPattern dom stage) (AnnListG UPattern dom stage)
exprArg :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
exprAlts :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UAlt dom stage) (AnnListG UAlt dom stage)
enumToFix :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
enumTo :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnMaybeG UExpr dom stage) (AnnMaybeG UExpr dom stage)
enumThen :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnMaybeG UExpr dom stage) (AnnMaybeG UExpr dom stage)
enumFrom :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
doKind :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UDoKind dom stage) (Ann UDoKind dom stage)
compExpr :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
compBody :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (AnnListG UListCompBody dom stage) (AnnListG UListCompBody dom stage)
arrowAppl :: () => Partial (Ann UExpr dom stage) (Ann UExpr dom stage) (Ann UArrowAppl dom stage) (Ann UArrowAppl dom stage)
innerAsserts :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (AnnListG UAssertion dom stage) (AnnListG UAssertion dom stage)
assertTypes :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (AnnListG UType dom stage) (AnnListG UType dom stage)
assertRhs :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (Ann UType dom stage) (Ann UType dom stage)
assertOp :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
assertLhs :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (Ann UType dom stage) (Ann UType dom stage)
assertImplVar :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (Ann UName dom stage) (Ann UName dom stage)
assertImplType :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (Ann UType dom stage) (Ann UType dom stage)
assertClsName :: () => Partial (Ann UAssertion dom stage) (Ann UAssertion dom stage) (Ann UName dom stage) (Ann UName dom stage)
contextAssertion :: () => Lens (Ann UContext dom stage) (Ann UContext dom stage) (Ann UAssertion dom stage) (Ann UAssertion dom stage)
kindVar :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UName dom stage) (Ann UName dom stage)
kindType :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UType dom stage) (Ann UType dom stage)
kindRight :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindRhs :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindPromoted :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann (UPromoted UKind) dom stage) (Ann (UPromoted UKind) dom stage)
kindParen :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindLhs :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindLeft :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindElems :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (AnnListG UKind dom stage) (AnnListG UKind dom stage)
kindElem :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindAppOp :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
kindAppFun :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
kindAppArg :: () => Partial (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
typeWildcardName :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UName dom stage) (Ann UName dom stage)
typeType :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeRight :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeResult :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeQQ :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UQuasiQuote dom stage) (Ann UQuasiQuote dom stage)
typeParam :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeOperator :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
typeName :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UName dom stage) (Ann UName dom stage)
typeLeft :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeKind :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
typeInner :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeElements :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (AnnListG UType dom stage) (AnnListG UType dom stage)
typeElement :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeCtx :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UContext dom stage) (Ann UContext dom stage)
typeCon :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
typeBounded :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (AnnListG UTyVar dom stage) (AnnListG UTyVar dom stage)
typeArg :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage) (Ann UType dom stage)
tsSplice :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann USplice dom stage) (Ann USplice dom stage)
tpPromoted :: () => Partial (Ann UType dom stage) (Ann UType dom stage) (Ann (UPromoted UType) dom stage) (Ann (UPromoted UType) dom stage)
tyVarName :: () => Lens (Ann UTyVar dom stage) (Ann UTyVar dom stage) (Ann UName dom stage) (Ann UName dom stage)
tyVarKind :: () => Lens (Ann UTyVar dom stage) (Ann UTyVar dom stage) (AnnMaybeG UKindConstraint dom stage) (AnnMaybeG UKindConstraint dom stage)
valBindRhs :: () => Partial (Ann UValueBind dom stage) (Ann UValueBind dom stage) (Ann URhs dom stage) (Ann URhs dom stage)
valBindPat :: () => Partial (Ann UValueBind dom stage) (Ann UValueBind dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
valBindLocals :: () => Partial (Ann UValueBind dom stage) (Ann UValueBind dom stage) (AnnMaybeG ULocalBinds dom stage) (AnnMaybeG ULocalBinds dom stage)
funBindMatches :: () => Partial (Ann UValueBind dom stage) (Ann UValueBind dom stage) (AnnListG UMatch dom stage) (AnnListG UMatch dom stage)
kindConstr :: () => Lens (Ann UKindConstraint dom stage) (Ann UKindConstraint dom stage) (Ann UKind dom stage) (Ann UKind dom stage)
matchLhsRhs :: () => Partial (Ann UMatchLhs dom stage) (Ann UMatchLhs dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
matchLhsOperator :: () => Partial (Ann UMatchLhs dom stage) (Ann UMatchLhs dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
matchLhsName :: () => Partial (Ann UMatchLhs dom stage) (Ann UMatchLhs dom stage) (Ann UName dom stage) (Ann UName dom stage)
matchLhsLhs :: () => Partial (Ann UMatchLhs dom stage) (Ann UMatchLhs dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
matchLhsArgs :: () => Lens (Ann UMatchLhs dom stage) (Ann UMatchLhs dom stage) (AnnListG UPattern dom stage) (AnnListG UPattern dom stage)
tsType :: () => Lens (Ann UTypeSignature dom stage) (Ann UTypeSignature dom stage) (Ann UType dom stage) (Ann UType dom stage)
tsName :: () => Lens (Ann UTypeSignature dom stage) (Ann UTypeSignature dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
precedenceValue :: () => Lens (Ann Precedence dom stage) (Ann Precedence dom stage) Int Int
fixityPrecedence :: () => Lens (Ann UFixitySignature dom stage) (Ann UFixitySignature dom stage) (AnnMaybeG Precedence dom stage) (AnnMaybeG Precedence dom stage)
fixityOperators :: () => Lens (Ann UFixitySignature dom stage) (Ann UFixitySignature dom stage) (AnnListG UOperator dom stage) (AnnListG UOperator dom stage)
fixityAssoc :: () => Lens (Ann UFixitySignature dom stage) (Ann UFixitySignature dom stage) (Ann Assoc dom stage) (Ann Assoc dom stage)
localBinds :: () => Lens (Ann ULocalBinds dom stage) (Ann ULocalBinds dom stage) (AnnListG ULocalBind dom stage) (AnnListG ULocalBind dom stage)
localVal :: () => Partial (Ann ULocalBind dom stage) (Ann ULocalBind dom stage) (Ann UValueBind dom stage) (Ann UValueBind dom stage)
localSig :: () => Partial (Ann ULocalBind dom stage) (Ann ULocalBind dom stage) (Ann UTypeSignature dom stage) (Ann UTypeSignature dom stage)
localInline :: () => Partial (Ann ULocalBind dom stage) (Ann ULocalBind dom stage) (Ann UInlinePragma dom stage) (Ann UInlinePragma dom stage)
localFixity :: () => Partial (Ann ULocalBind dom stage) (Ann ULocalBind dom stage) (Ann UFixitySignature dom stage) (Ann UFixitySignature dom stage)
guardRhs :: () => Partial (Ann URhsGuard dom stage) (Ann URhsGuard dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
guardPat :: () => Partial (Ann URhsGuard dom stage) (Ann URhsGuard dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
guardCheck :: () => Partial (Ann URhsGuard dom stage) (Ann URhsGuard dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
guardBinds :: () => Partial (Ann URhsGuard dom stage) (Ann URhsGuard dom stage) (AnnListG ULocalBind dom stage) (AnnListG ULocalBind dom stage)
guardStmts :: () => Lens (Ann UGuardedRhs dom stage) (Ann UGuardedRhs dom stage) (AnnListG URhsGuard dom stage) (AnnListG URhsGuard dom stage)
guardExpr :: () => Lens (Ann UGuardedRhs dom stage) (Ann UGuardedRhs dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
rhsGuards :: () => Partial (Ann URhs dom stage) (Ann URhs dom stage) (AnnListG UGuardedRhs dom stage) (AnnListG UGuardedRhs dom stage)
rhsExpr :: () => Partial (Ann URhs dom stage) (Ann URhs dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
matchRhs :: () => Lens (Ann UMatch dom stage) (Ann UMatch dom stage) (Ann URhs dom stage) (Ann URhs dom stage)
matchLhs :: () => Lens (Ann UMatch dom stage) (Ann UMatch dom stage) (Ann UMatchLhs dom stage) (Ann UMatchLhs dom stage)
matchBinds :: () => Lens (Ann UMatch dom stage) (Ann UMatch dom stage) (AnnMaybeG ULocalBinds dom stage) (AnnMaybeG ULocalBinds dom stage)
specializeType :: () => Lens (Ann USpecializePragma dom stage) (Ann USpecializePragma dom stage) (AnnListG UType dom stage) (AnnListG UType dom stage)
specializeDef :: () => Lens (Ann USpecializePragma dom stage) (Ann USpecializePragma dom stage) (Ann UName dom stage) (Ann UName dom stage)
pragmaPhase :: () => Lens (Ann USpecializePragma dom stage) (Ann USpecializePragma dom stage) (AnnMaybeG UPhaseControl dom stage) (AnnMaybeG UPhaseControl dom stage)
numberInteger :: () => Lens (Ann Number dom stage) (Ann Number dom stage) Integer Integer
srToLine :: () => Lens (Ann USourceRange dom stage) (Ann USourceRange dom stage) (Ann Number dom stage) (Ann Number dom stage)
srToCol :: () => Lens (Ann USourceRange dom stage) (Ann USourceRange dom stage) (Ann Number dom stage) (Ann Number dom stage)
srFromLine :: () => Lens (Ann USourceRange dom stage) (Ann USourceRange dom stage) (Ann Number dom stage) (Ann Number dom stage)
srFromCol :: () => Lens (Ann USourceRange dom stage) (Ann USourceRange dom stage) (Ann Number dom stage) (Ann Number dom stage)
srFileName :: () => Lens (Ann USourceRange dom stage) (Ann USourceRange dom stage) (Ann UStringNode dom stage) (Ann UStringNode dom stage)
minimalOrs :: () => Partial (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage) (AnnListG UMinimalFormula dom stage) (AnnListG UMinimalFormula dom stage)
minimalName :: () => Partial (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage) (Ann UName dom stage) (Ann UName dom stage)
minimalInner :: () => Partial (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage)
minimalAnds :: () => Partial (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage) (AnnListG UMinimalFormula dom stage) (AnnListG UMinimalFormula dom stage)
annotateName :: () => Partial (Ann UAnnotationSubject dom stage) (Ann UAnnotationSubject dom stage) (Ann UName dom stage) (Ann UName dom stage)
warnMessage :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (AnnListG UStringNode dom stage) (AnnListG UStringNode dom stage)
specializePragma :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (Ann USpecializePragma dom stage) (Ann USpecializePragma dom stage)
pragmaSignature :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (AnnMaybeG UName dom stage) (AnnMaybeG UName dom stage)
pragmaRule :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (AnnListG URule dom stage) (AnnListG URule dom stage)
pragmaObjects :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
pragmaLineNum :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (Ann LineNumber dom stage) (Ann LineNumber dom stage)
pragmaInline :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (Ann UInlinePragma dom stage) (Ann UInlinePragma dom stage)
pragmaFileName :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (AnnMaybeG UStringNode dom stage) (AnnMaybeG UStringNode dom stage)
deprMessage :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (AnnListG UStringNode dom stage) (AnnListG UStringNode dom stage)
annotationSubject :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (Ann UAnnotationSubject dom stage) (Ann UAnnotationSubject dom stage)
annotateExpr :: () => Partial (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
phaseNum :: () => Lens (Ann PhaseNumber dom stage) (Ann PhaseNumber dom stage) Integer Integer
phaseUntil :: () => Lens (Ann UPhaseControl dom stage) (Ann UPhaseControl dom stage) (AnnMaybeG PhaseInvert dom stage) (AnnMaybeG PhaseInvert dom stage)
phaseNumber :: () => Lens (Ann UPhaseControl dom stage) (Ann UPhaseControl dom stage) (AnnMaybeG PhaseNumber dom stage) (AnnMaybeG PhaseNumber dom stage)
ruleVarType :: () => Partial (Ann URuleVar dom stage) (Ann URuleVar dom stage) (Ann UType dom stage) (Ann UType dom stage)
ruleVarName :: () => Lens (Ann URuleVar dom stage) (Ann URuleVar dom stage) (Ann UName dom stage) (Ann UName dom stage)
ruleRhs :: () => Lens (Ann URule dom stage) (Ann URule dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
rulePhase :: () => Lens (Ann URule dom stage) (Ann URule dom stage) (AnnMaybeG UPhaseControl dom stage) (AnnMaybeG UPhaseControl dom stage)
ruleName :: () => Lens (Ann URule dom stage) (Ann URule dom stage) (Ann UStringNode dom stage) (Ann UStringNode dom stage)
ruleLhs :: () => Lens (Ann URule dom stage) (Ann URule dom stage) (Ann UExpr dom stage) (Ann UExpr dom stage)
ruleBounded :: () => Lens (Ann URule dom stage) (Ann URule dom stage) (AnnListG URuleVar dom stage) (AnnListG URuleVar dom stage)
teRhs :: () => Lens (Ann UTypeEqn dom stage) (Ann UTypeEqn dom stage) (Ann UType dom stage) (Ann UType dom stage)
teLhs :: () => Lens (Ann UTypeEqn dom stage) (Ann UTypeEqn dom stage) (Ann UType dom stage) (Ann UType dom stage)
ihType :: () => Partial (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UType dom stage) (Ann UType dom stage)
ihOperator :: () => Partial (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
ihLeftOp :: () => Partial (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UType dom stage) (Ann UType dom stage)
ihHead :: () => Partial (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage)
ihFun :: () => Partial (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage)
ihConName :: () => Partial (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage) (Ann UName dom stage) (Ann UName dom stage)
irVars :: () => Lens (Ann UInstanceRule dom stage) (Ann UInstanceRule dom stage) (AnnMaybeG (AnnListG UTyVar) dom stage) (AnnMaybeG (AnnListG UTyVar) dom stage)
irHead :: () => Lens (Ann UInstanceRule dom stage) (Ann UInstanceRule dom stage) (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage)
irCtx :: () => Lens (Ann UInstanceRule dom stage) (Ann UInstanceRule dom stage) (AnnMaybeG UContext dom stage) (AnnMaybeG UContext dom stage)
oneDerived :: () => Partial (Ann UDeriving dom stage) (Ann UDeriving dom stage) (Ann UInstanceHead dom stage) (Ann UInstanceHead dom stage)
allDerived :: () => Partial (Ann UDeriving dom stage) (Ann UDeriving dom stage) (AnnListG UInstanceHead dom stage) (AnnListG UInstanceHead dom stage)
deriveStrategy :: () => Lens (Ann UDeriving dom stage) (Ann UDeriving dom stage) (AnnMaybeG UDeriveStrategy dom stage) (AnnMaybeG UDeriveStrategy dom stage)
fieldType :: () => Lens (Ann UFieldDecl dom stage) (Ann UFieldDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
fieldNames :: () => Lens (Ann UFieldDecl dom stage) (Ann UFieldDecl dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
conDeclRhs :: () => Partial (Ann UConDecl dom stage) (Ann UConDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
conDeclOp :: () => Partial (Ann UConDecl dom stage) (Ann UConDecl dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
conDeclName :: () => Partial (Ann UConDecl dom stage) (Ann UConDecl dom stage) (Ann UName dom stage) (Ann UName dom stage)
conDeclLhs :: () => Partial (Ann UConDecl dom stage) (Ann UConDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
conDeclFields :: () => Partial (Ann UConDecl dom stage) (Ann UConDecl dom stage) (AnnListG UFieldDecl dom stage) (AnnListG UFieldDecl dom stage)
conDeclArgs :: () => Partial (Ann UConDecl dom stage) (Ann UConDecl dom stage) (AnnListG UType dom stage) (AnnListG UType dom stage)
conTypeCtx :: () => Lens (Ann UConDecl dom stage) (Ann UConDecl dom stage) (AnnMaybeG UContext dom stage) (AnnMaybeG UContext dom stage)
conTypeArgs :: () => Lens (Ann UConDecl dom stage) (Ann UConDecl dom stage) (AnnListG UTyVar dom stage) (AnnListG UTyVar dom stage)
funDepRhs :: () => Lens (Ann UFunDep dom stage) (Ann UFunDep dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
funDepLhs :: () => Lens (Ann UFunDep dom stage) (Ann UFunDep dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
funDeps :: () => Lens (Ann UFunDeps dom stage) (Ann UFunDeps dom stage) (AnnListG UFunDep dom stage) (AnnListG UFunDep dom stage)
patSigType :: () => Lens (Ann UPatternTypeSignature dom stage) (Ann UPatternTypeSignature dom stage) (Ann UType dom stage) (Ann UType dom stage)
patSigName :: () => Lens (Ann UPatternTypeSignature dom stage) (Ann UPatternTypeSignature dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
patOpposite :: () => Lens (Ann UPatSynWhere dom stage) (Ann UPatSynWhere dom stage) (AnnListG UMatch dom stage) (AnnListG UMatch dom stage)
patSynRhs :: () => Partial (Ann UPatSynLhs dom stage) (Ann UPatSynLhs dom stage) (Ann UName dom stage) (Ann UName dom stage)
patSynOp :: () => Partial (Ann UPatSynLhs dom stage) (Ann UPatSynLhs dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
patSynLhs :: () => Partial (Ann UPatSynLhs dom stage) (Ann UPatSynLhs dom stage) (Ann UName dom stage) (Ann UName dom stage)
patName :: () => Partial (Ann UPatSynLhs dom stage) (Ann UPatSynLhs dom stage) (Ann UName dom stage) (Ann UName dom stage)
patArgs :: () => Partial (Ann UPatSynLhs dom stage) (Ann UPatSynLhs dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
patRhsOpposite :: () => Partial (Ann UPatSynRhs dom stage) (Ann UPatSynRhs dom stage) (AnnMaybeG UPatSynWhere dom stage) (AnnMaybeG UPatSynWhere dom stage)
patRhsPat :: () => Lens (Ann UPatSynRhs dom stage) (Ann UPatSynRhs dom stage) (Ann UPattern dom stage) (Ann UPattern dom stage)
patRhs :: () => Lens (Ann UPatternSynonym dom stage) (Ann UPatternSynonym dom stage) (Ann UPatSynRhs dom stage) (Ann UPatSynRhs dom stage)
patLhs :: () => Lens (Ann UPatternSynonym dom stage) (Ann UPatternSynonym dom stage) (Ann UPatSynLhs dom stage) (Ann UPatSynLhs dom stage)
gadtConResultType :: () => Partial (Ann UGadtConType dom stage) (Ann UGadtConType dom stage) (Ann UType dom stage) (Ann UType dom stage)
gadtConRecordFields :: () => Partial (Ann UGadtConType dom stage) (Ann UGadtConType dom stage) (AnnListG UFieldDecl dom stage) (AnnListG UFieldDecl dom stage)
gadtConNormalType :: () => Partial (Ann UGadtConType dom stage) (Ann UGadtConType dom stage) (Ann UType dom stage) (Ann UType dom stage)
gadtConTypeCtx :: () => Lens (Ann UGadtConDecl dom stage) (Ann UGadtConDecl dom stage) (AnnMaybeG UContext dom stage) (AnnMaybeG UContext dom stage)
gadtConTypeArgs :: () => Lens (Ann UGadtConDecl dom stage) (Ann UGadtConDecl dom stage) (AnnListG UTyVar dom stage) (AnnListG UTyVar dom stage)
gadtConType :: () => Lens (Ann UGadtConDecl dom stage) (Ann UGadtConDecl dom stage) (Ann UGadtConType dom stage) (Ann UGadtConType dom stage)
gadtConNames :: () => Lens (Ann UGadtConDecl dom stage) (Ann UGadtConDecl dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
injAnnRes :: () => Lens (Ann UInjectivityAnn dom stage) (Ann UInjectivityAnn dom stage) (Ann UTyVar dom stage) (Ann UTyVar dom stage)
injAnnDeps :: () => Lens (Ann UInjectivityAnn dom stage) (Ann UInjectivityAnn dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
tfTypeVar :: () => Partial (Ann UTypeFamilySpec dom stage) (Ann UTypeFamilySpec dom stage) (Ann UTyVar dom stage) (Ann UTyVar dom stage)
tfSpecKind :: () => Partial (Ann UTypeFamilySpec dom stage) (Ann UTypeFamilySpec dom stage) (Ann UKindConstraint dom stage) (Ann UKindConstraint dom stage)
tfInjectivity :: () => Partial (Ann UTypeFamilySpec dom stage) (Ann UTypeFamilySpec dom stage) (Ann UInjectivityAnn dom stage) (Ann UInjectivityAnn dom stage)
tfSpec :: () => Partial (Ann UTypeFamily dom stage) (Ann UTypeFamily dom stage) (AnnMaybeG UTypeFamilySpec dom stage) (AnnMaybeG UTypeFamilySpec dom stage)
tfKind :: () => Partial (Ann UTypeFamily dom stage) (Ann UTypeFamily dom stage) (AnnMaybeG UKindConstraint dom stage) (AnnMaybeG UKindConstraint dom stage)
tfHead :: () => Lens (Ann UTypeFamily dom stage) (Ann UTypeFamily dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage)
specializeInstanceType :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
specializeInstance :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann USpecializePragma dom stage) (Ann USpecializePragma dom stage)
instanceInline :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UInlinePragma dom stage) (Ann UInlinePragma dom stage)
instBodyTypeSig :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UTypeSignature dom stage) (Ann UTypeSignature dom stage)
instBodyTypeEqn :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UTypeEqn dom stage) (Ann UTypeEqn dom stage)
instBodyLhsType :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UInstanceRule dom stage) (Ann UInstanceRule dom stage)
instBodyGadtCons :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (AnnListG UGadtConDecl dom stage) (AnnListG UGadtConDecl dom stage)
instBodyDerivings :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (AnnListG UDeriving dom stage) (AnnListG UDeriving dom stage)
instBodyDeclFunbind :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UValueBind dom stage) (Ann UValueBind dom stage)
instBodyDataNew :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (Ann UDataOrNewtypeKeyword dom stage) (Ann UDataOrNewtypeKeyword dom stage)
instBodyDataKind :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (AnnMaybeG UKindConstraint dom stage) (AnnMaybeG UKindConstraint dom stage)
instBodyDataCons :: () => Partial (Ann UInstBodyDecl dom stage) (Ann UInstBodyDecl dom stage) (AnnListG UConDecl dom stage) (AnnListG UConDecl dom stage)
instBodyDecls :: () => Lens (Ann UInstBody dom stage) (Ann UInstBody dom stage) (AnnListG UInstBodyDecl dom stage) (AnnListG UInstBodyDecl dom stage)
dhRight :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UTyVar dom stage) (Ann UTyVar dom stage)
dhOperator :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UOperator dom stage) (Ann UOperator dom stage)
dhName :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UName dom stage) (Ann UName dom stage)
dhLeft :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UTyVar dom stage) (Ann UTyVar dom stage)
dhBody :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage)
dhAppOperand :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UTyVar dom stage) (Ann UTyVar dom stage)
dhAppFun :: () => Partial (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage)
pragmaFormula :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UMinimalFormula dom stage) (Ann UMinimalFormula dom stage)
clsInline :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UInlinePragma dom stage) (Ann UInlinePragma dom stage)
clsFixity :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UFixitySignature dom stage) (Ann UFixitySignature dom stage)
ceTypeSig :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UTypeSignature dom stage) (Ann UTypeSignature dom stage)
ceTypeFam :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UTypeFamily dom stage) (Ann UTypeFamily dom stage)
ceType :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UType dom stage) (Ann UType dom stage)
ceName :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UName dom stage) (Ann UName dom stage)
ceKind :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UType dom stage) (Ann UType dom stage)
ceHead :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage)
ceBind :: () => Partial (Ann UClassElement dom stage) (Ann UClassElement dom stage) (Ann UValueBind dom stage) (Ann UValueBind dom stage)
cbElements :: () => Lens (Ann UClassBody dom stage) (Ann UClassBody dom stage) (AnnListG UClassElement dom stage) (AnnListG UClassElement dom stage)
declValBind :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UValueBind dom stage) (Ann UValueBind dom stage)
declTypes :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnListG UType dom stage) (AnnListG UType dom stage)
declTypeSig :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UTypeSignature dom stage) (Ann UTypeSignature dom stage)
declTypeFamily :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UTypeFamily dom stage) (Ann UTypeFamily dom stage)
declType :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
declSplice :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann USplice dom stage) (Ann USplice dom stage)
declSpec :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UTypeFamilySpec dom stage) (AnnMaybeG UTypeFamilySpec dom stage)
declSafety :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG USafety dom stage) (AnnMaybeG USafety dom stage)
declRoles :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnListG URole dom stage) (AnnListG URole dom stage)
declRoleType :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UQualifiedName dom stage) (Ann UQualifiedName dom stage)
declPragma :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UTopLevelPragma dom stage) (Ann UTopLevelPragma dom stage)
declPatTypeSig :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UPatternTypeSignature dom stage) (Ann UPatternTypeSignature dom stage)
declPatSyn :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UPatternSynonym dom stage) (Ann UPatternSynonym dom stage)
declOverlap :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UOverlapPragma dom stage) (AnnMaybeG UOverlapPragma dom stage)
declNewtype :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UDataOrNewtypeKeyword dom stage) (Ann UDataOrNewtypeKeyword dom stage)
declName :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UName dom stage) (Ann UName dom stage)
declKind :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UKindConstraint dom stage) (AnnMaybeG UKindConstraint dom stage)
declInstance :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UInstanceRule dom stage) (Ann UInstanceRule dom stage)
declInstRule :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UInstanceRule dom stage) (Ann UInstanceRule dom stage)
declInstDecl :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UInstBody dom stage) (AnnMaybeG UInstBody dom stage)
declHead :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UDeclHead dom stage) (Ann UDeclHead dom stage)
declGadt :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnListG UGadtConDecl dom stage) (AnnListG UGadtConDecl dom stage)
declFunDeps :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UFunDeps dom stage) (AnnMaybeG UFunDeps dom stage)
declForeignType :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
declFixity :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UFixitySignature dom stage) (Ann UFixitySignature dom stage)
declDeriving :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnListG UDeriving dom stage) (AnnListG UDeriving dom stage)
declDerivStrat :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UDeriveStrategy dom stage) (AnnMaybeG UDeriveStrategy dom stage)
declDecl :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnListG UTypeEqn dom stage) (AnnListG UTypeEqn dom stage)
declCtx :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UContext dom stage) (AnnMaybeG UContext dom stage)
declCons :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnListG UConDecl dom stage) (AnnListG UConDecl dom stage)
declCallConv :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UCallConv dom stage) (Ann UCallConv dom stage)
declBody :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (AnnMaybeG UClassBody dom stage) (AnnMaybeG UClassBody dom stage)
declAssignedType :: () => Partial (Ann UDecl dom stage) (Ann UDecl dom stage) (Ann UType dom stage) (Ann UType dom stage)
langExt :: () => Lens (Ann ULanguageExtension dom stage) (Ann ULanguageExtension dom stage) String String
moduleNameString :: () => Lens (Ann UModuleName dom stage) (Ann UModuleName dom stage) String String
importRename :: () => Lens (Ann UImportRenaming dom stage) (Ann UImportRenaming dom stage) (Ann UModuleName dom stage) (Ann UModuleName dom stage)
importSpecList :: () => Partial (Ann UImportSpec dom stage) (Ann UImportSpec dom stage) (AnnListG UIESpec dom stage) (AnnListG UIESpec dom stage)
importSpecHiding :: () => Partial (Ann UImportSpec dom stage) (Ann UImportSpec dom stage) (AnnListG UIESpec dom stage) (AnnListG UIESpec dom stage)
importSpec :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (AnnMaybeG UImportSpec dom stage) (AnnMaybeG UImportSpec dom stage)
importSource :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (AnnMaybeG UImportSource dom stage) (AnnMaybeG UImportSource dom stage)
importSafe :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (AnnMaybeG UImportSafe dom stage) (AnnMaybeG UImportSafe dom stage)
importQualified :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (AnnMaybeG UImportQualified dom stage) (AnnMaybeG UImportQualified dom stage)
importPkg :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (AnnMaybeG UStringNode dom stage) (AnnMaybeG UStringNode dom stage)
importModule :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (Ann UModuleName dom stage) (Ann UModuleName dom stage)
importAs :: () => Lens (Ann UImportDecl dom stage) (Ann UImportDecl dom stage) (AnnMaybeG UImportRenaming dom stage) (AnnMaybeG UImportRenaming dom stage)
opStr :: () => Partial (Ann UFilePragma dom stage) (Ann UFilePragma dom stage) (Ann UStringNode dom stage) (Ann UStringNode dom stage)
lpPragmas :: () => Partial (Ann UFilePragma dom stage) (Ann UFilePragma dom stage) (AnnListG ULanguageExtension dom stage) (AnnListG ULanguageExtension dom stage)
modWarningStr :: () => Partial (Ann UModulePragma dom stage) (Ann UModulePragma dom stage) (AnnListG UStringNode dom stage) (AnnListG UStringNode dom stage)
modDeprecatedPragma :: () => Partial (Ann UModulePragma dom stage) (Ann UModulePragma dom stage) (AnnListG UStringNode dom stage) (AnnListG UStringNode dom stage)
essList :: () => Partial (Ann USubSpec dom stage) (Ann USubSpec dom stage) (AnnListG UName dom stage) (AnnListG UName dom stage)
ieSubspec :: () => Lens (Ann UIESpec dom stage) (Ann UIESpec dom stage) (AnnMaybeG USubSpec dom stage) (AnnMaybeG USubSpec dom stage)
ieName :: () => Lens (Ann UIESpec dom stage) (Ann UIESpec dom stage) (Ann UName dom stage) (Ann UName dom stage)
ieModifier :: () => Lens (Ann UIESpec dom stage) (Ann UIESpec dom stage) (AnnMaybeG UImportModifier dom stage) (AnnMaybeG UImportModifier dom stage)
exportModuleName :: () => Partial (Ann UExportSpec dom stage) (Ann UExportSpec dom stage) (Ann UModuleName dom stage) (Ann UModuleName dom stage)
exportDecl :: () => Partial (Ann UExportSpec dom stage) (Ann UExportSpec dom stage) (Ann UIESpec dom stage) (Ann UIESpec dom stage)
espExports :: () => Lens (Ann UExportSpecs dom stage) (Ann UExportSpecs dom stage) (AnnListG UExportSpec dom stage) (AnnListG UExportSpec dom stage)
mhPragma :: () => Lens (Ann UModuleHead dom stage) (Ann UModuleHead dom stage) (AnnMaybeG UModulePragma dom stage) (AnnMaybeG UModulePragma dom stage)
mhName :: () => Lens (Ann UModuleHead dom stage) (Ann UModuleHead dom stage) (Ann UModuleName dom stage) (Ann UModuleName dom stage)
mhExports :: () => Lens (Ann UModuleHead dom stage) (Ann UModuleHead dom stage) (AnnMaybeG UExportSpecs dom stage) (AnnMaybeG UExportSpecs dom stage)
modImports :: () => Lens (Ann UModule dom stage) (Ann UModule dom stage) (AnnListG UImportDecl dom stage) (AnnListG UImportDecl dom stage)
modHead :: () => Lens (Ann UModule dom stage) (Ann UModule dom stage) (AnnMaybeG UModuleHead dom stage) (AnnMaybeG UModuleHead dom stage)
modDecl :: () => Lens (Ann UModule dom stage) (Ann UModule dom stage) (AnnListG UDecl dom stage) (AnnListG UDecl dom stage)
filePragmas :: () => Lens (Ann UModule dom stage) (Ann UModule dom stage) (AnnListG UFilePragma dom stage) (AnnListG UFilePragma dom stage)
semanticsLitType :: () => Ann ULiteral IdDom st -> Type

-- | Domains that have semantic information for names
type HasNameInfo dom = (Domain dom, HasNameInfo' SemanticInfo dom UQualifiedName)

-- | Infos that may have a name that can be extracted
class HasNameInfo' si
semanticsName :: HasNameInfo' si => si -> Maybe Name

-- | Domains that have semantic information for literals
type HasLiteralInfo dom = (Domain dom, HasLiteralInfo' SemanticInfo dom ULiteral)

-- | Info of types
class HasLiteralInfo' si
semanticsLiteralType :: HasLiteralInfo' si => si -> Type
type HasIdInfo dom = (Domain dom, HasIdInfo' SemanticInfo dom UQualifiedName)

-- | Infos that may have a typed name that can be extracted
class HasNameInfo' si => HasIdInfo' si
semanticsId :: HasIdInfo' si => si -> Id
type HasFixityInfo dom = (Domain dom, HasFixityInfo' SemanticInfo dom UQualifiedName)

-- | Infos that may have a fixity information
class HasFixityInfo' si
semanticsFixity :: HasFixityInfo' si => si -> Maybe Fixity
type HasScopeInfo dom = (Domain dom, HasScopeInfo' SemanticInfo dom UQualifiedName, HasScopeInfo' SemanticInfo dom UExpr)

-- | Infos that contain the names that are available in theirs scope
class HasScopeInfo' si
semanticsScope :: HasScopeInfo' si => si -> Scope
type HasDefiningInfo dom = (Domain dom, HasDefiningInfo' SemanticInfo dom UQualifiedName)

-- | Infos that store if they were used to define a name
class HasDefiningInfo' si
semanticsDefining :: HasDefiningInfo' si => si -> Bool
class HasSourceInfoInSema' si
semanticsSourceInfo :: HasSourceInfoInSema' si => si -> Maybe SrcSpan
type HasModuleInfo dom = (Domain dom, HasModuleInfo' SemanticInfo dom UModule)
class HasModuleInfo' si
semanticsModule :: HasModuleInfo' si => si -> Module
semanticsDynFlags :: HasModuleInfo' si => si -> DynFlags
isBootModule :: HasModuleInfo' si => si -> Bool
semanticsImplicitImports :: HasModuleInfo' si => si -> [Name]
semanticsPrelTransMods :: HasModuleInfo' si => si -> [Module]
type HasImportInfo dom = (Domain dom, HasImportInfo' SemanticInfo dom UImportDecl)
class HasImportInfo' si
semanticsImportedModule :: HasImportInfo' si => si -> Module
semanticsAvailable :: HasImportInfo' si => si -> [Name]
semanticsImported :: HasImportInfo' si => si -> [Name]
semanticsTransMods :: HasImportInfo' si => si -> [Module]
type HasImplicitFieldsInfo dom = (Domain dom, HasImplicitFieldsInfo' SemanticInfo dom UFieldWildcard)
class HasImplicitFieldsInfo' si
semanticsImplicitFlds :: HasImplicitFieldsInfo' si => si -> [(Name, Name)]
type HasNoSemanticInfo dom (si :: Type -> Type -> Type) = SemanticInfo dom si ~ NoSemanticInfo

-- | Gets the class and family instances from a module.
getInstances :: GhcMonad m => [Module] -> m ([ClsInst], [FamInst])
data UsageSpec
UsageSpec :: Bool -> String -> String -> UsageSpec
[usageQualified] :: UsageSpec -> Bool
[usageQualifier] :: UsageSpec -> String
[usageAs] :: UsageSpec -> String

-- | Put the given string before the element if it is not empty
after :: AfterBefore i => String -> i -> i

-- | The given string should follow the element if it is not empty
followedBy :: AfterBefore i => String -> i -> i

-- | The element should be indented relatively to its parent
relativeIndented :: RelativeIndent i => Int -> i -> i

-- | The elements should be indented at least to the given number of spaces
minimumIndented :: MinimumIndent i => Int -> i -> i
fixMainRange :: () => StringBuffer -> Ann UModule dom RangeStage -> Ann UModule dom RangeStage
prepareASTCpp :: () => StringBuffer -> Ann UModule dom RangeStage -> Ann UModule dom SrcTemplateStage

-- | Prepares the AST for pretty printing
prepareAST :: () => StringBuffer -> Ann UModule dom RangeStage -> Ann UModule dom SrcTemplateStage

-- | The elements of the list should be indented on the same column
indented :: ListInfo SrcTemplateStage -> ListInfo SrcTemplateStage

-- | The elements of the list should be separated by the given string by
--   default (might be overridden)
separatedBy :: String -> ListInfo SrcTemplateStage -> ListInfo SrcTemplateStage
list :: ListInfo SrcTemplateStage
opt :: OptionalInfo SrcTemplateStage
child :: SpanInfo SrcTemplateStage

-- | Marks template elements in the AST that should always be present in
--   the source code, regardless of their containing elements being
--   deleted. Currently it recognizes CPP pragmas (lines starting with #)
--   This function should only be applied to an AST if CPP is enabled.
extractStayingElems :: SourceInfoTraversal node => Ann node dom SrcTemplateStage -> Ann node dom SrcTemplateStage

-- | Partitions the source file in the order where the parts are used in
--   the AST
mapLocIndices :: Ord k => StringBuffer -> Set (RealSrcLoc, k) -> Map k String

-- | Assigns an index (in the order they are used) for each range
getLocIndices :: SourceInfoTraversal e => Ann e dom RngTemplateStage -> Set (RealSrcLoc, Int)
rangeToSource :: SourceInfoTraversal node => StringBuffer -> Ann node dom RngTemplateStage -> Ann node dom SrcTemplateStage
lineEndings :: Partial SourceTemplateTextElem SourceTemplateTextElem String String
sourceTemplateText :: Lens SourceTemplateTextElem SourceTemplateTextElem String String
sourceTemplateTextRange :: Partial SourceTemplateElem SourceTemplateElem SrcSpan SrcSpan
sourceTemplateTextElem :: Partial SourceTemplateElem SourceTemplateElem [SourceTemplateTextElem] [SourceTemplateTextElem]
isStayingText :: SourceTemplateTextElem -> Bool
srcTmpOptMinimalIndent :: Simple Lens (OptionalInfo SrcTemplateStage) Int
srcTmpOptAfter :: Simple Lens (OptionalInfo SrcTemplateStage) String
srcTmpOptBefore :: Simple Lens (OptionalInfo SrcTemplateStage) String
sourceTemplateOptRange :: Simple Lens (OptionalInfo SrcTemplateStage) SrcSpan
srcTmpListMinimalIndent :: Simple Lens (ListInfo SrcTemplateStage) Int
srcTmpSeparators :: Simple Lens (ListInfo SrcTemplateStage) [([SourceTemplateTextElem], SrcSpan)]
srcTmpIndented :: Simple Lens (ListInfo SrcTemplateStage) (Maybe [Bool])
srcTmpDefaultSeparator :: Simple Lens (ListInfo SrcTemplateStage) String
srcTmpListAfter :: Simple Lens (ListInfo SrcTemplateStage) String
srcTmpListBefore :: Simple Lens (ListInfo SrcTemplateStage) String
sourceTemplateListRange :: Simple Lens (ListInfo SrcTemplateStage) SrcSpan
sourceTemplateMinimalIndent :: Simple Lens (SpanInfo SrcTemplateStage) Int
sourceTemplateNodeElems :: Simple Lens (SpanInfo SrcTemplateStage) [SourceTemplateElem]
sourceTemplateNodeRange :: Simple Lens (SpanInfo SrcTemplateStage) SrcSpan

-- | An element of a source template for a singleton AST node.
data SourceTemplateElem

-- | Source text belonging to the current node
TextElem :: [SourceTemplateTextElem] -> SrcSpan -> SourceTemplateElem
[_sourceTemplateTextElem] :: SourceTemplateElem -> [SourceTemplateTextElem]
[_sourceTemplateTextRange] :: SourceTemplateElem -> SrcSpan

-- | Placeholder for the next children of the node
ChildElem :: SourceTemplateElem
data SourceTemplateTextElem
NormalText :: String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
StayingText :: String -> String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
[_lineEndings] :: SourceTemplateTextElem -> String

-- | Modifies ranges to contain their children
fixRanges :: SourceInfoTraversal node => Ann node dom RangeStage -> Ann node dom NormRangeStage

-- | Creates a source template from the ranges and the input file. All
--   source ranges must be good ranges.
cutUpRanges :: SourceInfoTraversal node => Ann node dom NormRangeStage -> Ann node dom RngTemplateStage
data BreakUpProblem
BreakUpProblem :: RealSrcSpan -> SrcSpan -> [SrcSpan] -> BreakUpProblem
[bupOuter] :: BreakUpProblem -> RealSrcSpan
[bupInner] :: BreakUpProblem -> SrcSpan
[bupSiblings] :: BreakUpProblem -> [SrcSpan]
data TransformationProblem
TransformationProblem :: String -> TransformationProblem

-- | Puts comments in the nodes they should be attached to. Watches for
--   lexical tokens that may divide the comment and the supposed element.
--   Leaves the AST in a state where parent nodes does not contain all of
--   their children.
placeComments :: RangeInfo stage => Map ApiAnnKey [SrcSpan] -> Map SrcSpan [Located AnnotationComment] -> Ann UModule dom stage -> Ann UModule dom stage
getPragmaComments :: Map SrcSpan [Located AnnotationComment] -> Map String [Located String]
getNormalComments :: Map SrcSpan [Located AnnotationComment] -> Map SrcSpan [Located AnnotationComment]

-- | Forall types (<tt> forall x y . type </tt>)
pattern ForallType :: () => () => TyVarList -> Type -> Type

-- | Type with a context (<tt> C a =&gt; type </tt>)
pattern CtxType :: () => () => Context -> Type -> Type

-- | Function types (<tt> a -&gt; b </tt>)
pattern FunctionType :: () => () => Type -> Type -> Type

-- | Tuple types (<tt> (a,b) </tt>)
pattern TupleType :: () => () => TypeList -> Type

-- | Unboxed tuple types (<tt> (#a,b#) </tt>)
pattern UnboxedTupleType :: () => () => TypeList -> Type

-- | List type with special syntax (<tt> [a] </tt>)
pattern ListType :: () => () => Type -> Type

-- | Parallel array type (<tt> [:a:] </tt>)
pattern ParArrayType :: () => () => Type -> Type

-- | Type application (<tt> F a </tt>)
pattern TypeApp :: () => () => Type -> Type -> Type

-- | Infix type constructor (<tt> (a &lt;: b) </tt>)
pattern InfixTypeApp :: () => () => Type -> Operator -> Type -> Type

-- | Type surrounded by parentheses (<tt> (T a) </tt>)
pattern ParenType :: () => () => Type -> Type

-- | Type variable or constructor (<tt> a </tt>)
pattern VarType :: () => () => Name -> Type

-- | Type with explicit kind signature (<tt> a :: * </tt>)
pattern KindedType :: () => () => Type -> Kind -> Type

-- | Strict type marked with <tt>!</tt>.
pattern BangType :: () => () => Type -> Type

-- | Lazy type marked with <tt>~</tt>. (Should only be used if
--   <tt>Strict</tt> or <tt>StrictData</tt> language extension is used)
pattern LazyType :: () => () => Type -> Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
pattern UnpackType :: () => () => Type -> Type

-- | Strict type marked with NOUNPACK pragma. (Usually contains the bang
--   mark.)
pattern NoUnpackType :: () => () => Type -> Type

-- | A wildcard type (<tt> _ </tt>) with <tt>-XPartialTypeSignatures</tt>
pattern WildcardType :: () => () => Type

-- | A named wildcard type (<tt> _t </tt>) with
--   <tt>-XPartialTypeSignatures</tt>
pattern NamedWildcardType :: () => () => Name -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
pattern SpliceType :: () => () => Splice -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
pattern QuasiQuoteType :: () => () => QuasiQuote -> Type

-- | Numeric value promoted to the type level.
pattern PromotedIntType :: () => () => Integer -> Type

-- | String value promoted to the type level.
pattern PromotedStringType :: () => () => String -> Type

-- | A data constructor value promoted to the type level.
pattern PromotedConType :: () => () => Name -> Type

-- | A list of elements as a type.
pattern PromotedListType :: () => () => TypeList -> Type

-- | A tuple of elements as a type.
pattern PromotedTupleType :: () => () => TypeList -> Type

-- | Kind of the unit value <tt>()</tt>.
pattern PromotedUnitType :: () => () => Type

-- | An unboxed sum type.
pattern UnboxedSumType :: () => () => TypeList -> Type

-- | Type variable declaration
pattern TyVarDecl :: () => () => Name -> TyVar

-- | Kinded type variable declaration (<tt> v :: * </tt>)
pattern KindedTyVarDecl :: () => () => Name -> Kind -> TyVar

-- | A context of assertions (<tt> C a =&gt; ... </tt>)
pattern Context :: () => () => Assertion -> Context

-- | Class assertion (<tt>Cls x</tt>)
pattern ClassAssert :: () => () => Name -> TypeList -> Assertion

-- | Infix class assertion, also contains type equations (<tt> a ~ X y
--   </tt>)
pattern InfixAssert :: () => () => Type -> Operator -> Type -> Assertion

-- | Assertion for implicit parameter binding (<tt> ?cmp :: a -&gt; a -&gt;
--   Bool </tt>)
pattern ImplicitAssert :: () => () => Name -> Type -> Assertion

-- | A list of assertions (<tt> (Eq a, Show a) </tt>)
pattern TupleAssert :: () => () => [Assertion] -> Assertion

-- | A simple name splice: <tt>$generateX</tt>
pattern IdSplice :: () => () => Name -> Splice

-- | A splice with parentheses: <tt>$(generate input)</tt>
pattern ParenSplice :: () => () => Expr -> Splice

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
pattern QuasiQuote :: () => () => Name -> String -> QuasiQuote

-- | Expression bracket (<tt> [| x + y |] </tt>)
pattern ExprBracket :: () => () => Expr -> Bracket

-- | Pattern bracket (<tt> [p| Point x y |] </tt>)
pattern PatternBracket :: () => () => Pattern -> Bracket

-- | Type bracket (<tt> [t| (Int,Int) |] </tt>)
pattern TypeBracket :: () => () => Type -> Bracket

-- | Declaration bracket (<tt> [d| f :: Int -&gt; Int; f x = x*x |] </tt>)
pattern DeclsBracket :: () => () => DeclList -> Bracket

-- | An expression for a variable or a data constructor (<tt> a </tt>)
pattern Var :: () => () => Name -> Expr

-- | A literal expression (<tt> 42 </tt>)
pattern Lit :: () => () => Literal -> Expr

-- | An infix operator application (<tt> a + b </tt>)
pattern InfixApp :: () => () => Expr -> Operator -> Expr -> Expr

-- | Prefix operator application (<tt> -x </tt>)
pattern PrefixApp :: () => () => Operator -> Expr -> Expr

-- | Function application (<tt> f 4 </tt>)
pattern App :: () => () => Expr -> Expr -> Expr

-- | Lambda expression (<tt> \a b -&gt; a + b </tt>)
pattern Lambda :: () => () => PatternList -> Expr -> Expr

-- | Local binding (<tt> let x = 2; y = 3 in e x y </tt>)
pattern Let :: () => () => LocalBindList -> Expr -> Expr

-- | If expression (<tt> if a then b else c </tt>)
pattern If :: () => () => Expr -> Expr -> Expr -> Expr

-- | Multi way if expressions with <tt>MultiWayIf</tt> extension (<tt> if |
--   guard1 -&gt; expr1; guard2 -&gt; expr2 </tt>)
pattern MultiIf :: () => () => GuardedCaseRhsList -> Expr

-- | Pattern matching expression (<tt> case expr of pat1 -&gt; expr1; pat2
--   -&gt; expr2 </tt>)
pattern Case :: () => () => Expr -> AltList -> Expr

-- | Do-notation expressions (<tt> do x &lt;- act1; act2 </tt>)
pattern Do :: () => () => StmtList -> Expr

-- | MDo-notation expressions (<tt> mdo x &lt;- act1; act2 </tt>)
pattern MDo :: () => () => StmtList -> Expr
pattern ParArrayComp :: () => () => Expr -> ListCompBodyList -> Expr

-- | Tuple expression (<tt> (e1, e2, e3) </tt>)
pattern Tuple :: () => () => ExprList -> Expr

-- | Unboxed tuple expression (<tt> (# e1, e2, e3 #) </tt>)
pattern UnboxedTuple :: () => () => ExprList -> Expr

-- | Tuple section, enabled with <tt>TupleSections</tt> (<tt> (a,,b)
--   </tt>). One of the elements must be missing.
pattern TupleSection :: () => () => TupSecElemList -> Expr

-- | Unboxed tuple section enabled with <tt>TupleSections</tt> (<tt> ()
--   </tt>). One of the elements must be missing.
pattern UnboxedTupleSection :: () => () => TupSecElemList -> Expr

-- | List expression: <tt>[1,2,3]</tt>
pattern List :: () => () => ExprList -> Expr

-- | Parallel array expression: <tt>[: 1,2,3 :]</tt>
pattern ParArray :: () => () => ExprList -> Expr

-- | Parenthesized expression: <tt>( a + b )</tt>
pattern Paren :: () => () => Expr -> Expr

-- | Left operator section: <tt>(1+)</tt>
pattern LeftSection :: () => () => Expr -> Operator -> Expr

-- | Right operator section: <tt>(+1)</tt>
pattern RightSection :: () => () => Operator -> Expr -> Expr

-- | Record value construction: <tt>Point { x = 3, y = -2 }</tt>
pattern RecCon :: () => () => Name -> FieldUpdateList -> Expr

-- | Record value update: <tt>p1 { x = 3, y = -2 }</tt>
pattern RecUpdate :: () => () => Expr -> FieldUpdateList -> Expr

-- | Enumeration expression (<tt> [1,3..10] </tt>)
pattern Enum :: () => () => Expr -> MaybeExpr -> MaybeExpr -> Expr

-- | Parallel array enumeration (<tt> [: 1,3 .. 10 :] </tt>)
pattern ParArrayEnum :: () => () => Expr -> MaybeExpr -> Expr -> Expr

-- | List comprehension (<tt> [ (x, y) | x &lt;- xs | y &lt;- ys ] </tt>)
pattern ListComp :: () => () => Expr -> ListCompBodyList -> Expr

-- | Parallel array comprehensions <tt> [: (x, y) | x &lt;- xs , y &lt;- ys
--   :] </tt> enabled by <tt>ParallelArrays</tt>
pattern ParArrayListComp :: () => () => Expr -> ListCompBodyList -> Expr

-- | Explicit type signature (<tt> x :: Int </tt>)
pattern TypeSig :: () => () => Expr -> Type -> Expr

-- | Explicit type application (<tt> show @Integer (read "5") </tt>)
pattern ExplicitTypeApp :: () => () => Expr -> Type -> Expr

-- | <tt>'x</tt> for template haskell reifying of expressions
pattern VarQuote :: () => () => Name -> Expr

-- | <tt>''T</tt> for template haskell reifying of types
pattern TypeQuote :: () => () => Name -> Expr

-- | Template haskell bracket expression
pattern BracketExpr :: () => () => Bracket -> Expr

-- | Template haskell splice expression, for example: <tt>$(gen a)</tt> or
--   <tt>$x</tt>
pattern SpliceExpr :: () => () => Splice -> Expr

-- | Template haskell quasi-quotation: <tt>[$quoter|str]</tt>
pattern QuasiQuoteExpr :: () => () => QuasiQuote -> Expr

-- | Template haskell quasi-quotation: <tt>[$quoter|str]</tt>
pattern ExprPragma :: () => () => ExprPragma -> Expr -> Expr

-- | Arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
pattern Proc :: () => () => Pattern -> Cmd -> Expr

-- | Arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
pattern ArrowApp :: () => () => Expr -> ArrowApp -> Expr -> Expr

-- | Lambda case ( <tt>case 0 -&gt; 1; 1 -&gt; 2</tt> )
pattern LambdaCase :: () => () => AltList -> Expr

-- | Static pointer expression (<tt> static e </tt>). The inner expression
--   must be closed (cannot have variables bound outside)
pattern StaticPointer :: () => () => Expr -> Expr

-- | Update of a field (<tt> x = 1 </tt>)
pattern NormalFieldUpdate :: () => () => Name -> Expr -> FieldUpdate

-- | Update the field to the value of the same name (<tt> x </tt>)
pattern FieldPun :: () => () => Name -> FieldUpdate

-- | Update the fields of the bounded names to their values (<tt> ..
--   </tt>). Must be the last initializer. Cannot be used in a record
--   update expression.
pattern FieldWildcard :: () => () => FieldWildcard -> FieldUpdate

-- | An existing element in a tuple section
pattern TupSecPresent :: () => () => Expr -> TupSecElem

-- | A missing element in a tuple section
pattern TupSecMissing :: () => () => TupSecElem

-- | Clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
pattern Alt :: () => () => Pattern -> CaseRhs -> MaybeLocalBinds -> Alt

-- | Unguarded right-hand side a pattern match (<tt> -&gt; 3 </tt>)
pattern CaseRhs :: () => () => Expr -> CaseRhs

-- | Guarded right-hand sides of a pattern match (<tt> | x == 1 -&gt; 3; |
--   otherwise -&gt; 4 </tt>)
pattern GuardedCaseRhss :: () => () => GuardedCaseRhsList -> CaseRhs

-- | A guarded right-hand side of pattern matches binding (<tt> | x &gt; 3
--   -&gt; 2 </tt>)
pattern GuardedCaseRhs :: () => () => RhsGuardList -> Expr -> GuardedCaseRhs

-- | A <tt>CORE</tt> pragma for adding notes to expressions.
pattern CorePragma :: () => () => String -> ExprPragma

-- | An <tt>SCC</tt> pragma for defining cost centers for profiling
pattern SccPragma :: () => () => String -> ExprPragma

-- | A pragma that describes if an expression was generated from a code
--   fragment by an external tool (<tt> {--} </tt>)
pattern GeneratedPragma :: () => () => SourceRange -> ExprPragma

-- | In-AST source ranges (for generated pragmas)
pattern SourceRange :: () => () => String -> Integer -> Integer -> Integer -> Integer -> SourceRange

-- | An arrow application command (<tt> f -&lt; x + 1 </tt>)
pattern ArrowAppCmd :: () => () => Expr -> ArrowApp -> Expr -> Cmd

-- | A form command (<tt> (|untilA (increment -&lt; x+y) (within 0.5 -&lt;
--   x)|) </tt>)
pattern ArrowFormCmd :: () => () => Expr -> CmdList -> Cmd

-- | A function application command
pattern AppCmd :: () => () => Cmd -> Expr -> Cmd

-- | An infix command application
pattern InfixCmd :: () => () => Cmd -> Name -> Cmd -> Cmd

-- | An infix command application
pattern LambdaCmd :: () => () => PatternList -> Cmd -> Cmd

-- | A parenthesized command
pattern ParenCmd :: () => () => Cmd -> Cmd

-- | A pattern match command
pattern CaseCmd :: () => () => Expr -> CmdAltList -> Cmd

-- | An if command (<tt> if f x y then g -&lt; x+1 else h -&lt; y+2 </tt>)
pattern IfCmd :: () => () => Expr -> Cmd -> Cmd -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
pattern LetCmd :: () => () => LocalBindList -> Cmd -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
pattern DoCmd :: () => () => CmdStmtList -> Cmd

-- | Left arrow application: <tt>-&lt;</tt>
pattern LeftAppl :: () => () => ArrowApp

-- | Right arrow application: <tt>&gt;-</tt>
pattern RightAppl :: () => () => ArrowApp

-- | Left arrow high application: <tt>-&lt;&lt;</tt>
pattern LeftHighApp :: () => () => ArrowApp

-- | Right arrow high application: <tt>&gt;&gt;-</tt>
pattern RightHighApp :: () => () => ArrowApp

-- | A hole expression <tt>_</tt>
pattern Hole :: () => () => Expr

-- | Binding statement (<tt> x &lt;- action </tt>)
pattern BindStmt :: () => () => Pattern -> Expr -> Stmt

-- | Non-binding statement (<tt> action </tt>)
pattern ExprStmt :: () => () => Expr -> Stmt

-- | Let statement (<tt> let x = 3; y = 4 </tt>)
pattern LetStmt :: () => () => LocalBindList -> Stmt

-- | A recursive binding statement with (<tt> rec b &lt;- f a c; c &lt;- f
--   b a </tt>)
pattern RecStmt :: () => () => StmtList -> Stmt
pattern DoKeyword :: () => () => DoKind
pattern MDoKeyword :: () => () => DoKind

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
pattern ListCompBody :: () => () => CompStmtList -> ListCompBody

-- | Normal monadic statement of a list comprehension
pattern CompStmt :: () => () => Stmt -> CompStmt

-- | Then statements by <tt>TransformListComp</tt> (<tt> then sortWith by
--   (x + y) </tt>)
pattern ThenStmt :: () => () => Expr -> MaybeExpr -> CompStmt

-- | Grouping statements by <tt>TransformListComp</tt> (<tt> then group by
--   (x + y) using groupWith </tt>)
pattern GroupStmt :: () => () => MaybeExpr -> MaybeExpr -> CompStmt

-- | Binding statement command (<tt> x &lt;- action </tt>)
pattern BindStmtCmd :: () => () => Pattern -> Cmd -> CmdStmt

-- | Non-binding statement command (<tt> action </tt>)
pattern ExprStmtCmd :: () => () => Cmd -> CmdStmt

-- | Let statement command (<tt> let x = 3; y = 4 </tt>)
pattern LetStmtCmd :: () => () => LocalBindList -> CmdStmt

-- | A recursive binding statement command with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
pattern RecStmtCmd :: () => () => CmdStmtList -> CmdStmt

-- | Pattern name binding
pattern VarPat :: () => () => Name -> Pattern

-- | Literal pattern
pattern LitPat :: () => () => Literal -> Pattern

-- | Infix constructor application pattern (<tt> a :+: b </tt>)
pattern InfixAppPat :: () => () => Pattern -> Operator -> Pattern -> Pattern

-- | Constructor application pattern (<tt> Point x y </tt>)
pattern AppPat :: () => () => Name -> PatternList -> Pattern

-- | Tuple pattern (<tt> (x,y) </tt>)
pattern TuplePat :: () => () => PatternList -> Pattern

-- | Unboxed tuple pattern (<tt> (# x, y #) </tt>)
pattern UnboxTuplePat :: () => () => PatternList -> Pattern

-- | List pattern (<tt> [1,2,a,x] </tt>)
pattern ListPat :: () => () => PatternList -> Pattern

-- | Parallel array pattern (<tt> [:1,2,a,x:] </tt>)
pattern ParArrayPat :: () => () => PatternList -> Pattern

-- | Parenthesised patterns
pattern ParenPat :: () => () => Pattern -> Pattern

-- | Record pattern (<tt> Point { x = 3, y } </tt>)
pattern RecPat :: () => () => Name -> PatternFieldList -> Pattern

-- | As-pattern (explicit name binding) (<tt> ls@(hd:_) </tt>)
pattern AsPat :: () => () => Name -> Pattern -> Pattern

-- | Wildcard pattern: (<tt> _ </tt>)
pattern WildPat :: () => () => Pattern

-- | Irrefutable pattern (<tt> ~(x:_) </tt>)
pattern IrrefutablePat :: () => () => Pattern -> Pattern

-- | Bang pattern (<tt> !x </tt>)
pattern BangPat :: () => () => Pattern -> Pattern

-- | Pattern with explicit type signature (<tt> x :: Int </tt>)
pattern TypeSigPat :: () => () => Pattern -> Type -> Pattern

-- | View pattern (<tt> f -&gt; Just 1 </tt>)
pattern ViewPat :: () => () => Expr -> Pattern -> Pattern

-- | Splice patterns: <tt>$(generateX inp)</tt>
pattern SplicePat :: () => () => Splice -> Pattern

-- | Quasi-quoted patterns: <tt>[| 1 + 2 |]</tt>
pattern QuasiQuotePat :: () => () => QuasiQuote -> Pattern
pattern NPlusKPat :: () => () => Name -> Literal -> Pattern

-- | Named field pattern (<tt> p = Point 3 2 </tt>)
pattern FieldPattern :: () => () => Name -> Pattern -> PatternField

-- | Named field pun (<tt> p </tt>)
pattern FieldPunPattern :: () => () => Name -> PatternField

-- | Wildcard field pattern (<tt> .. </tt>)
pattern FieldWildcardPattern :: () => () => FieldWildcard -> PatternField

-- | A normal operator used as an operator.
pattern NormalOp :: () => () => QualifiedName -> Operator

-- | A normal name used as an operator with backticks: <tt> a `mod` b </tt>
pattern BacktickOp :: () => () => QualifiedName -> Operator

-- | A normal, non-operator name.
pattern NormalName :: () => () => QualifiedName -> Name

-- | Parenthesized name: <tt> foldl (+) 0 </tt>
pattern ParenName :: () => () => QualifiedName -> Name

-- | Creates an implicit name: <tt> ?var </tt>
pattern ImplicitName :: () => () => QualifiedName -> Name

-- | Program elements formatted as string literals (import packages, pragma
--   texts)
pattern StringNode :: () => () => String -> StringNode

-- | Possibly qualified name.
pattern QualifiedName :: () => () => NamePartList -> NamePart -> QualifiedName

-- | Parts of a qualified name.
pattern NamePart :: () => () => String -> NamePart

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
pattern Module :: () => () => FilePragmaList -> MaybeModuleHead -> ImportDeclList -> DeclList -> Module

-- | Module declaration with name and (optional) exports
pattern ModuleHead :: () => () => ModuleName -> MaybeModulePragma -> MaybeExportSpecs -> ModuleHead

-- | A list of export specifications surrounded by parentheses
pattern ExportSpecs :: () => () => ExportSpecList -> ExportSpecs

-- | Export a name and related names
pattern ExportSpec :: () => () => IESpec -> ExportSpec

-- | The export of an imported module (<tt> module A </tt>)
pattern ModuleExport :: () => () => ModuleName -> ExportSpec

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
pattern IESpec :: () => () => MaybeImportModifier -> Name -> MaybeSubSpec -> IESpec

-- | <tt>(..)</tt>: a class exported with all of its methods, or a datatype
--   exported with all of its constructors.
pattern SubAll :: () => () => SubSpec

-- | <tt>(a,b,c)</tt>: a class exported with some of its methods, or a
--   datatype exported with some of its constructors.
pattern SubList :: () => () => NameList -> SubSpec
pattern ImportDecl :: () => () => MaybeImportSource -> MaybeImportQualified -> MaybeImportSafe -> MaybeStringNode -> ModuleName -> MaybeImportRenaming -> MaybeImportSpec -> ImportDecl
pattern ImportRenaming :: () => () => ModuleName -> ImportRenaming
pattern ImportSpecList :: () => () => IESpecList -> ImportSpec
pattern ImportHidingList :: () => () => IESpecList -> ImportSpec
pattern ModuleName :: () => () => String -> ModuleName

-- | <tt>LANGUAGE</tt> pragma, listing the enabled language extensions in
--   that file
pattern LanguagePragma :: () => () => LanguageExtensionList -> FilePragma

-- | <tt>OPTIONS</tt> pragma, possibly qualified with a tool, e.g.
--   OPTIONS_GHC
pattern OptionsPragma :: () => () => String -> FilePragma

-- | The name of the enabled language extension, for example (<tt>
--   LambdaCase </tt>)
pattern LanguageExtension :: () => () => String -> LanguageExtension

-- | A warning pragma attached to the module
pattern ModuleWarningPragma :: () => () => StringNodeList -> ModulePragma

-- | A deprecated pragma attached to the module
pattern ModuleDeprecatedPragma :: () => () => StringNodeList -> ModulePragma

-- | Character literal: <tt><tt>c</tt></tt>
pattern CharLit :: () => () => Char -> Literal

-- | String literal: <tt>"abc"</tt>
pattern StringLit :: () => () => String -> Literal

-- | Integer literal: <tt>12</tt>
pattern IntLit :: () => () => Integer -> Literal

-- | Fractional literal: <tt>3.14</tt>
pattern FracLit :: () => () => Rational -> Literal

-- | Primitive integer literal (of type <tt>Int#</tt>): <tt>32#</tt>
pattern PrimIntLit :: () => () => Integer -> Literal

-- | Primitive word literal (of type <tt>Word#</tt>): <tt>32##</tt>
pattern PrimWordLit :: () => () => Integer -> Literal

-- | Primitive float literal (of type <tt>Float#</tt>): <tt>3.14#</tt>
pattern PrimFloatLit :: () => () => Rational -> Literal

-- | Primitive double literal (of type <tt>Double#</tt>): <tt>3.14##</tt>
pattern PrimDoubleLit :: () => () => Rational -> Literal

-- | Primitive character literal (of type <tt>Char#</tt>):
--   <tt><tt>c</tt>#</tt>
pattern PrimCharLit :: () => () => Char -> Literal

-- | Primitive string literal (of type <tt>Addr#</tt>): <tt>"xxx"#</tt>
pattern PrimStringLit :: () => () => String -> Literal

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
pattern KindConstraint :: () => () => Kind -> KindConstraint

-- | <tt>*</tt>, the kind of types
pattern StarKind :: () => () => Kind

-- | <tt>#</tt>, the kind of unboxed types
pattern UnboxKind :: () => () => Kind

-- | <tt>-&gt;</tt>, the kind of type constructor
pattern FunKind :: () => () => Kind -> Kind -> Kind

-- | A parenthesised kind
pattern ParenKind :: () => () => Kind -> Kind

-- | Kind variable (using <tt>PolyKinds</tt> extension)
pattern VarKind :: () => () => Name -> Kind

-- | Kind application (<tt> k1 k2 </tt>)
pattern AppKind :: () => () => Kind -> Kind -> Kind

-- | A list kind (<tt> [k] </tt>)
pattern ListKind :: () => () => Kind -> Kind

-- | Numeric value promoted to the kind level.
pattern IntKind :: () => () => Integer -> Kind

-- | String value promoted to the kind level.
pattern StringKind :: () => () => String -> Kind

-- | A data constructor value promoted to the kind level.
pattern ConKind :: () => () => Name -> Kind

-- | A list of elements as a kind.
pattern ListKindPromoted :: () => () => KindList -> Kind

-- | A tuple of elements as a kind.
pattern TupleKind :: () => () => KindList -> Kind

-- | Kind of the unit value <tt>()</tt>.
pattern UnitKind :: () => () => Kind

-- | A type synonym ( <tt>type String = [Char]</tt> )
pattern TypeDecl :: () => () => DeclHead -> Type -> Decl

-- | Standalone deriving declaration (<tt> deriving instance X T </tt>)
pattern StandaloneDeriving :: () => () => Maybe DeriveStrategy -> Maybe OverlapPragma -> InstanceRule -> Decl

-- | Fixity declaration (<tt> infixl 5 +, - </tt>)
pattern FixityDecl :: () => () => FixitySignature -> Decl

-- | Default types (<tt> default (T1, T2) </tt>)
pattern DefaultDecl :: () => () => TypeList -> Decl

-- | Type signature declaration (<tt> f :: Int -&gt; Int </tt>)
pattern TypeSigDecl :: () => () => TypeSignature -> Decl

-- | Function or value binding (<tt> f x = 12 </tt>)
pattern ValueBinding :: () => () => ValueBind -> Decl

-- | A Template Haskell splice declaration (<tt> $(generateDecls) </tt>)
pattern SpliceDecl :: () => () => Splice -> Decl

-- | A data or newtype declaration. Empty data type declarations without
--   where keyword are always belong to DataDecl.
pattern DataDecl :: () => () => DataOrNewtypeKeyword -> MaybeContext -> DeclHead -> ConDeclList -> DerivingList -> Decl

-- | A GADT-style data or newtype declaration.
pattern GADTDataDecl :: () => () => DataOrNewtypeKeyword -> MaybeContext -> DeclHead -> MaybeKindConstraint -> AnnList UGadtConDecl -> DerivingList -> Decl

-- | GADT constructor declaration (<tt> D1 :: Int -&gt; T String </tt>)
pattern GadtConDecl :: () => () => NameList -> Type -> GadtConDecl

-- | GADT constructor declaration with record syntax (<tt> D1 :: { val ::
--   Int } -&gt; T String </tt>)
pattern GadtRecordConDecl :: () => () => NameList -> FieldDeclList -> Type -> GadtConDecl

-- | Ordinary data constructor (<tt> C t1 t2 </tt>)
pattern ConDecl :: () => () => Name -> TypeList -> ConDecl

-- | Creates a record data constructor (<tt> Point { x :: Double, y ::
--   Double } </tt>)
pattern RecordConDecl :: () => () => Name -> FieldDeclList -> ConDecl

-- | Infix data constructor (<tt> t1 :+: t2 </tt>)
pattern InfixConDecl :: () => () => Type -> Operator -> Type -> ConDecl

-- | Field declaration (<tt> fld :: Int </tt>)
pattern FieldDecl :: () => () => NameList -> Type -> FieldDecl

-- | A deriving clause without parentheses (<tt> deriving Show </tt>.
pattern DerivingOne :: () => () => InstanceHead -> Deriving

-- | A deriving clause without parentheses, with/witohut strategy (<tt>
--   deriving stock Show </tt>.
pattern DerivingOne' :: () => () => MaybeDeriveStrategy -> InstanceHead -> Deriving

-- | A deriving clause with parentheses <tt> deriving (Show, Eq) </tt>)
pattern DerivingMulti :: () => () => InstanceHeadList -> Deriving

-- | A deriving clause with parentheses, with/witohut strategy (<tt>
--   deriving stock (Show, Eq) </tt>.
pattern DerivingMulti' :: () => () => MaybeDeriveStrategy -> InstanceHeadList -> Deriving
pattern DataKeyword :: () => () => DataOrNewtypeKeyword
pattern NewtypeKeyword :: () => () => DataOrNewtypeKeyword

-- | A list of functional dependencies: <tt> | a -&gt; b, c -&gt; d </tt>
--   separated by commas
pattern FunDeps :: () => () => FunDepList -> FunDeps

-- | A functional dependency, given on the form <tt>l1 ... ln -&gt; r1 ...
--   rn</tt>
pattern FunDep :: () => () => NameList -> NameList -> FunDep

-- | Type class declaration (<tt> class X a [where f = ...] </tt>)
pattern ClassDecl :: () => () => MaybeContext -> DeclHead -> MaybeFunDeps -> MaybeClassBody -> Decl

-- | The list of declarations that can appear in a typeclass
pattern ClassBody :: () => () => ClassElementList -> ClassBody

-- | Type signature: <tt> f :: A -&gt; B </tt> as a class member
pattern ClassElemSig :: () => () => TypeSignature -> ClassElement

-- | Default binding: <tt> f x = "aaa" </tt> as a class member
pattern ClassElemDef :: () => () => ValueBind -> ClassElement

-- | Declaration of an associated type synonym: <tt> type T x :: * </tt> in
--   a class
pattern ClassElemTypeFam :: () => () => DeclHead -> MaybeTypeFamilySpec -> ClassElement

-- | Declaration of an associated data synonym: <tt> data T x :: * </tt> in
--   a class
pattern ClassElemDataFam :: () => () => DeclHead -> MaybeKindConstraint -> ClassElement

-- | Default choice for type synonym: <tt> type T x = TE </tt> or <tt> type
--   instance T x = TE </tt> in a class
pattern ClsDefaultType :: () => () => DeclHead -> Type -> ClassElement

-- | Default signature (by using <tt>DefaultSignatures</tt>): <tt> default
--   enum :: (Generic a, GEnum (Rep a)) =&gt; [a] </tt>
pattern ClsDefaultSig :: () => () => Name -> Type -> ClassElement

-- | Minimal pragma: <tt> {-# MINIMAL (==) | (/=) #-} </tt> in a class
pattern ClsMinimal :: () => () => MinimalFormula -> ClassElement
pattern MinimalName :: () => () => Name -> MinimalFormula
pattern MinimalParen :: () => () => MinimalFormula -> MinimalFormula

-- | One of the minimal formulas are needed (<tt> min1 | min2 </tt>)
pattern MinimalOr :: () => () => MinimalFormulaList -> MinimalFormula

-- | Both of the minimal formulas are needed (<tt> min1 , min2 </tt>)
pattern MinimalAnd :: () => () => MinimalFormulaList -> MinimalFormula

-- | Type or class name as a declaration head
pattern NameDeclHead :: () => () => Name -> DeclHead

-- | Parenthesized type as a declaration head
pattern ParenDeclHead :: () => () => DeclHead -> DeclHead

-- | Type application as a declaration head
pattern DeclHeadApp :: () => () => DeclHead -> TyVar -> DeclHead

-- | Infix type application as a declaration head
pattern InfixDeclHead :: () => () => TyVar -> Operator -> TyVar -> DeclHead

-- | Instance declaration (<tt> instance X T [where f = ...] </tt>)
pattern InstanceDecl :: () => () => InstanceRule -> MaybeInstBody -> Decl

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
pattern InstanceBody :: () => () => InstBodyDeclList -> InstBody

-- | A normal value binding (<tt> f x = 12 </tt>) inside a class instance
pattern InstanceBind :: () => () => ValueBind -> InstBodyDecl

-- | Type signature in instance definition with <tt>InstanceSigs</tt>
pattern InstanceTypeSig :: () => () => TypeSignature -> InstBodyDecl

-- | An associated type definition (<tt> type A X = B </tt>) in a class
--   instance
pattern InstanceTypeFamilyDef :: () => () => TypeEqn -> InstBodyDecl

-- | An associated data definition (<tt> data A X = B Int | C </tt>) in a
--   class instance
pattern InstanceDataFamilyDef :: () => () => DataOrNewtypeKeyword -> InstanceRule -> ConDeclList -> DerivingList -> InstBodyDecl

-- | An associated data definition as a GADT (<tt> data A X where B :: Int
--   -&gt; A X </tt>) in a class instance
pattern InstanceDataFamilyGADTDef :: () => () => DataOrNewtypeKeyword -> InstanceRule -> MaybeKindConstraint -> AnnList UGadtConDecl -> DerivingList -> InstBodyDecl

-- | Specialize instance pragma in a class instance (no phase selection is
--   allowed)
pattern InstanceSpecializePragma :: () => () => Type -> InstBodyDecl

-- | Instance head as an instance rule (<tt> X a =&gt; Y a </tt>)
pattern InstanceRule :: () => () => AnnMaybe (AnnListG UTyVar) -> MaybeContext -> InstanceHead -> InstanceRule

-- | Type or class name as an instance head
pattern InstanceHead :: () => () => Name -> InstanceHead

-- | Infix application of the type/class name to the left operand as an
--   instance head
pattern InfixInstanceHead :: () => () => Type -> Operator -> InstanceHead

-- | Parenthesized instance head
pattern ParenInstanceHead :: () => () => InstanceHead -> InstanceHead

-- | Type application as an instance head
pattern AppInstanceHead :: () => () => InstanceHead -> Type -> InstanceHead

-- | <tt>OVERLAP</tt> pragma
pattern EnableOverlap :: () => () => OverlapPragma

-- | <tt>NO_OVERLAP</tt> pragma
pattern DisableOverlap :: () => () => OverlapPragma

-- | <tt>OVERLAPPABLE</tt> pragma
pattern Overlappable :: () => () => OverlapPragma

-- | <tt>OVERLAPPING</tt> pragma
pattern Overlapping :: () => () => OverlapPragma

-- | <tt>OVERLAPS</tt> pragma
pattern Overlaps :: () => () => OverlapPragma

-- | <tt>INCOHERENT</tt> pragma
pattern IncoherentOverlap :: () => () => OverlapPragma

-- | Role annotations (<tt> type role Ptr representational </tt>)
pattern RoleDecl :: () => () => QualifiedName -> RoleList -> Decl
pattern NominalRole :: () => () => Role
pattern RepresentationalRole :: () => () => Role
pattern PhantomRole :: () => () => Role

-- | Foreign import (<tt> foreign import foo :: Int -&gt; IO Int </tt>)
pattern ForeignImport :: () => () => CallConv -> MaybeSafety -> Name -> Type -> Decl

-- | Foreign export (<tt> foreign export ccall foo :: Int -&gt; IO Int
--   </tt>)
pattern ForeignExport :: () => () => CallConv -> Name -> Type -> Decl

-- | Specifies <tt>stdcall</tt> calling convention for foreign
--   import/export.
pattern StdCall :: () => () => CallConv

-- | Specifies <tt>ccall</tt> calling convention for foreign import/export.
pattern CCall :: () => () => CallConv

-- | Specifies <tt>capi</tt> calling convention for foreign import/export.
pattern CApi :: () => () => CallConv

-- | Specifies that the given foreign import is <tt>unsafe</tt>.
pattern Unsafe :: () => () => Safety

-- | Pattern synonyms (<tt> pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
--   </tt>)
pattern PatternSynonym :: () => () => PatSynLhs -> PatSynRhs -> Decl

-- | A left hand side with a constructor name and arguments (<tt> Arrow t1
--   t2 </tt>)
pattern ConPatSyn :: () => () => Name -> NameList -> PatSynLhs

-- | An infix pattern synonym left-hand side (<tt> t1 :+: t2 </tt>)
pattern InfixPatSyn :: () => () => Name -> Operator -> Name -> PatSynLhs

-- | A record-style pattern synonym left-hand side (<tt> Arrow { arrowFrom,
--   arrowTo } </tt>)
pattern RecordPatSyn :: () => () => Name -> NameList -> PatSynLhs

-- | An automatically two-way pattern synonym (<tt> = App "Int" [] </tt>)
pattern SymmetricPatSyn :: () => () => Pattern -> PatSynRhs

-- | A pattern synonym that can be only used for pattenr matching but not
--   for combining (<tt> &lt;- App "Int" [] </tt>)
pattern OneWayPatSyn :: () => () => Pattern -> PatSynRhs

-- | A pattern synonym with the other direction explicitly specified (<tt>
--   &lt;- App "Int" [] where Int = App "Int" [] </tt>)
pattern TwoWayPatSyn :: () => () => Pattern -> MatchList -> PatSynRhs

-- | Pattern type signature declaration (<tt> pattern Succ :: Int -&gt; Int
--   </tt>)
pattern PatternSignatureDecl :: () => () => PatternSignature -> Decl
pattern PatternSignature :: () => () => NameList -> Type -> PatternSignature

-- | Type family declaration (<tt> type family A a :: * -&gt; * </tt>)
pattern TypeFamily :: () => () => DeclHead -> MaybeTypeFamilySpec -> Decl

-- | Data family declaration (<tt> data family A a :: * -&gt; * </tt>)
pattern DataFamily :: () => () => DeclHead -> MaybeKindConstraint -> Decl

-- | Type family instance declaration (<tt> type instance Fam T = AssignedT
--   </tt>)
pattern TypeInstance :: () => () => InstanceRule -> Type -> Decl

-- | Data instance declaration (<tt> data instance Fam T = Con1 | Con2
--   </tt>)
pattern DataInstance :: () => () => DataOrNewtypeKeyword -> InstanceRule -> ConDeclList -> DerivingList -> Decl

-- | GADT-style data instance declaration (<tt> data instance Fam T where
--   ... </tt>)
pattern GadtDataInstance :: () => () => DataOrNewtypeKeyword -> InstanceRule -> MaybeKindConstraint -> GadtConDeclList -> Decl

-- | A closed type family declaration
pattern ClosedTypeFamily :: () => () => DeclHead -> MaybeTypeFamilySpec -> TypeEqnList -> Decl

-- | Specifies the kind of a type family (<tt> :: * -&gt; * </tt>)
pattern TypeFamilyKindSpec :: () => () => KindConstraint -> TypeFamilySpec

-- | Specifies the injectivity of a type family (<tt> = r | r -&gt; a
--   </tt>)
pattern TypeFamilyInjectivitySpec :: () => () => TyVar -> NameList -> TypeFamilySpec

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
pattern TypeEqn :: () => () => Type -> Type -> TypeEqn

-- | Top-level pragmas
pattern PragmaDecl :: () => () => TopLevelPragma -> Decl

-- | A pragma that introduces source rewrite rules (<tt> {-# RULES
--   "map/map" [2] forall f g xs. map f (map g xs) = map (f.g) xs #-}
--   </tt>)
pattern RulePragma :: () => () => RuleList -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# DEPRECATED f
--   "f will be replaced by g" #-} </tt>)
pattern DeprPragma :: () => () => NameList -> String -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# WARNING
--   unsafePerformIO "you should know what you are doing" #-} </tt>)
pattern WarningPragma :: () => () => NameList -> String -> TopLevelPragma

-- | A pragma that annotates a definition with an arbitrary value (<tt> {-#
--   ANN f 42 #-} </tt>)
pattern AnnPragma :: () => () => AnnotationSubject -> Expr -> TopLevelPragma

-- | A pragma that marks a function for inlining to the compiler (<tt> {-#
--   INLINE thenUs #-} </tt>)
pattern InlinePragma :: () => () => MaybeConlikeAnnot -> MaybePhaseControl -> Name -> TopLevelPragma

-- | A pragma that forbids a function from being inlined by the compiler
--   (<tt> {-# NOINLINE f #-} </tt>)
pattern NoInlinePragma :: () => () => Name -> TopLevelPragma

-- | A pragma that marks a function that it may be inlined by the compiler
--   (<tt> {-# INLINABLE thenUs #-} </tt>)
pattern InlinablePragma :: () => () => MaybePhaseControl -> Name -> TopLevelPragma

-- | A pragma for maintaining line numbers in generated sources (<tt> {-#
--   LINE 123 "somefile" #-} </tt>)
pattern LinePragma :: () => () => Int -> MaybeStringNode -> TopLevelPragma

-- | A pragma that tells the compiler that a polymorph function should be
--   optimized for a given type (<tt> {-# SPECIALISE f :: Int -&gt; b -&gt;
--   b #-} </tt>)
pattern SpecializePragma :: () => () => MaybePhaseControl -> Name -> TypeList -> TopLevelPragma

-- | Marks that the pragma should be applied from a given compile phase
--   (<tt> [2] </tt>)
pattern PhaseControlFrom :: () => () => Integer -> PhaseControl

-- | Marks that the pragma should be applied until a given compile phase
--   (<tt> [~2] </tt>)
pattern PhaseControlUntil :: () => () => Integer -> PhaseControl

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
pattern RewriteRule :: () => () => String -> MaybePhaseControl -> RuleVarList -> Expr -> Expr -> Rule

-- | The definition with the given name is annotated
pattern NameAnnotation :: () => () => Name -> AnnotationSubject

-- | A type with the given name is annotated
pattern TypeAnnotation :: () => () => Name -> AnnotationSubject

-- | The whole module is annotated
pattern ModuleAnnotation :: () => () => AnnotationSubject

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
pattern ConlikeAnnotation :: () => () => ConlikeAnnot

-- | Non-function binding (<tt> v = "12" </tt>)
pattern SimpleBind :: () => () => Pattern -> Rhs -> MaybeLocalBinds -> ValueBind

-- | Function binding (<tt> f 0 = 1; f x = x </tt>). All matches must have
--   the same name.
pattern FunctionBind :: () => () => MatchList -> ValueBind

-- | Clause of function binding
pattern Match :: () => () => MatchLhs -> Rhs -> MaybeLocalBinds -> Match

-- | A match lhs with the function name and parameter names (<tt> f a b
--   </tt>)
pattern MatchLhs :: () => () => Name -> PatternList -> MatchLhs

-- | An infix match lhs for an operator (<tt> a + b </tt>)
pattern InfixLhs :: () => () => Pattern -> Operator -> Pattern -> PatternList -> MatchLhs

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
pattern LocalBinds :: () => () => LocalBindList -> LocalBinds

-- | A local binding for a value
pattern LocalValBind :: () => () => ValueBind -> LocalBind

-- | A local type signature
pattern LocalTypeSig :: () => () => TypeSignature -> LocalBind

-- | A local fixity declaration
pattern LocalFixity :: () => () => FixitySignature -> LocalBind

-- | A type signature (<tt> f :: Int -&gt; Int </tt>)
pattern TypeSignature :: () => () => NameList -> Type -> TypeSignature

-- | A left-associative fixity declaration (<tt> infixl 5 +, - </tt>).
pattern InfixL :: () => () => OperatorList -> FixitySignature

-- | A right-associative fixity declaration (<tt> infixr 5 +, - </tt>).
pattern InfixR :: () => () => OperatorList -> FixitySignature

-- | A non-associative fixity declaration (<tt> infix 5 +, - </tt>).
pattern Infix :: () => () => OperatorList -> FixitySignature

-- | An unguarded right-hand-side (<tt> = 3 </tt>)
pattern UnguardedRhs :: () => () => Expr -> Rhs

-- | An unguarded right-hand-side (<tt> | x == 1 = 3; | otherwise = 4
--   </tt>)
pattern GuardedRhss :: () => () => GuardedRhsList -> Rhs

-- | A guarded right-hand side of a value binding (<tt> | x &gt; 3 = 2
--   </tt>)
pattern GuardedRhs :: () => () => RhsGuardList -> Expr -> GuardedRhs

-- | A bind statement in a pattern guard (<tt> Just v &lt;- x </tt>)
pattern GuardBind :: () => () => Pattern -> Expr -> RhsGuard

-- | A let statement in a pattern guard (<tt> let x = 3 </tt>)
pattern GuardLet :: () => () => LocalBindList -> RhsGuard

-- | An expression to check for a pattern guard
pattern GuardCheck :: () => () => Expr -> RhsGuard

-- | Creates an expression to check for a pattern guard
mkGuardCheck :: Expr -> RhsGuard

-- | Creates a let statement in a pattern guard (<tt> let x = 3 </tt>)
mkGuardLet :: [LocalBind] -> RhsGuard

-- | Creates a bind statement in a pattern guard (<tt> Just v &lt;- x
--   </tt>)
mkGuardBind :: Pattern -> Expr -> RhsGuard

-- | Creates a guarded right-hand side of a value binding (<tt> | x &gt; 3
--   = 2 </tt>)
mkGuardedRhs :: [RhsGuard] -> Expr -> GuardedRhs

-- | Creates an unguarded right-hand-side (<tt> | x == 1 = 3; | otherwise =
--   4 </tt>)
mkGuardedRhss :: [GuardedRhs] -> Rhs

-- | Creates an unguarded right-hand-side (<tt> = 3 </tt>)
mkUnguardedRhs :: Expr -> Rhs

-- | Creates a non-associative fixity declaration (<tt> infix 5 +, -
--   </tt>).
mkInfix :: Int -> Operator -> FixitySignature

-- | Creates a right-associative fixity declaration (<tt> infixr 5 +, -
--   </tt>).
mkInfixR :: Int -> Operator -> FixitySignature

-- | Creates a left-associative fixity declaration (<tt> infixl 5 +, -
--   </tt>).
mkInfixL :: Int -> Operator -> FixitySignature

-- | Creates a type signature (<tt> f :: Int -&gt; Int </tt>)
mkTypeSignature :: Name -> Type -> TypeSignature

-- | Creates a local fixity declaration
mkLocalFixity :: FixitySignature -> LocalBind

-- | Creates a local type signature
mkLocalTypeSig :: TypeSignature -> LocalBind

-- | Creates a local binding for a value
mkLocalValBind :: ValueBind -> LocalBind
mkLocalBinds' :: [LocalBind] -> LocalBinds

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
mkLocalBinds :: [LocalBind] -> MaybeLocalBinds

-- | Creates an infix match lhs for an operator (<tt> a + b </tt>)
mkInfixLhs :: Pattern -> Operator -> Pattern -> [Pattern] -> MatchLhs

-- | Creates a match lhs with the function name and parameter names (<tt> f
--   a b </tt>)
mkMatchLhs :: Name -> [Pattern] -> MatchLhs

-- | Creates a clause of function binding
mkMatch :: MatchLhs -> Rhs -> Maybe LocalBinds -> Match

-- | A simplified function for creating function bindings without local
--   definitions or guards.
mkFunctionBind' :: Name -> [([Pattern], Expr)] -> ValueBind

-- | Creates a function binding (<tt> f 0 = 1; f x = x </tt>). All matches
--   must have the same name.
mkFunctionBind :: [Match] -> ValueBind

-- | Creates a value binding (<tt> v = "12" </tt>).
mkSimpleBind :: Pattern -> Rhs -> Maybe LocalBinds -> ValueBind

-- | A simplified function to generate simple value bindings without local
--   definitions, guards or complex lhs.
mkSimpleBind' :: Name -> Expr -> ValueBind

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
mkConlikeAnnotation :: ConlikeAnnot

-- | The whole module is annotated
mkModuleAnnotation :: AnnotationSubject

-- | A type with the given name is annotated
mkTypeAnnotation :: Name -> AnnotationSubject

-- | The definition with the given name is annotated
mkNameAnnotation :: Name -> AnnotationSubject
mkRuleVar :: Name -> RuleVar

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
mkRewriteRule :: String -> Maybe PhaseControl -> [RuleVar] -> Expr -> Expr -> Rule

-- | Marks that the pragma should be applied until a given compile phase
--   (<tt> [~2] </tt>)
mkPhaseControlUntil :: Integer -> PhaseControl

-- | Marks that the pragma should be applied from a given compile phase
--   (<tt> [2] </tt>)
mkPhaseControlFrom :: Integer -> PhaseControl

-- | A pragma that tells the compiler that a polymorph function should be
--   optimized for a given type (<tt> {-# SPECIALISE f :: Int -&gt; b -&gt;
--   b #-} </tt>)
mkSpecializePragma :: Maybe PhaseControl -> Name -> [Type] -> TopLevelPragma

-- | A pragma for maintaining line numbers in generated sources (<tt> {-#
--   LINE 123 "somefile" #-} </tt>)
mkLinePragma :: Int -> Maybe StringNode -> TopLevelPragma

-- | A pragma that marks a function that it may be inlined by the compiler
--   (<tt> {-# INLINABLE thenUs #-} </tt>)
mkInlinablePragma :: Maybe PhaseControl -> Name -> TopLevelPragma

-- | A pragma that forbids a function from being inlined by the compiler
--   (<tt> {-# NOINLINE f #-} </tt>)
mkNoInlinePragma :: Name -> TopLevelPragma

-- | A pragma that marks a function for inlining to the compiler (<tt> {-#
--   INLINE thenUs #-} </tt>)
mkInlinePragma :: Maybe ConlikeAnnot -> Maybe PhaseControl -> Name -> TopLevelPragma

-- | A pragma that annotates a definition with an arbitrary value (<tt> {-#
--   ANN f 42 #-} </tt>)
mkAnnPragma :: AnnotationSubject -> Expr -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# WARNING
--   unsafePerformIO "you should know what you are doing" #-} </tt>)
mkWarningPragma :: [Name] -> String -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# DEPRECATED f
--   "f will be replaced by g" #-} </tt>)
mkDeprPragma :: [Name] -> String -> TopLevelPragma

-- | A pragma that introduces source rewrite rules (<tt> {-# RULES
--   "map/map" [2] forall f g xs. map f (map g xs) = map (f.g) xs #-}
--   </tt>)
mkRulePragma :: [Rule] -> TopLevelPragma

-- | Creates a top-level pragmas
mkPragmaDecl :: TopLevelPragma -> Decl
mkPatternSignature :: [Name] -> Type -> PatternSignature

-- | Creates a pattern type signature declaration (<tt> pattern Succ :: Int
--   -&gt; Int </tt>)
mkPatternSignatureDecl :: PatternSignature -> Decl

-- | Creates a pattern synonym with the other direction explicitly
--   specified (<tt> &lt;- App "Int" [] where Int = App "Int" [] </tt>)
mkTwoWayPatSyn :: Pattern -> [Match] -> PatSynRhs

-- | Creates a pattern synonym that can be only used for pattenr matching
--   but not for combining (<tt> &lt;- App "Int" [] </tt>)
mkOneWayPatSyn :: Pattern -> PatSynRhs

-- | Creates an automatically two-way pattern synonym (<tt> = App "Int" []
--   </tt>)
mkSymmetricPatSyn :: Pattern -> PatSynRhs

-- | Creates a record-style pattern synonym left-hand side (<tt> Arrow {
--   arrowFrom, arrowTo } </tt>)
mkRecordPatSyn :: Name -> [Name] -> PatSynLhs

-- | Creates an infix pattern synonym left-hand side (<tt> t1 :+: t2 </tt>)
mkInfixPatSyn :: Name -> Operator -> Name -> PatSynLhs

-- | Creates a left hand side of a pattern synonym with a constructor name
--   and arguments (<tt> Arrow t1 t2 </tt>)
mkConPatSyn :: Name -> [Name] -> PatSynLhs

-- | Creates a pattern synonym (<tt> pattern Arrow t1 t2 = App "-&gt;" [t1,
--   t2] </tt>)
mkPatternSynonym :: PatSynLhs -> PatSynRhs -> Decl

-- | Creates a GADT-style data instance declaration (<tt> data instance Fam
--   T where ... </tt>)
mkGadtDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> Maybe KindConstraint -> [GadtConDecl] -> Decl

-- | Creates a data instance declaration (<tt> data instance Fam T = Con1 |
--   Con2 </tt>)
mkDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> [ConDecl] -> [Deriving] -> Decl

-- | Creates a type family instance declaration (<tt> type instance Fam T =
--   AssignedT </tt>)
mkTypeInstance :: InstanceRule -> Type -> Decl

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
mkTypeEqn :: Type -> Type -> TypeEqn

-- | Specifies the injectivity of a type family (<tt> = r | r -&gt; a
--   </tt>)
mkTypeFamilyInjectivitySpec :: TyVar -> [Name] -> TypeFamilySpec

-- | Specifies the kind of a type family (<tt> :: * -&gt; * </tt>)
mkTypeFamilyKindSpec :: KindConstraint -> TypeFamilySpec

-- | Creates a data family declaration (<tt> data family A a :: * -&gt; *
--   </tt>)
mkDataFamily :: DeclHead -> Maybe KindConstraint -> Decl

-- | Creates a closed type family declaration ( <tt>type family F x where F
--   Int = (); F a = Int</tt> )
mkClosedTypeFamily :: DeclHead -> Maybe TypeFamilySpec -> [TypeEqn] -> Decl

-- | Creates a type family declaration ( <tt>type family F x</tt> )
mkTypeFamily :: DeclHead -> Maybe TypeFamilySpec -> Decl

-- | Specifies that the given foreign import is <tt>unsafe</tt>.
mkUnsafe :: Safety

-- | Specifies <tt>capi</tt> calling convention for foreign import/export.
mkCApi :: CallConv

-- | Specifies <tt>ccall</tt> calling convention for foreign import/export.
mkCCall :: CallConv

-- | Specifies <tt>stdcall</tt> calling convention for foreign
--   import/export.
mkStdCall :: CallConv

-- | Creates a foreign export (<tt> foreign export ccall foo :: Int -&gt;
--   IO Int </tt>)
mkForeignExport :: CallConv -> Name -> Type -> Decl

-- | Creates a foreign import (<tt> foreign import foo :: Int -&gt; IO Int
--   </tt>)
mkForeignImport :: CallConv -> Maybe Safety -> Name -> Type -> Decl

-- | Marks a given type parameter as <tt>phantom</tt>.
mkPhantomRole :: Role

-- | Marks a given type parameter as <tt>representational</tt>.
mkRepresentationalRole :: Role

-- | Marks a given type parameter as <tt>nominal</tt>.
mkNominalRole :: Role

-- | Creates a role annotations (<tt> type role Ptr representational </tt>)
mkRoleDecl :: QualifiedName -> [Role] -> Decl

-- | <tt>INCOHERENT</tt> pragma for type instance definitions
mkIncoherentOverlap :: OverlapPragma

-- | <tt>OVERLAPS</tt> pragma for type instance definitions
mkOverlaps :: OverlapPragma

-- | <tt>OVERLAPPING</tt> pragma for type instance definitions
mkOverlapping :: OverlapPragma

-- | <tt>OVERLAPPABLE</tt> pragma for type instance definitions
mkOverlappable :: OverlapPragma

-- | <tt>NO_OVERLAP</tt> pragma for type instance definitions
mkDisableOverlap :: OverlapPragma

-- | <tt>OVERLAP</tt> pragma for type instance definitions
mkEnableOverlap :: OverlapPragma

-- | Specialize instance pragma (no phase selection is allowed) in a type
--   class instance
mkInstanceSpecializePragma :: Type -> InstBodyDecl

-- | An associated data type implemented using GADT style int a type class
--   instance
mkInstanceDataFamilyGADTDef :: DataOrNewtypeKeyword -> InstanceRule -> Maybe KindConstraint -> [GadtConDecl] -> [Deriving] -> InstBodyDecl

-- | An associated data type implementation (<tt> data A X = C1 | C2 </tt>)
--   int a type class instance
mkInstanceDataFamilyDef :: DataOrNewtypeKeyword -> InstanceRule -> [ConDecl] -> [Deriving] -> InstBodyDecl

-- | An associated type definition (<tt> type A X = B </tt>) in a type
--   class instance
mkInstanceTypeFamilyDef :: TypeEqn -> InstBodyDecl

-- | Type signature in instance definition with <tt>InstanceSigs</tt>
mkInstanceTypeSig :: TypeSignature -> InstBodyDecl

-- | A normal declaration (<tt> f x = 12 </tt>) in a type class instance
mkInstanceBind :: ValueBind -> InstBodyDecl

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
mkInstanceBody :: [InstBodyDecl] -> InstBody

-- | Application to one more type as a part of the instance declaration
mkAppInstanceHead :: InstanceHead -> Type -> InstanceHead

-- | Parenthesized instance head as a part of the instance declaration
mkParenInstanceHead :: InstanceHead -> InstanceHead

-- | Infix application of the type/class name to the left operand as a part
--   of the instance declaration
mkInfixInstanceHead :: Type -> Operator -> InstanceHead

-- | Type or class name as a part of the instance declaration
mkInstanceHead :: Name -> InstanceHead

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the where keyword.
mkInstanceRule :: Maybe Context -> InstanceHead -> InstanceRule

-- | Creates a type class instance declaration (<tt> instance X T [where f
--   = ...] </tt>)
mkInstanceDecl :: Maybe OverlapPragma -> InstanceRule -> Maybe InstBody -> Decl

-- | Infix application of the type/class name to the left operand in a
--   declaration head
mkInfixDeclHead :: TyVar -> Operator -> TyVar -> DeclHead

-- | Application in a declaration head
mkDeclHeadApp :: DeclHead -> TyVar -> DeclHead

-- | Parenthesized type as a declaration head
mkParenDeclHead :: DeclHead -> DeclHead

-- | Type or class name as a declaration head
mkNameDeclHead :: Name -> DeclHead

-- | Both of the minimal formulas are needed (<tt> min1 , min2 </tt>)
mkMinimalAnd :: [MinimalFormula] -> MinimalFormula

-- | One of the minimal formulas are needed (<tt> min1 | min2 </tt>)
mkMinimalOr :: [MinimalFormula] -> MinimalFormula
mkMinimalParen :: MinimalFormula -> MinimalFormula
mkMinimalName :: Name -> MinimalFormula

-- | Minimal pragma: <tt> {-# MINIMAL (==) | (/=) #-} </tt> in a class
mkClsMinimal :: MinimalFormula -> ClassElement

-- | Creates a functional dependency, given on the form <tt>l1 ... ln -&gt;
--   r1 ... rn</tt>
mkFunDep :: [Name] -> [Name] -> FunDep

-- | Creates a default signature (by using <tt>DefaultSignatures</tt>) in
--   class: <tt> default enum :: (Generic a, GEnum (Rep a)) =&gt; [a] </tt>
mkClsDefaultSig :: Name -> Type -> ClassElement

-- | Creates a default choice for type synonym in class: <tt> type T x = TE
--   </tt> or <tt> type instance T x = TE </tt>
mkClsDefaultType :: DeclHead -> Type -> ClassElement

-- | Creates an associated data synonym in class: <tt> data T y :: * </tt>
mkClassElemDataFam :: DeclHead -> Maybe KindConstraint -> ClassElement

-- | Creates an associated type synonym in class: <tt> type T y :: * </tt>
mkClassElemTypeFam :: DeclHead -> Maybe TypeFamilySpec -> ClassElement

-- | Creates a default binding as class element: <tt> f x = "aaa" </tt>
mkClassElemDef :: ValueBind -> ClassElement

-- | Creates a type signature as class element: <tt> f :: A -&gt; B </tt>
mkClassElemSig :: TypeSignature -> ClassElement

-- | Creates the list of declarations that can appear in a typeclass
mkClassBody :: [ClassElement] -> ClassBody

-- | Creates a type class declaration (<tt> class X a where f = ... </tt>)
mkClassDecl :: Maybe Context -> DeclHead -> [FunDep] -> Maybe ClassBody -> Decl

-- | The <tt>newtype</tt> keyword in a type definition
mkNewtypeKeyword :: DataOrNewtypeKeyword

-- | The <tt>data</tt> keyword in a type definition
mkDataKeyword :: DataOrNewtypeKeyword

-- | Creates a deriving clause following a data type declaration. (<tt>
--   deriving Show </tt> or <tt> deriving (Show, Eq) </tt>)
mkDeriving :: [InstanceHead] -> Deriving

-- | Creates a field declaration (<tt> fld :: Int </tt>) for a constructor
mkFieldDecl :: [Name] -> Type -> FieldDecl

-- | Creates an infix data constructor (<tt> t1 :+: t2 </tt>)
mkInfixConDecl :: Type -> Operator -> Type -> ConDecl

-- | Creates a record data constructor (<tt> Point { x :: Double, y ::
--   Double } </tt>)
mkRecordConDecl :: Name -> [FieldDecl] -> ConDecl

-- | Creates an ordinary data constructor (<tt> C t1 t2 </tt>)
mkConDecl :: Name -> [Type] -> ConDecl

-- | Creates a GADT constructor declaration with record syntax (<tt> D1 ::
--   { val :: Int } -&gt; T String </tt>)
mkGadtRecordConDecl :: [Name] -> [FieldDecl] -> Type -> GadtConDecl

-- | Creates a GADT constructor declaration (<tt> D1 :: Int -&gt; T String
--   </tt>)
mkGadtConDecl :: [Name] -> Type -> GadtConDecl

-- | Creates a GADT-style data or newtype declaration.
mkGADTDataDecl :: DataOrNewtypeKeyword -> Maybe Context -> DeclHead -> Maybe KindConstraint -> [GadtConDecl] -> [Deriving] -> Decl

-- | Creates a data or newtype declaration.
mkDataDecl :: DataOrNewtypeKeyword -> Maybe Context -> DeclHead -> [ConDecl] -> [Deriving] -> Decl

-- | Creates a Template Haskell splice declaration (<tt> $(generateDecls)
--   </tt>)
mkSpliceDecl :: Splice -> Decl

-- | Creates a function or value binding (<tt> f x = 12 </tt>)
mkValueBinding :: ValueBind -> Decl

-- | Creates type signature declaration (<tt> f :: Int -&gt; Int </tt>)
mkTypeSigDecl :: TypeSignature -> Decl

-- | Creates default types (<tt> default (T1, T2) </tt>)
mkDefaultDecl :: [Type] -> Decl

-- | Creates a fixity declaration (<tt> infixl 5 +, - </tt>)
mkFixityDecl :: FixitySignature -> Decl

-- | Creates a standalone deriving declaration (<tt> deriving instance X T
--   </tt>)
mkStandaloneDeriving :: Maybe DeriveStrategy -> Maybe OverlapPragma -> InstanceRule -> Decl

-- | Creates a type synonym ( <tt>type String = [Char]</tt> )
mkTypeDecl :: DeclHead -> Type -> Decl

-- | A hole expression <tt>_</tt>
mkHole :: Expr

-- | Right arrow high application: <tt>&gt;&gt;-</tt>
mkRightHighAppl :: ArrowApp

-- | Left arrow high application: <tt>-&lt;&lt;</tt>
mkLeftHighAppl :: ArrowApp

-- | Right arrow application: <tt>&gt;-</tt>
mkRightAppl :: ArrowApp

-- | Left arrow application: <tt>-&lt;</tt>
mkLeftAppl :: ArrowApp

-- | A do-notation in a command
mkDoCmd :: [CmdStmt] -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
mkLetCmd :: [LocalBind] -> Cmd -> Cmd

-- | An if command (<tt> if f x y then g -&lt; x+1 else h -&lt; y+2 </tt>)
mkIfCmd :: Expr -> Cmd -> Cmd -> Cmd

-- | A pattern match command
mkCaseCmd :: Expr -> [CmdAlt] -> Cmd

-- | A parenthesized command
mkParenCmd :: Cmd -> Cmd

-- | A lambda command
mkLambdaCmd :: [Pattern] -> Cmd -> Cmd

-- | An infix command application
mkInfixCmd :: Cmd -> Name -> Cmd -> Cmd

-- | A function application command
mkAppCmd :: Cmd -> Expr -> Cmd

-- | A form command (<tt> (|untilA (increment -&lt; x+y) (within 0.5 -&lt;
--   x)|) </tt>)
mkArrowFromCmd :: Expr -> [Cmd] -> Cmd

-- | An arrow application command (<tt> f -&lt; x + 1 </tt>)
mkArrowAppCmd :: Expr -> ArrowApp -> Expr -> Cmd

-- | Create a in-AST source ranges (for generated pragmas)
mkSourceRange :: String -> Integer -> Integer -> Integer -> Integer -> SourceRange

-- | Creates a pragma that describes if an expression was generated from a
--   code fragment by an external tool (<tt> {-# GENERATED "Happy.y"
--   1:15-1:25 #-} </tt>)
mkGeneratedPragma :: SourceRange -> ExprPragma

-- | Creates an <tt>SCC</tt> pragma for defining cost centers for profiling
mkSccPragma :: String -> ExprPragma

-- | Creates a <tt>CORE</tt> pragma for adding notes to expressions.
mkCorePragma :: String -> ExprPragma

-- | Creates a guarded right-hand side of pattern matches binding (<tt> | x
--   &gt; 3 -&gt; 2 </tt>)
mkGuardedCaseRhs :: [RhsGuard] -> Expr -> GuardedCaseRhs

-- | Create a guarded right-hand sides of a pattern match (<tt> | x == 1
--   -&gt; 3; | otherwise -&gt; 4 </tt>)
mkGuardedCaseRhss :: [GuardedCaseRhs] -> CaseRhs

-- | Create a unguarded right-hand side a pattern match (<tt> -&gt; 3
--   </tt>)
mkCaseRhs :: Expr -> CaseRhs

-- | Create a clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
mkAlt :: Pattern -> CaseRhs -> Maybe LocalBinds -> Alt

-- | Create a update the fields of the bounded names to their values (<tt>
--   .. </tt>). Must be the last initializer. Cannot be used in a record
--   update expression.
mkFieldWildcard :: FieldUpdate

-- | Create a update the field to the value of the same name (<tt> x </tt>)
mkFieldPun :: Name -> FieldUpdate

-- | Create a update of a field (<tt> x = 1 </tt>)
mkFieldUpdate :: Name -> Expr -> FieldUpdate

-- | Create a static pointer expression (<tt> static e </tt>). The inner
--   expression must be closed (cannot have variables bound outside)
mkStaticPointer :: Expr -> Expr

-- | Create a lambda case ( <tt>case 0 -&gt; 1; 1 -&gt; 2</tt> )
mkLambdaCase :: [Alt] -> Expr

-- | Create a arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
mkArrowApp :: Expr -> ArrowApp -> Expr -> Expr

-- | Create a arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
mkProcExpr :: Pattern -> Cmd -> Expr

-- | Creates a pragma that marks an expression.
mkExprPragma :: ExprPragma -> Expr -> Expr

-- | Create a template haskell quasi quote expression, for example:
--   <tt>[quoter| a + b ]</tt>
mkQuasiQuoteExpr :: QuasiQuote -> Expr

-- | Create a template haskell splice expression, for example: <tt>$(gen
--   a)</tt> or <tt>$x</tt>
mkSpliceExpr :: Splice -> Expr

-- | Create a template haskell bracket expression
mkBracketExpr :: Bracket -> Expr

-- | <tt>''T</tt> for template haskell reifying of types
mkTypeQuote :: Name -> Expr

-- | <tt>'x</tt> for template haskell reifying of expressions
mkVarQuote :: Name -> Expr

-- | Create a explicit type application (<tt> show @Integer (read "5")
--   </tt>)
mkExplicitTypeApp :: Expr -> Type -> Expr

-- | Create a explicit type signature (<tt> x :: Int </tt>)
mkExprTypeSig :: Expr -> Type -> Expr

-- | Create a parallel array comprehensions <tt> [: (x, y) | x &lt;- xs , y
--   &lt;- ys :] </tt> enabled by <tt>ParallelArrays</tt>
mkParArrayComp :: Expr -> [ListCompBody] -> Expr

-- | Create a list comprehension (<tt> [ (x, y) | x &lt;- xs | y &lt;- ys ]
--   </tt>)
mkListComp :: Expr -> [ListCompBody] -> Expr

-- | Create a parallel array enumeration (<tt> [: 1,3 .. 10 :] </tt>)
mkParArrayEnum :: Expr -> Maybe Expr -> Expr -> Expr

-- | Create a enumeration expression (<tt> [1,3..10] </tt>)
mkEnum :: Expr -> Maybe Expr -> Maybe Expr -> Expr

-- | Create a record value update: <tt>p1 { x = 3, y = -2 }</tt>
mkRecUpdate :: Expr -> [FieldUpdate] -> Expr

-- | Create a record value construction: <tt>Point { x = 3, y = -2 }</tt>
mkRecCon :: Name -> [FieldUpdate] -> Expr

-- | Create a right operator section: <tt>(+1)</tt>
mkRightSection :: Operator -> Expr -> Expr

-- | Create a left operator section: <tt>(1+)</tt>
mkLeftSection :: Expr -> Operator -> Expr

-- | Create a parenthesized expression: <tt>( a + b )</tt>
mkParen :: Expr -> Expr

-- | Create a parallel array expression: <tt>[: 1,2,3 :]</tt>
mkParArray :: [Expr] -> Expr

-- | Create a list expression: <tt>[1,2,3]</tt>
mkList :: [Expr] -> Expr

-- | Create a unboxed tuple section, enabled with <tt>TupleSections</tt>
--   (<tt> (#a,,b#) </tt>). One of the elements must be missing.
mkTupleUnboxedSection :: [Maybe Expr] -> Expr

-- | Create a tuple section, enabled with <tt>TupleSections</tt> (<tt>
--   (a,,b) </tt>). One of the elements must be missing.
mkTupleSection :: [Maybe Expr] -> Expr

-- | Create a unboxed tuple expression (<tt> (# e1, e2, e3 #) </tt>)
mkUnboxedTuple :: [Expr] -> Expr

-- | Create a tuple expression (<tt> (e1, e2, e3) </tt>)
mkTuple :: [Expr] -> Expr

-- | Create a mdo-notation expressions (<tt> mdo x &lt;- act1; act2 </tt>)
mkMDoBlock :: [Stmt] -> Expr

-- | Create a do-notation expressions (<tt> do x &lt;- act1; act2 </tt>)
mkDoBlock :: [Stmt] -> Expr

-- | Create a pattern matching expression (<tt> case expr of pat1 -&gt;
--   expr1; pat2 -&gt; expr2 </tt>)
mkCase :: Expr -> [Alt] -> Expr

-- | Create a multi way if expressions with <tt>MultiWayIf</tt> extension
--   (<tt> if | guard1 -&gt; expr1; guard2 -&gt; expr2 </tt>)
mkMultiIf :: [GuardedCaseRhs] -> Expr

-- | Create a if expression (<tt> if a then b else c </tt>)
mkIf :: Expr -> Expr -> Expr -> Expr

-- | Create a local binding (<tt> let x = 2; y = 3 in e x y </tt>)
mkLet :: [LocalBind] -> Expr -> Expr

-- | Create a lambda expression (<tt> \a b -&gt; a + b </tt>)
mkLambda :: [Pattern] -> Expr -> Expr

-- | Create a function application expression (<tt> f 4 </tt>)
mkApp :: Expr -> Expr -> Expr

-- | Create a prefix operator application expression (<tt> -x </tt>)
mkPrefixApp :: Operator -> Expr -> Expr

-- | Create a infix operator application expression (<tt> a + b </tt>)
mkInfixApp :: Expr -> Operator -> Expr -> Expr

-- | Create a literal expression (<tt> 42 </tt>)
mkLit :: Literal -> Expr

-- | Create a expression for a variable or a data constructor (<tt> a
--   </tt>)
mkVar :: Name -> Expr

-- | Creates a list of assertions (<tt> (Eq a, Show a) </tt>)
mkTupleAssertion :: [Assertion] -> Assertion

-- | Creates an assertion for implicit parameter binding (<tt> ?cmp :: a
--   -&gt; a -&gt; Bool </tt>)
mkImplicitAssert :: Name -> Type -> Assertion

-- | Infix class assertion, also contains type equations (<tt> a ~ X y
--   </tt>)
mkInfixAssert :: Type -> Operator -> Type -> Assertion

-- | Class assertion (<tt>Cls x</tt>)
mkClassAssert :: Name -> [Type] -> Assertion

-- | Creates a context of assertions (<tt> C a =&gt; ... </tt>)
mkContext :: Assertion -> Context

-- | Kind of the unit value <tt>()</tt>.
mkPromotedUnitType :: Type

-- | A tuple of elements as a kind.
mkPromotedTupleType :: [Type] -> Type

-- | A list of elements as a kind.
mkPromotedListType :: [Type] -> Type

-- | A data constructor value promoted to the kind level.
mkPromotedConType :: Name -> Type

-- | String value promoted to the kind level.
mkPromotedStringType :: String -> Type

-- | Numeric value promoted to the kind level.
mkPromotedIntType :: Integer -> Type

-- | A Template Haskell quasi-quote type (<tt> [quoter| ... ] </tt>).
mkQuasiQuoteType :: QuasiQuote -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
mkSpliceType :: Splice -> Type

-- | A named wildcard type (<tt> _t </tt>) with
--   <tt>-XPartialTypeSignatures</tt>
mkNamedWildcardType :: Name -> Type

-- | A wildcard type (<tt> _ </tt>) with <tt>-XPartialTypeSignatures</tt>
mkWildcardType :: Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
mkNoUnpackType :: Type -> Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
mkUnpackType :: Type -> Type

-- | Lazy type marked with <tt>~</tt>. (Should only be used if
--   <tt>Strict</tt> or <tt>StrictData</tt> language extension is used)
mkLazyType :: Type -> Type

-- | Strict type marked with <tt>!</tt>.
mkBangType :: Type -> Type

-- | Type with explicit kind signature (<tt> a :: * </tt>)
mkKindedType :: Type -> Kind -> Type

-- | Type variable or constructor (<tt> a </tt>)
mkVarType :: Name -> Type

-- | Creates a type variable with kind specification (<tt> t :: * </tt>)
mkKindedTypeVar :: Name -> Kind -> TyVar

-- | Creates a simple type variable
mkTypeVar :: Name -> TyVar

-- | Type surrounded by parentheses (<tt> (T a) </tt>)
mkParenType :: Type -> Type

-- | Infix type constructor (<tt> (a &lt;: b) </tt>)
mkInfixTypeApp :: Type -> Operator -> Type -> Type

-- | Type application (<tt> F a </tt>)
mkTypeApp :: Type -> Type -> Type

-- | Parallel array type (<tt> [:a:] </tt>)
mkParArrayType :: Type -> Type

-- | List type with special syntax (<tt> [a] </tt>)
mkListType :: Type -> Type

-- | Unboxed tuple types (<tt> (#a,b#) </tt>)
mkUnboxedTupleType :: [Type] -> Type

-- | Tuple types (<tt> (a,b) </tt>)
mkTupleType :: [Type] -> Type

-- | Function types (<tt> a -&gt; b </tt>)
mkFunctionType :: Type -> Type -> Type

-- | Type with a context (<tt> forall x y . type </tt>)
mkCtxType :: Context -> Type -> Type

-- | Simplified creation of type variables
mkTypeVar' :: Name -> TyVar

-- | Forall types (<tt> forall x y . type </tt>)
mkForallType :: [TyVar] -> Type -> Type

-- | Kind of the unit value <tt>()</tt>.
mkUnitKind :: Kind

-- | A tuple of elements as a kind.
mkTupleKind :: [Kind] -> Kind

-- | A list of elements as a kind.
mkListKind :: [Kind] -> Kind

-- | A data constructor value promoted to the kind level.
mkConKind :: Name -> Kind

-- | String value promoted to the kind level.
mkStringKind :: String -> Kind

-- | Numeric value promoted to the kind level.
mkIntKind :: Integer -> Kind

-- | A list kind (<tt> [k] </tt>)
mkKindList :: Kind -> Kind

-- | Kind application (<tt> k1 k2 </tt>)
mkKindApp :: Kind -> Kind -> Kind

-- | Kind variable (using <tt>PolyKinds</tt> extension)
mkKindVar :: Name -> Kind

-- | A parenthesised kind
mkKindParen :: Kind -> Kind

-- | <tt>-&gt;</tt>, the kind of type constructor
mkKindFun :: Kind -> Kind -> Kind

-- | <tt>#</tt>, the kind of unboxed types
mkKindUnbox :: Kind

-- | <tt>*</tt>, the kind of types
mkKindStar :: Kind

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
mkKindConstraint :: Kind -> KindConstraint

-- | Primitive string literal (of type <tt>Addr#</tt>): <tt>"xxx"#</tt>
mkPrimStringLit :: String -> Literal

-- | Primitive character literal (of type <tt>Char#</tt>):
--   <tt><tt>c</tt>#</tt>
mkPrimCharLit :: Char -> Literal

-- | Primitive double literal (of type <tt>Double#</tt>): <tt>3.14##</tt>
mkPrimDoubleLit :: Rational -> Literal

-- | Primitive float literal (of type <tt>Float#</tt>): <tt>3.14#</tt>
mkPrimFloatLit :: Rational -> Literal

-- | Primitive word literal (of type <tt>Word#</tt>): <tt>32##</tt>
mkPrimWordLit :: Integer -> Literal

-- | Primitive integer literal (of type <tt>Int#</tt>): <tt>32#</tt>
mkPrimIntLit :: Integer -> Literal

-- | Fractional literal: <tt>3.14</tt>
mkFracLit :: Rational -> Literal

-- | Integer literal: <tt>12</tt>
mkIntLit :: Integer -> Literal

-- | String literal: <tt>"abc"</tt>
mkStringLit :: String -> Literal

-- | Character literal: <tt><tt>c</tt></tt>
mkCharLit :: Char -> Literal

-- | A deprecated pragma attached to the module
mkModuleDeprecatedPragma :: [String] -> ModulePragma

-- | A warning pragma attached to the module
mkModuleWarningPragma :: [String] -> ModulePragma

-- | <tt>OPTIONS</tt> pragma, possibly qualified with a tool, e.g.
--   OPTIONS_GHC
mkOptionsGHC :: String -> FilePragma

-- | <tt>LANGUAGE</tt> pragma, listing the enabled language extensions in
--   that file
mkLanguagePragma :: [String] -> FilePragma
mkFilePragmas :: [FilePragma] -> FilePragmaList

-- | The name of a module
mkModuleName :: String -> ModuleName

-- | Restrict the import definition to DONT import the listed names
mkImportHidingList :: [IESpec] -> ImportSpec

-- | Restrict the import definition to ONLY import the listed names
mkImportSpecList :: [IESpec] -> ImportSpec

-- | An import declaration: <tt>import Module.Name</tt>
mkImportDecl :: Bool -> Bool -> Bool -> Maybe String -> ModuleName -> Maybe ModuleName -> Maybe ImportSpec -> ImportDecl

-- | <tt>(..)</tt>: a class exported with all of its methods, or a datatype
--   exported with all of its constructors.
mkSubAll :: SubSpec

-- | <tt>(a,b,c)</tt>: a class exported with some of its methods, or a
--   datatype exported with some of its constructors.
mkSubList :: [Name] -> SubSpec

-- | Marks a pattern synonym to be imported or exported
mkPatternIESpec :: Name -> IESpec

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
mkIESpec :: Name -> Maybe SubSpec -> IESpec

-- | The export of an imported module (<tt> module A </tt>)
mkModuleExport :: ModuleName -> ExportSpec

-- | Export a name and related names
mkExportSpec :: IESpec -> ExportSpec

-- | A list of export specifications surrounded by parentheses
mkExportSpecs :: [ExportSpec] -> ExportSpecs

-- | Module declaration with name and (optional) exports
mkModuleHead :: ModuleName -> Maybe ModulePragma -> Maybe ExportSpecs -> ModuleHead

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
mkModule :: [FilePragma] -> Maybe ModuleHead -> [ImportDecl] -> [Decl] -> Module

-- | Creates a quoted text
mkStringNode :: String -> StringNode

-- | Creates a simple (unqualified) name
mkSimpleName :: String -> QualifiedName

-- | Creates a simple (unqualified) name
mkSimpleName' :: Name -> QualifiedName

-- | Creates a part of a qualified name.
mkNamePart :: String -> NamePart
mkQualifiedName :: [String] -> String -> QualifiedName

-- | Creates an annotated qualified simple name
mkQualifiedName' :: [String] -> Name -> QualifiedName

-- | Creates an implicit name: <tt> ?var </tt>
mkImplicitName :: QualifiedName -> Name

-- | Creates a parenthesized name: <tt> foldl (+) 0 </tt>
mkParenName :: QualifiedName -> Name
mkNormalName :: QualifiedName -> Name

-- | Creates an annotated unqualified (non-operator) binding name:
--   <tt>f</tt> or <tt>(+)</tt>
mkUnqualName' :: Name -> Name

-- | Creates an annotated qualified (non-operator) binding name:
--   <tt>A.B.f</tt> or <tt>(A.B.+)</tt>
mkQualName' :: [String] -> Name -> Name
mkUnqualOp :: String -> Operator

-- | Creates an annotated unqualified operator: <tt>+</tt> or
--   <tt>`mod`</tt>.
mkUnqualOp' :: Name -> Operator

-- | Creates an annotated qualified operator: <tt>A.B.+</tt> or
--   <tt>`A.B.mod`</tt>.
mkQualOp' :: [String] -> Name -> Operator
mkBacktickOp :: [String] -> String -> Operator
mkQualOp :: [String] -> String -> Operator

-- | Creates a simple, unqualified name
mkName :: String -> Name

-- | Wildcard field pattern (<tt> .. </tt>)
mkFieldWildcardPattern :: PatternField

-- | Named field pun (<tt> p </tt>)
mkFieldPunPattern :: Name -> PatternField

-- | Named field pattern (<tt> p = Point 3 2 </tt>)
mkPatternField :: Name -> Pattern -> PatternField

-- | Quasi-quoted patterns: <tt>[| 1 + 2 |]</tt>
mkQuasiQuotePat :: QuasiQuote -> Pattern

-- | Splice patterns: <tt>$(generateX inp)</tt>
mkSplicePat :: Splice -> Pattern

-- | View pattern (<tt> f -&gt; Just 1 </tt>)
mkViewPat :: Expr -> Pattern -> Pattern

-- | Pattern with explicit type signature (<tt> x :: Int </tt>)
mkTypeSigPat :: Pattern -> Type -> Pattern

-- | Bang pattern (<tt> !x </tt>)
mkBangPat :: Pattern -> Pattern

-- | Irrefutable pattern (<tt> ~(x:_) </tt>)
mkIrrefutablePat :: Pattern -> Pattern

-- | Wildcard pattern: (<tt> _ </tt>)
mkWildPat :: Pattern

-- | As-pattern (explicit name binding) (<tt> ls@(hd:_) </tt>)
mkAsPat :: Name -> Pattern -> Pattern

-- | Record pattern (<tt> Point { x = 3, y } </tt>)
mkRecPat :: Name -> [PatternField] -> Pattern

-- | Parenthesised patterns
mkParenPat :: Pattern -> Pattern

-- | Parallel array pattern (<tt> [:1,2,a,x:] </tt>)
mkParArrayPat :: [Pattern] -> Pattern

-- | List pattern (<tt> [1,2,a,x] </tt>)
mkListPat :: [Pattern] -> Pattern

-- | Unboxed tuple pattern (<tt> (# x, y #) </tt>)
mkUnboxTuplePat :: [Pattern] -> Pattern

-- | Tuple pattern (<tt> (x,y) </tt>)
mkTuplePat :: [Pattern] -> Pattern

-- | Constructor application pattern (<tt> Point x y </tt>)
mkAppPat :: Name -> [Pattern] -> Pattern

-- | Infix constructor application pattern (<tt> a :+: b </tt>)
mkInfixAppPat :: Pattern -> Operator -> Pattern -> Pattern

-- | Literal pattern
mkLitPat :: Literal -> Pattern

-- | Pattern name binding
mkVarPat :: Name -> Pattern

-- | Creates a recursive binding command with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
mkRecCmd :: [CmdStmt] -> CmdStmt

-- | Creates a let command (<tt> let x = 3; y = 4 </tt>)
mkLetStmtCmd :: [LocalBind] -> CmdStmt

-- | Creates a non-binding command (<tt> action </tt>)
mkExprCmd :: Cmd -> CmdStmt

-- | Creates a binding command (<tt> x &lt;- action </tt>)
mkBindCmd :: Pattern -> Cmd -> CmdStmt

-- | Grouping statements by <tt>TransformListComp</tt> (<tt> then group by
--   (x + y) using groupWith </tt>)
mkGroupStmt :: Maybe Expr -> Maybe Expr -> CompStmt

-- | Then statements by <tt>TransformListComp</tt> (<tt> then sortWith by
--   (x + y) </tt>)
mkThenStmt :: Expr -> Maybe Expr -> CompStmt

-- | Normal monadic statement of a list comprehension
mkCompStmt :: Stmt -> CompStmt

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
mkListCompBody :: [CompStmt] -> ListCompBody

-- | Creates a recursive binding statement with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
mkRecStmt :: [Stmt] -> Stmt

-- | Creates a let statement (<tt> let x = 3; y = 4 </tt>)
mkLetStmt :: [LocalBind] -> Stmt

-- | Creates a non-binding statement (<tt> action </tt>)
mkExprStmt :: Expr -> Stmt

-- | Creates a binding statement (<tt> x &lt;- action </tt>)
mkBindStmt :: Pattern -> Expr -> Stmt

-- | Declaration bracket (<tt> [d| f :: Int -&gt; Int; f x = x*x |] </tt>)
mkDeclsBracket :: [Decl] -> Bracket

-- | Type bracket (<tt> [t| (Int,Int) |] </tt>)
mkTypeBracket :: Type -> Bracket

-- | Pattern bracket (<tt> [p| Point x y |] </tt>)
mkPatternBracket :: Pattern -> Bracket

-- | Expression bracket (<tt> [| x + y |] </tt>)
mkExprBracket :: Expr -> Bracket

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
mkQuasiQuote :: Name -> String -> QuasiQuote

-- | A splice with parentheses: <tt>$(generate input)</tt>
mkParenSplice :: Expr -> Splice

-- | A simple name splice: <tt>$generateX</tt>
mkIdSplice :: Name -> Splice
type AnnList (node :: Type -> Type -> Type) = AnnListG node IdDom SrcTemplateStage
type AnnMaybe (node :: Type -> Type -> Type) = AnnMaybeG node IdDom SrcTemplateStage

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
type Module = Ann UModule IdDom SrcTemplateStage

-- | Module declaration with name and (optional) exports
type ModuleHead = Ann UModuleHead IdDom SrcTemplateStage

-- | A list of export specifications surrounded by parentheses
type ExportSpecs = Ann UExportSpecs IdDom SrcTemplateStage

-- | Export specifier
type ExportSpec = Ann UExportSpec IdDom SrcTemplateStage

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
type IESpec = Ann UIESpec IdDom SrcTemplateStage

-- | Specifies the imported element
type ImportModifier = Ann UImportModifier IdDom SrcTemplateStage

-- | Marks how related names will be imported or exported with a given name
type SubSpec = Ann USubSpec IdDom SrcTemplateStage

-- | Pragmas that must be used after the module head
type ModulePragma = Ann UModulePragma IdDom SrcTemplateStage

-- | Pragmas that must be used before defining the module
type FilePragma = Ann UFilePragma IdDom SrcTemplateStage

-- | An import declaration: <tt>import Module.Name</tt>
type ImportDecl = Ann UImportDecl IdDom SrcTemplateStage

-- | Restriction on the imported names
type ImportSpec = Ann UImportSpec IdDom SrcTemplateStage

-- | Marks the import as qualified: <tt>qualified</tt>
type ImportQualified = Ann UImportQualified IdDom SrcTemplateStage

-- | Marks the import as source: <tt>{-# SOURCE #-}</tt>
type ImportSource = Ann UImportSource IdDom SrcTemplateStage

-- | Marks the import as safe: <tt>safe</tt>
type ImportSafe = Ann UImportSafe IdDom SrcTemplateStage

-- | Marks an imported name to belong to the type namespace: <tt>type</tt>
type TypeNamespace = Ann UTypeNamespace IdDom SrcTemplateStage

-- | Renaming imports (<tt> as A </tt>)
type ImportRenaming = Ann UImportRenaming IdDom SrcTemplateStage

-- | The name of a module
type ModuleName = Ann UModuleName IdDom SrcTemplateStage

-- | The name of the enabled language extension, for example (<tt>
--   LambdaCase </tt>)
type LanguageExtension = Ann ULanguageExtension IdDom SrcTemplateStage

-- | Haskell declaration
type Decl = Ann UDecl IdDom SrcTemplateStage

-- | The list of declarations that can appear in a typeclass
type ClassBody = Ann UClassBody IdDom SrcTemplateStage

-- | Members of a class declaration
type ClassElement = Ann UClassElement IdDom SrcTemplateStage
type DeclHead = Ann UDeclHead IdDom SrcTemplateStage

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
type InstBody = Ann UInstBody IdDom SrcTemplateStage

-- | Declarations inside an instance declaration.
type InstBodyDecl = Ann UInstBodyDecl IdDom SrcTemplateStage

-- | GADT constructor declaration (<tt> D1 :: { val :: Int } -&gt; T String
--   </tt>)
type GadtConDecl = Ann UGadtConDecl IdDom SrcTemplateStage

-- | Type of GADT constructors (can be record types: <tt>{ val :: Int
--   }</tt>)
type GadtConType = Ann UGadtConType IdDom SrcTemplateStage

-- | Marker for a field wildcard. Only needed to attach semantic
--   information in a type-safe way.
type FieldWildcard = Ann UFieldWildcard IdDom SrcTemplateStage

-- | A list of functional dependencies: <tt> | a -&gt; b, c -&gt; d </tt>
--   separated by commas
type FunDeps = Ann UFunDeps IdDom SrcTemplateStage

-- | A functional dependency, given on the form <tt>l1 ... ln -&gt; r1 ...
--   rn</tt>
type FunDep = Ann UFunDep IdDom SrcTemplateStage

-- | A constructor declaration for a datatype
type ConDecl = Ann UConDecl IdDom SrcTemplateStage

-- | The <tt>data</tt> or the <tt>newtype</tt> keyword to define ADTs.
type DataOrNewtypeKeyword = Ann UDataOrNewtypeKeyword IdDom SrcTemplateStage

-- | Field declaration (<tt> fld :: Int </tt>)
type FieldDecl = Ann UFieldDecl IdDom SrcTemplateStage

-- | A deriving clause following a data type declaration. (<tt> deriving
--   Show </tt> or <tt> deriving (Show, Eq) </tt>)
type Deriving = Ann UDeriving IdDom SrcTemplateStage

-- | A deriving strategy (<tt>stock</tt>, <tt>newtype</tt> or
--   <tt>anyclass</tt>)
type DeriveStrategy = Ann UDeriveStrategy IdDom SrcTemplateStage

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the where keyword.
type InstanceRule = Ann UInstanceRule IdDom SrcTemplateStage

-- | The specification of the class instance declaration
type InstanceHead = Ann UInstanceHead IdDom SrcTemplateStage

-- | Specialize pragma (<tt> {--} </tt>)
type SpecializePragma = Ann USpecializePragma IdDom SrcTemplateStage

-- | Overlap pragmas. Can be applied to class declarations and class
--   instance declarations.
type OverlapPragma = Ann UOverlapPragma IdDom SrcTemplateStage

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
type TypeEqn = Ann UTypeEqn IdDom SrcTemplateStage

-- | Top level pragmas
type TopLevelPragma = Ann UTopLevelPragma IdDom SrcTemplateStage

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
type Rule = Ann URule IdDom SrcTemplateStage

-- | A variable for a rewrite rule. With or without type signature.
type RuleVar = Ann URuleVar IdDom SrcTemplateStage

-- | Annotation allows you to connect an expression to any declaration.
type AnnotationSubject = Ann UAnnotationSubject IdDom SrcTemplateStage

-- | Formulas of minimal annotations declaring which functions should be
--   defined.
type MinimalFormula = Ann UMinimalFormula IdDom SrcTemplateStage

-- | In-AST source ranges (for generated pragmas)
type SourceRange = Ann USourceRange IdDom SrcTemplateStage

-- | Open type and data families
type TypeFamily = Ann UTypeFamily IdDom SrcTemplateStage

-- | Type family specification with kinds specification and injectivity.
type TypeFamilySpec = Ann UTypeFamilySpec IdDom SrcTemplateStage

-- | Injectivity annotation for type families (<tt> = r | r -&gt; a </tt>)
type InjectivityAnn = Ann UInjectivityAnn IdDom SrcTemplateStage

-- | Pattern synonyms: <tt> pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
--   </tt>
type PatternSynonym = Ann UPatternSynonym IdDom SrcTemplateStage

-- | Right-hand side of pattern synonym
type PatSynRhs = Ann UPatSynRhs IdDom SrcTemplateStage

-- | Left hand side of a pattern synonym
type PatSynLhs = Ann UPatSynLhs IdDom SrcTemplateStage

-- | Where clause of pattern synonym (explicit expression direction)
type PatSynWhere = Ann UPatSynWhere IdDom SrcTemplateStage

-- | Pattern type signature declaration (<tt> pattern Succ :: Int -&gt; Int
--   </tt>)
type PatternSignature = Ann UPatternTypeSignature IdDom SrcTemplateStage

-- | Role annotations for types
type Role = Ann URole IdDom SrcTemplateStage

-- | Call conventions of foreign functions
type CallConv = Ann UCallConv IdDom SrcTemplateStage

-- | Safety annotations for foreign calls
type Safety = Ann USafety IdDom SrcTemplateStage

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
type ConlikeAnnot = Ann UConlikeAnnot IdDom SrcTemplateStage

-- | Controls the activation of a rewrite rule (<tt> [1] </tt>)
type PhaseControl = Ann UPhaseControl IdDom SrcTemplateStage

-- | Value binding for top-level and local bindings
type ValueBind = Ann UValueBind IdDom SrcTemplateStage

-- | Clause of function binding
type Match = Ann UMatch IdDom SrcTemplateStage

-- | Something on the left side of the match
type MatchLhs = Ann UMatchLhs IdDom SrcTemplateStage

-- | Right hand side of a value binding (possible with guards): (<tt> = 3
--   </tt> or <tt> | x == 1 = 3; | otherwise = 4 </tt>)
type Rhs = Ann URhs IdDom SrcTemplateStage

-- | A guarded right-hand side of a value binding (<tt> | x &gt; 3 = 2
--   </tt>)
type GuardedRhs = Ann UGuardedRhs IdDom SrcTemplateStage

-- | Guards for value bindings and pattern matches (<tt> Just v <a>x, v</a>
--   1 </tt>)
type RhsGuard = Ann URhsGuard IdDom SrcTemplateStage

-- | Bindings that are enabled in local blocks (where or let).
type LocalBind = Ann ULocalBind IdDom SrcTemplateStage

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
type LocalBinds = Ann ULocalBinds IdDom SrcTemplateStage

-- | A fixity signature (<tt> infixl 5 +, - </tt>).
type FixitySignature = Ann UFixitySignature IdDom SrcTemplateStage

-- | A type signature (<tt> f :: Int -&gt; Int </tt>)
type TypeSignature = Ann UTypeSignature IdDom SrcTemplateStage

-- | Haskell types
type Type = Ann UType IdDom SrcTemplateStage

-- | Type variable declarations (with possible kind annotation)
type TyVar = Ann UTyVar IdDom SrcTemplateStage
type Context = Ann UContext IdDom SrcTemplateStage

-- | A single assertion in the context
type Assertion = Ann UAssertion IdDom SrcTemplateStage

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
type KindConstraint = Ann UKindConstraint IdDom SrcTemplateStage

-- | Haskell kinds
type Kind = Ann UKind IdDom SrcTemplateStage

-- | Values promoted to the kind level
type PromotedKind = Ann UPromoted UKind IdDom SrcTemplateStage

-- | Haskell expressions
type Expr = Ann UExpr IdDom SrcTemplateStage

-- | Clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
type Alt = Ann UAlt IdDom SrcTemplateStage

-- | Right hand side of a match (possible with guards): (<tt> -&gt; 3 </tt>
--   or <tt> | x == 1 -&gt; 3; | otherwise -&gt; 4 </tt>)
type CaseRhs = Ann UCaseRhs IdDom SrcTemplateStage

-- | A guarded right-hand side of pattern matches binding (<tt> | x &gt; 3
--   -&gt; 2 </tt>)
type GuardedCaseRhs = Ann UGuardedCaseRhs IdDom SrcTemplateStage

-- | Field update expressions
type FieldUpdate = Ann UFieldUpdate IdDom SrcTemplateStage

-- | An element of a tuple section that can be an expression or missing
--   (indicating a value from a parameter)
type TupSecElem = Ann UTupSecElem IdDom SrcTemplateStage

-- | Pragmas that can be applied to expressions
type ExprPragma = Ann UExprPragma IdDom SrcTemplateStage

-- | Special expressions for arrows
type Cmd = Ann UCmd IdDom SrcTemplateStage

-- | Clause of case expression for commands
type CmdAlt = Ann UCmdAlt IdDom SrcTemplateStage

-- | Arrow directions
type ArrowApp = Ann UArrowAppl IdDom SrcTemplateStage

-- | A statement in a do-notation
type Stmt = Ann UStmt IdDom SrcTemplateStage

-- | Keywords <tt>do</tt> or <tt>mdo</tt> to start a do-block
type DoKind = Ann UDoKind IdDom SrcTemplateStage

-- | List comprehension statement
type CompStmt = Ann UCompStmt IdDom SrcTemplateStage

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
type ListCompBody = Ann UListCompBody IdDom SrcTemplateStage

-- | A do-notation for arrows
type CmdStmt = Ann UCmdStmt IdDom SrcTemplateStage

-- | Representation of patterns for pattern bindings
type Pattern = Ann UPattern IdDom SrcTemplateStage
type PatternField = Ann UPatternField IdDom SrcTemplateStage

-- | A template haskell splice
type Splice = Ann USplice IdDom SrcTemplateStage

-- | Template Haskell bracket expressions
type Bracket = Ann UBracket IdDom SrcTemplateStage

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
type QuasiQuote = Ann UQuasiQuote IdDom SrcTemplateStage

-- | Haskell literals
type Literal = Ann ULiteral IdDom SrcTemplateStage

-- | A definition that functions as an operator
type Operator = Ann UOperator IdDom SrcTemplateStage

-- | A definition that functions as a name
type Name = Ann UName IdDom SrcTemplateStage

-- | Possible qualified names. Contains also implicit names. Linear
--   implicit parameter: <tt>%x</tt>. Non-linear implicit parameter:
--   <tt>?x</tt>.
type QualifiedName = Ann UQualifiedName IdDom SrcTemplateStage

-- | Parts of a qualified name.
type NamePart = Ann UNamePart IdDom SrcTemplateStage

-- | Program elements formatted as string literals (import packages, pragma
--   texts)
type StringNode = Ann UStringNode IdDom SrcTemplateStage
type MaybeContext = AnnMaybe UContext
type MaybeDeriving = AnnMaybe UDeriving
type MaybeDeriveStrategy = AnnMaybe UDeriveStrategy
type MaybeLocalBinds = AnnMaybe ULocalBinds
type MaybeTypeFamilySpec = AnnMaybe UTypeFamilySpec
type MaybeKindConstraint = AnnMaybe UKindConstraint
type MaybeClassBody = AnnMaybe UClassBody
type MaybeInstBody = AnnMaybe UInstBody
type MaybeExpr = AnnMaybe UExpr
type MaybeExportSpecs = AnnMaybe UExportSpecs
type MaybeImportQualified = AnnMaybe UImportQualified
type MaybeImportSource = AnnMaybe UImportSource
type MaybeImportSafe = AnnMaybe UImportSafe
type MaybeImportSpec = AnnMaybe UImportSpec
type MaybeModuleHead = AnnMaybe UModuleHead
type MaybeImportModifier = AnnMaybe UImportModifier
type MaybeModulePragma = AnnMaybe UModulePragma
type MaybeSubSpec = AnnMaybe USubSpec
type MaybeStringNode = AnnMaybe UStringNode
type MaybeImportRenaming = AnnMaybe UImportRenaming
type MaybeSafety = AnnMaybe USafety
type MaybePhaseControl = AnnMaybe UPhaseControl
type MaybeConlikeAnnot = AnnMaybe UConlikeAnnot
type MaybeFunDeps = AnnMaybe UFunDeps
type MatchList = AnnList UMatch
type DeclList = AnnList UDecl
type PatternList = AnnList UPattern
type OperatorList = AnnList UOperator
type NameList = AnnList UName
type LocalBindList = AnnList ULocalBind
type IESpecList = AnnList UIESpec
type RhsGuardList = AnnList URhsGuard
type GuardedRhsList = AnnList UGuardedRhs
type GuardedCaseRhsList = AnnList UGuardedCaseRhs
type ConDeclList = AnnList UConDecl
type TypeEqnList = AnnList UTypeEqn
type TypeList = AnnList UType
type FieldDeclList = AnnList UFieldDecl
type ExprList = AnnList UExpr
type FieldUpdateList = AnnList UFieldUpdate
type GadtConDeclList = AnnList UGadtConDecl
type ClassElementList = AnnList UClassElement
type InstBodyDeclList = AnnList UInstBodyDecl
type InstanceHeadList = AnnList UInstanceHead
type AltList = AnnList UAlt
type StmtList = AnnList UStmt
type KindList = AnnList UKind
type TyVarList = AnnList UTyVar
type ListCompBodyList = AnnList UListCompBody
type ExportSpecList = AnnList UExportSpec
type FilePragmaList = AnnList UFilePragma
type ImportDeclList = AnnList UImportDecl
type PatternFieldList = AnnList UPatternField
type AssertionList = AnnList UAssertion
type CompStmtList = AnnList UCompStmt
type RuleList = AnnList URule
type RuleVarList = AnnList URuleVar
type RoleList = AnnList URole
type MinimalFormulaList = AnnList UMinimalFormula
type FunDepList = AnnList UFunDep
type TupSecElemList = AnnList UTupSecElem
type CmdList = AnnList UCmd
type CmdAltList = AnnList UCmdAlt
type CmdStmtList = AnnList UCmdStmt
type LanguageExtensionList = AnnList ULanguageExtension
type StringNodeList = AnnList UStringNode
type NamePartList = AnnList UNamePart
type DerivingList = AnnList UDeriving

-- | Exceptions that can occur while loading modules or during internal
--   operations (not during performing the refactor).
data RefactorException
IllegalExtensions :: [String] -> RefactorException
SourceCodeProblem :: ErrorMessages -> RefactorException
UnknownException :: String -> RefactorException

-- | Change in the project, modification or removal of a module.
data RefactorChange
ContentChanged :: ModuleDom -> RefactorChange
[fromContentChanged] :: RefactorChange -> ModuleDom
ModuleRemoved :: String -> RefactorChange
[removedModuleName] :: RefactorChange -> String
ModuleCreated :: String -> UnnamedModule -> SourceFileKey -> RefactorChange
[createdModuleName] :: RefactorChange -> String
[createdModuleContent] :: RefactorChange -> UnnamedModule
[sameLocation] :: RefactorChange -> SourceFileKey

-- | Module name and marker to separate .hs-boot module definitions.
--   Specifies a source file in a working directory.
data SourceFileKey
SourceFileKey :: FilePath -> String -> SourceFileKey
[_sfkFileName] :: SourceFileKey -> FilePath
[_sfkModuleName] :: SourceFileKey -> String

-- | The name of the module and the AST
type ModuleDom = (SourceFileKey, UnnamedModule)

-- | A type for the input and result of refactoring a module
type UnnamedModule = Ann UModule IdDom SrcTemplateStage

-- | Transforms module name to a .hs file name relative to the source root
--   directory.
moduleSourceFile :: String -> FilePath

-- | Transforms a source root relative file name into module name.
sourceFileModule :: FilePath -> String
sfkFileName :: Lens SourceFileKey SourceFileKey FilePath FilePath
sfkModuleName :: Lens SourceFileKey SourceFileKey String String

-- | The information a refactoring can use
data RefactorCtx
RefactorCtx :: Module -> Ann UModule IdDom SrcTemplateStage -> [Ann UImportDecl IdDom SrcTemplateStage] -> RefactorCtx

-- | The name of the module being refactored. Used for accessing implicit
--   imports.
[refModuleName] :: RefactorCtx -> Module
[refCtxRoot] :: RefactorCtx -> Ann UModule IdDom SrcTemplateStage
[refCtxImports] :: RefactorCtx -> [Ann UImportDecl IdDom SrcTemplateStage]

-- | Input and output information for the refactoring TODO: use multiple
--   states instead of Either
newtype LocalRefactorT m a
LocalRefactorT :: WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a -> LocalRefactorT m a
[fromRefactorT] :: LocalRefactorT m a -> WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a

-- | The refactoring monad for the whole project
type Refactor = ExceptT String Ghc

-- | The refactoring monad for a given module
type LocalRefactor = LocalRefactorT Refactor

-- | The type of a refactoring that affects the whole project.
type ProjectRefactoring = [ModuleDom] -> Refactor [RefactorChange]

-- | The type of a refactoring
type Refactoring = ModuleDom -> [ModuleDom] -> Refactor [RefactorChange]

-- | A refactoring that only affects one module
type LocalRefactoring = UnnamedModule -> LocalRefactor UnnamedModule

-- | A monad that can be used to refactor
class Monad m => RefactorMonad m
refactError :: RefactorMonad m => String -> m a
liftGhc :: RefactorMonad m => Ghc a -> m a

-- | A type class for handling definitions that can appear as both
--   top-level and local definitions
class NamedElement d => BindingElem d

-- | Accesses a type signature definition in a local or top-level
--   definition
sigBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) TypeSignature

-- | Accesses a value or function definition in a local or top-level
--   definition
valBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) ValueBind

-- | Accesses a type signature definition in a local or top-level
--   definition
fixitySig :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) FixitySignature

-- | Creates a new definition from a type signature
createTypeSig :: BindingElem d => TypeSignature -> Ann d IdDom SrcTemplateStage

-- | Creates a new definition from a value or function definition
createBinding :: BindingElem d => ValueBind -> Ann d IdDom SrcTemplateStage

-- | Creates a new fixity signature
createFixitySig :: BindingElem d => FixitySignature -> Ann d IdDom SrcTemplateStage

-- | Checks if a given definition is a type signature
isTypeSig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a function or value binding
isBinding :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a fixity signature
isFixitySig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool
getValBindInList :: BindingElem d => RealSrcSpan -> AnnList d -> Maybe ValueBind
valBindsInList :: BindingElem d => Simple Traversal (AnnList d) ValueBind
debugM :: (Monad m, Show a) => m a -> m a
debug :: Show a => a -> a

-- | Displays True iff the wrapped value is a Just
debugMaybeT :: Monad m => MaybeT m a -> MaybeT m a
showOutputable :: Outputable a => a -> String
showName :: Name -> String
showOp :: Operator -> String

-- | Set the minimal indentation recursively for a part of the AST
setMinimalIndent :: SourceInfoTraversal elem => Int -> elem dom SrcTemplateStage -> elem dom SrcTemplateStage

-- | Filters the elements of the list. By default it removes the separator
--   before the element. Of course, if the first element is removed, the
--   following separator is removed as well.
filterList :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e
filterListIndexed :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e

-- | A version of filterList that cares about keeping non-removable code
--   elements (like preprocessor pragmas)
filterListSt :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | A version of filterListIndexed that cares about keeping non-removable
--   code elements (like preprocessor pragmas)
filterListIndexedSt :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | Selects the given indices from a list
sublist :: [Int] -> [a] -> [a]

-- | Selects all but the given indices from a list
notSublist :: [Int] -> [a] -> [a]

-- | Inserts the element in the places where the two positioning functions
--   (one checks the element before, one the element after) allows the
--   placement.
insertWhere :: Bool -> Ann e IdDom SrcTemplateStage -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> AnnList e -> AnnList e

-- | Checks where the element will be inserted given the two positioning
--   functions.
insertIndex :: (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> [Ann e IdDom SrcTemplateStage] -> Maybe Int

-- | Gets the elements and separators from a list. The first separator is
--   zipped to the second element. To the first element, the "" string is
--   zipped.
zipWithSeparators :: AnnList e -> [(([SourceTemplateTextElem], SrcSpan), Ann e IdDom SrcTemplateStage)]
replaceWithJust :: Ann e IdDom SrcTemplateStage -> AnnMaybe e -> AnnMaybe e
replaceWithNothing :: AnnMaybe e -> AnnMaybe e

-- | Remove the container (where or let) when the last binding is removed.
removeEmptyBnds :: Simple Traversal Module ValueBind -> Simple Traversal Module Expr -> Module -> Module

-- | Puts the elements in the orginal order and remove duplicates (elements
--   with the same source range)
normalizeElements :: [Ann e dom SrcTemplateStage] -> [Ann e dom SrcTemplateStage]

-- | Groups elements together into equivalence groups.
groupElemsBy :: Ord k => (a -> k) -> [a] -> [[a]]

-- | Chooses a representative element for each equivalence group, and pairs
--   them with their corresponding group.
reprElems :: [[a]] -> [(a, [a])]

-- | Sorts the elements of a list into equivalence groups based on a
--   function, then chooses a representative element for each group, and
--   pairs them with their corresponding group.
equivalenceGroupsBy :: Ord k => (a -> k) -> [a] -> [(a, [a])]
isJustT :: Monad m => MaybeT m a -> m Bool
isNothingT :: Monad m => MaybeT m a -> m Bool
liftMaybe :: Monad m => Maybe a -> MaybeT m a
fromMaybeT :: Monad m => a -> MaybeT m a -> m a
fromMaybeTM :: Monad m => m a -> MaybeT m a -> m a
maybeT :: Monad m => b -> (a -> b) -> MaybeT m a -> m b
maybeTM :: Monad m => m b -> (a -> m b) -> MaybeT m a -> m b

-- | Performs the given refactoring, transforming it into a Ghc action
runRefactor :: ModuleDom -> [ModuleDom] -> Refactoring -> Ghc (Either String [RefactorChange])

-- | Wraps a refactoring that only affects one module. Performs the
--   per-module finishing touches.
localRefactoring :: LocalRefactoring -> Refactoring

-- | Transform the result of the local refactoring
localRefactoringRes :: ((UnnamedModule -> UnnamedModule) -> a -> a) -> UnnamedModule -> LocalRefactor a -> Refactor a

-- | Re-inserts the elements removed from the AST that should be kept (for
--   example preprocessor directives)
insertText :: SourceInfoTraversal p => [(SrcSpan, String, String)] -> p dom SrcTemplateStage -> p dom SrcTemplateStage

-- | Adds the imports that bring names into scope that are needed by the
--   refactoring
addGeneratedImports :: [Name] -> Module -> Module
registeredNamesFromPrelude :: [Name]
otherNamesFromPrelude :: [String]
qualifiedName :: Name -> String
referenceName :: Name -> LocalRefactor (Ann UName IdDom SrcTemplateStage)
referenceOperator :: Name -> LocalRefactor (Ann UOperator IdDom SrcTemplateStage)

-- | Create a name that references the definition. Generates an import if
--   the definition is not yet imported.
referenceName' :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> LocalRefactor (Ann nt IdDom SrcTemplateStage)

-- | Reference the name by the shortest suitable import
referenceBy :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> [Ann UImportDecl IdDom SrcTemplateStage] -> Ann nt IdDom SrcTemplateStage
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension

-- | The final version of our AST, with type infromation added
type TypedModule = Ann UModule IdDom SrcTemplateStage

-- | A quick function to try the refactorings
tryRefactor :: (RealSrcSpan -> Refactoring) -> String -> ModuleName -> IO ()

-- | Adjust the source range to be applied to the refactored module
correctRefactorSpan :: UnnamedModule -> RealSrcSpan -> RealSrcSpan

-- | Set the given flags for the GHC session. Also gives back a change
--   function that you can use to apply the settings to any flags. Prints
--   out errors and warnings
useFlags :: [String] -> Ghc ([String], DynFlags -> DynFlags)
pprWarning :: Warn -> SDoc
pprErr :: Err -> SDoc

-- | Reloads the package database based on the session flags
reloadPkgDb :: Ghc ()

-- | Initialize GHC flags to default values that support refactoring
initGhcFlags :: Ghc ()
initGhcFlagsForTest :: Ghc ()

-- | Sets up basic flags and settings for GHC
initGhcFlags' :: Bool -> Bool -> Ghc ()

-- | Use the given source directories when searching for imported modules
useDirs :: [FilePath] -> Ghc ()

-- | Don't use the given source directories when searching for imported
--   modules
deregisterDirs :: [FilePath] -> Ghc ()

-- | Translates module name and working directory into the name of the file
--   where the given module should be defined
toFileName :: FilePath -> ModuleName -> FilePath

-- | Translates module name and working directory into the name of the file
--   where the boot module should be defined
toBootFileName :: FilePath -> ModuleName -> FilePath

-- | Get the source directory where the module is located.
getSourceDir :: ModSummary -> IO FilePath

-- | Gets the path to the source file of the module.
getModSumOrig :: ModSummary -> FilePath
keyFromMS :: ModSummary -> SourceFileKey

-- | Gets the module name
getModSumName :: ModSummary -> String

-- | Load the AST of a module given by the working directory and module
--   name.
loadModuleAST :: FilePath -> ModuleName -> Ghc TypedModule

-- | Load the summary of a module given by the working directory and module
--   name.
loadModule :: FilePath -> ModuleName -> Ghc ModSummary

-- | Get the typed representation of a Haskell module.
parseTyped :: ModSummary -> Ghc TypedModule
trfProblem :: String -> a

-- | Modifies the dynamic flags for performing a ghc task
withAlteredDynFlags :: GhcMonad m => (DynFlags -> m DynFlags) -> m a -> m a

-- | Forces the code generation for a given module
forceCodeGen :: ModSummary -> ModSummary
codeGenDfs :: DynFlags -> DynFlags

-- | Forces ASM code generation for a given module
forceAsmGen :: ModSummary -> ModSummary

-- | Normalizes the flags for a module summary
modSumNormalizeFlags :: ModSummary -> ModSummary

-- | Removes all flags that are unintelligable for refactoring
normalizeFlags :: DynFlags -> DynFlags

-- | Read a source range from our textual format:
--   <tt>line:col-line:col</tt> or <tt>line:col</tt>
readSrcSpan :: String -> RealSrcSpan

-- | Read a source location from our format: <tt>line:col</tt>
readSrcLoc :: String -> RealSrcLoc

-- | The signature and behavior of one refactoring that can be executed.
data RefactoringChoice
NamingRefactoring :: String -> (RealSrcSpan -> String -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoring] :: RefactoringChoice -> RealSrcSpan -> String -> Refactoring
NamingRefactoringIndent :: String -> (RealSrcSpan -> String -> Maybe String -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoringIndent] :: RefactoringChoice -> RealSrcSpan -> String -> Maybe String -> Refactoring
SelectionRefactoring :: String -> (RealSrcSpan -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[selectionRefactoring] :: RefactoringChoice -> RealSrcSpan -> Refactoring
ModuleRefactoring :: String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[moduleRefactoring] :: RefactoringChoice -> Refactoring
ProjectRefactoring :: String -> ProjectRefactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[projectRefactoring] :: RefactoringChoice -> ProjectRefactoring

-- | Executes a given command (choosen from the set of available
--   refactorings) on the selected module and given other modules.
performCommand :: [RefactoringChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String [RefactorChange])

-- | Gets the name of possible refactorings.
refactorCommands :: [RefactoringChoice] -> [String]
data Severity
Error :: Severity
Warning :: Severity
Info :: Severity
data Marker
Marker :: SrcSpan -> Severity -> String -> Marker
[location] :: Marker -> SrcSpan
[severity] :: Marker -> Severity
[message] :: Marker -> String
data QueryChoice
LocationQuery :: String -> (RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue) -> QueryChoice
[queryName] :: QueryChoice -> String
[locationQuery] :: QueryChoice -> RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
GlobalQuery :: String -> (ModuleDom -> [ModuleDom] -> QueryMonad QueryValue) -> QueryChoice
[queryName] :: QueryChoice -> String
[globalQuery] :: QueryChoice -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
data QueryValue
GeneralQuery :: Value -> QueryValue
MarkerQuery :: [Marker] -> QueryValue
type QueryMonad = ExceptT String Ghc
type QueryType = String
decompQuery :: QueryValue -> (QueryType, Value)
queryCommands :: [QueryChoice] -> [String]
queryError :: String -> QueryMonad a
performQuery :: [QueryChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String (QueryType, Value))

-- | Different classes of definitions that have different kind of names.
data NameClass

-- | Normal value definitions: functions, variables
Variable :: NameClass

-- | Data constructors
Ctor :: NameClass

-- | Functions with operator-like names
ValueOperator :: NameClass

-- | Constructors with operator-like names
DataCtorOperator :: NameClass

-- | UType definitions with operator-like names
SynonymOperator :: NameClass

-- | Get which category does a given name belong to
classifyName :: RefactorMonad m => Name -> m NameClass

-- | Checks if a given name is a valid module name
validModuleName :: String -> Maybe String

-- | Check if a given name is valid for a given kind of definition
nameValid :: NameClass -> String -> Maybe String
isIdChar :: Char -> Bool
isOperatorChar :: Char -> Bool
opSemName :: Operator -> Maybe Name
declHeadQName :: DeclHead -> QualifiedName
declHeadSemName :: DeclHead -> Maybe Name
instHeadSemName :: InstanceHead -> Maybe Name

-- | Collects the qualified names of the class heads in an assertion.
assertionQNames :: Assertion -> [QualifiedName]

-- | Collects the semantic names of the class heads in an assertion.
assertionSemNames :: Assertion -> [Name]

-- | Extracts the name of a type. In case of a type application, it finds
--   the type being applied. It works only for unambiguous types, so it
--   won't work for tuples.
nameFromType :: Type -> Maybe Name
typeExpr :: Expr -> Ghc Type
literalType :: Literal -> Ghc Type
appTypeMatches :: [ClsInst] -> Type -> [Type] -> Maybe (TCvSubst, Type)
type ClosedTyFam = CoAxiom Branched
hasConstraintKind :: Type -> Bool

-- | Looks up the Type of an entity with an Id of any locality. If the
--   entity being scrutinised is a type variable, it fails.
lookupTypeFromId :: (HasIdInfo' id, GhcMonad m) => id -> MaybeT m Type

-- | Looks up the Type or the Kind of an entity that has an Id. Note: In
--   some cases we only get the Kind of the Id (e.g. for type constructors)
typeOrKindFromId :: HasIdInfo' id => id -> Type

-- | Extracts a Type from a TyThing when possible.
typeFromTyThing :: TyThing -> Maybe Type

-- | Looks up a GHC Type from a Haskell Tools Name (given the name is
--   global) For an identifier, it returns its type. For a data
--   constructor, it returns its type. For a pattern synonym, it returns
--   its builder's type. For a type synonym constructor, it returns its
--   right-hand side. For a coaxiom, it fails.
lookupTypeFromGlobalName :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Name corresponding to a type synonym
lookupTypeSynRhs :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type
lookupSynDef :: TyThing -> Maybe TyCon
tyconFromTyThing :: TyThing -> Maybe TyCon
tyconFromGHCType :: Type -> Maybe TyCon
isNewtype :: GhcMonad m => Type -> m Bool
lookupType :: GhcMonad m => Type -> MaybeT m TyThing

-- | Looks up a GHC.Class from something that has a type class constructor
--   in it Fails if the argument does not contain a class type constructor
lookupClassWith :: GhcMonad m => (a -> MaybeT m Name) -> a -> MaybeT m Class
lookupClass :: (GhcMonad m, HasNameInfo' n) => n -> MaybeT m Class
lookupClassFromInstance :: GhcMonad m => InstanceHead -> MaybeT m Class
lookupClassFromDeclHead :: GhcMonad m => DeclHead -> MaybeT m Class

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Type corresponding to a type synonym
semanticsTypeSynRhs :: GhcMonad m => Type -> MaybeT m Type

-- | Converts a global Haskell Tools type to a GHC type
semanticsType :: GhcMonad m => Type -> MaybeT m Type
isNewtypeTyCon :: TyThing -> Bool

-- | Looks up the given name, extracts something out of it. If the
--   extraction is not succesful, it returns False, if it is successful,
--   then checks the result against the predicate. The reasoning behind
--   this, is that the predicate can only be satisfied by a proper name.
satisfies :: (HasNameInfo' n, GhcMonad m) => (TyThing -> Maybe a) -> (a -> Bool) -> n -> MaybeT m Bool

-- | Decides whether a given name is a type family constructor. Fails if
--   the lookup is not successful.
isClassTyConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Decides whether a given name is a standard Haskell98 data constructor.
--   Fails if the lookup is not successful.
isVanillaDataConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Looks up a closed type family from a name.
lookupClosedTyFam :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m ClosedTyFam

-- | Extract the CoAxioms from a TyThing representing a closed type family.
coAxiomFromTyThing :: TyThing -> Maybe (CoAxiom Branched)

-- | Determines whether a Type itself has a type variable head.
hasTyVarHead :: Type -> Bool

-- | An element of the AST keeping extra information.
data Ann (elem :: Type -> Type -> Type) dom stage
class HasSourceInfo e where {
    type family SourceInfoType e :: Type;
}
srcInfo :: HasSourceInfo e => Simple Lens e (SourceInfoType e)

-- | Extracts or modifies the concrete range corresponding to a given
--   source info. In case of lists and optional elements, it may not
--   contain the elements inside.
class HasRange a
getRange :: HasRange a => a -> SrcSpan
setRange :: HasRange a => SrcSpan -> a -> a
annListElems :: () => Lens (AnnListG elem dom stage) (AnnListG elem dom stage) [Ann elem dom stage] [Ann elem dom stage]
annListAnnot :: () => Lens (AnnListG elem dom stage) (AnnListG elem dom stage) (NodeInfo (SemanticInfo dom (AnnListG elem)) (ListInfo stage)) (NodeInfo (SemanticInfo dom (AnnListG elem)) (ListInfo stage))
annList :: () => Traversal (AnnListG e d s) (AnnListG e d s) (Ann e d s) (Ann e d s)
annJust :: () => Partial (AnnMaybeG e d s) (AnnMaybeG e d s) (Ann e d s) (Ann e d s)
annMaybe :: () => Lens (AnnMaybeG elem dom stage) (AnnMaybeG elem dom stage) (Maybe (Ann elem dom stage)) (Maybe (Ann elem dom stage))
isAnnNothing :: () => AnnMaybeG e d s -> Bool

-- | A semantic domain for the AST. The semantic domain maps semantic
--   information for the different types of nodes in the AST. The kind of
--   semantic domain for an AST depends on which stages of the compilation
--   it passed. However after transforming the GHC representation to our
--   AST, the domain stays the same. The domain is not applied to the AST
--   elements that are generated while refactoring.
type Domain d = (Typeable d, Data d, SemanticInfo' d SemaInfoDefaultCls ~ NoSemanticInfo, Data SemanticInfo' d SemaInfoNameCls, Data SemanticInfo' d SemaInfoLitCls, Data SemanticInfo' d SemaInfoExprCls, Data SemanticInfo' d SemaInfoImportCls, Data SemanticInfo' d SemaInfoModuleCls, Data SemanticInfo' d SemaInfoWildcardCls)

-- | With this domain, semantic information can be parameterized. In
--   practice it is only used if the compilation cannot proceed past the
--   type checking phase.
data Dom name
data IdDom

-- | A short form of showing a range, without file name, for debugging
--   purposes.
shortShowSpan :: SrcSpan -> String
shortShowSpanWithFile :: SrcSpan -> String

-- | A stage where the annotation controls how the original source code can
--   be retrieved from the AST. A source template is assigned to each node.
--   It has holes where the content of an other node should be printed and
--   ranges for the source code of the node.
data SrcTemplateStage

-- | A class for traversing source information in an AST
class SourceInfoTraversal (a :: Type -> Type -> Type)
sourceInfoTraverseUp :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> f () -> f () -> a dom st1 -> f (a dom st2)
sourceInfoTraverseDown :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> f () -> f () -> a dom st1 -> f (a dom st2)
sourceInfoTraverse :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> a dom st1 -> f (a dom st2)
sourceTemplateNodeRange :: Simple Lens (SpanInfo SrcTemplateStage) SrcSpan
sourceTemplateNodeElems :: Simple Lens (SpanInfo SrcTemplateStage) [SourceTemplateElem]
sourceTemplateListRange :: Simple Lens (ListInfo SrcTemplateStage) SrcSpan
srcTmpListBefore :: Simple Lens (ListInfo SrcTemplateStage) String
srcTmpListAfter :: Simple Lens (ListInfo SrcTemplateStage) String
srcTmpDefaultSeparator :: Simple Lens (ListInfo SrcTemplateStage) String
srcTmpIndented :: Simple Lens (ListInfo SrcTemplateStage) (Maybe [Bool])
srcTmpSeparators :: Simple Lens (ListInfo SrcTemplateStage) [([SourceTemplateTextElem], SrcSpan)]
sourceTemplateOptRange :: Simple Lens (OptionalInfo SrcTemplateStage) SrcSpan
srcTmpOptBefore :: Simple Lens (OptionalInfo SrcTemplateStage) String
srcTmpOptAfter :: Simple Lens (OptionalInfo SrcTemplateStage) String
data SourceTemplateTextElem
NormalText :: String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
StayingText :: String -> String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
[_lineEndings] :: SourceTemplateTextElem -> String
sourceTemplateText :: Lens SourceTemplateTextElem SourceTemplateTextElem String String
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension
data SpliceInsertionProblem
SpliceInsertionProblem :: SrcSpan -> String -> SpliceInsertionProblem
data ConvertionProblem
ConvertionProblem :: CallStack -> SrcSpan -> String -> ConvertionProblem
UnrootedConvertionProblem :: String -> ConvertionProblem
data TransformationProblem
TransformationProblem :: String -> TransformationProblem
data BreakUpProblem
BreakUpProblem :: RealSrcSpan -> SrcSpan -> [SrcSpan] -> BreakUpProblem
[bupOuter] :: BreakUpProblem -> RealSrcSpan
[bupInner] :: BreakUpProblem -> SrcSpan
[bupSiblings] :: BreakUpProblem -> [SrcSpan]
data PrettyPrintProblem
PrettyPrintProblem :: String -> PrettyPrintProblem
