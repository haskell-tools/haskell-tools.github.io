-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Refactoring Tool for Haskell
--   
--   Contains a set of refactorings based on the Haskell-Tools framework to
--   easily transform a Haskell program. For the descriptions of the
--   implemented refactorings, see the homepage.
@package haskell-tools-builtin-refactorings
@version 1.1.0.2

module Language.Haskell.Tools.Refactor.Builtin.AutoCorrect
autoCorrect :: RealSrcSpan -> LocalRefactoring
tryItOut :: String -> String -> IO ()
autoCorrectRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMap
type ExtMap = Map (LogicalRelation Extension) [Occurence SrcSpan]
data Occurence a
Hint :: a -> Occurence a
[unOcc] :: Occurence a -> a
Evidence :: a -> Occurence a
[unOcc] :: Occurence a -> a
MissingInformation :: a -> Occurence a
[unOcc] :: Occurence a -> a
type LogicalRelation a = Formula a
prettyPrintFormula :: Show a => LogicalRelation a -> String
lVar :: a -> LogicalRelation a
lNot :: a -> LogicalRelation a
lAnd :: a -> a -> LogicalRelation a
lOr :: a -> a -> LogicalRelation a
lImplies :: a -> a -> LogicalRelation a
lAll :: [LogicalRelation a] -> LogicalRelation a
complexity :: Extension -> Int

-- | Completely expand extension
expandExtension' :: Extension -> [Extension]

-- | Terminating variant of Control.Monad.Fix.fix It tries to find the
--   fixpoint of a function with a given starting value. It terminates if a
--   value repeats itself.
findFixedPoint :: Eq a => (a -> a) -> a -> a
determineExtensions :: Map (LogicalRelation Extension) v -> [Extension]
rmImplied :: Extension -> [Extension] -> [Extension]
mergeImplied :: [Extension] -> [Extension]

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
data Formula v
Var :: v -> Formula v
Yes :: Formula v
No :: Formula v
Not :: Formula v -> Formula v
(:&&:) :: Formula v -> Formula v -> Formula v
(:||:) :: Formula v -> Formula v -> Formula v
(:++:) :: Formula v -> Formula v -> Formula v
(:->:) :: Formula v -> Formula v -> Formula v
(:<->:) :: Formula v -> Formula v -> Formula v
All :: [Formula v] -> Formula v
Some :: [Formula v] -> Formula v
None :: [Formula v] -> Formula v
ExactlyOne :: [Formula v] -> Formula v
AtMostOne :: [Formula v] -> Formula v
Let :: Formula v -> (Formula v -> Formula v) -> Formula v
Bound :: Integer -> Formula v
instance GHC.Base.Functor Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMap.Occurence
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMap.Occurence a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMap.Occurence a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMap.Occurence a)
instance GHC.Classes.Ord GHC.LanguageExtensions.Type.Extension
instance GHC.Read.Read GHC.LanguageExtensions.Type.Extension
instance GHC.Generics.Generic a => GHC.Generics.Generic (SAT.MiniSat.Formula.Formula a)
instance (GHC.Generics.Generic a, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (SAT.MiniSat.Formula.Formula a)
instance Control.DeepSeq.NFData GHC.LanguageExtensions.Type.Extension

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad
class Checkable node
check :: Checkable node => CheckNode node
type CheckUNode uelem = Ann uelem IdDom SrcTemplateStage -> ExtMonad (Ann uelem IdDom SrcTemplateStage)
type CheckNode elem = elem -> ExtMonad elem
type ExtMonad = ReaderT [Extension] (StateT ExtMap Ghc)
addHint' :: (Ord k, HasRange a) => k -> a -> Map k [Occurence SrcSpan] -> Map k [Occurence SrcSpan]
addHint_ :: (MonadState ExtMap m, HasRange node) => Extension -> node -> m ()
addHint :: (MonadState ExtMap m, HasRange node) => Extension -> node -> m node
addRelationHint_ :: (MonadState ExtMap m, HasRange node) => LogicalRelation Extension -> node -> m ()
addRelationHint :: (MonadState ExtMap m, HasRange node) => LogicalRelation Extension -> node -> m node
addMI' :: (Ord k, HasRange a) => k -> a -> Map k [Occurence SrcSpan] -> Map k [Occurence SrcSpan]
addMI_ :: (MonadState ExtMap m, HasRange node) => Extension -> node -> m ()
addMI :: (MonadState ExtMap m, HasRange node) => Extension -> node -> m node
addRelationMI_ :: (MonadState ExtMap m, HasRange node) => LogicalRelation Extension -> node -> m ()
addRelationMI :: (MonadState ExtMap m, HasRange node) => LogicalRelation Extension -> node -> m node
addEvidence' :: (Ord k, HasRange a) => k -> a -> Map k [Occurence SrcSpan] -> Map k [Occurence SrcSpan]
addEvidence_ :: (MonadState ExtMap m, HasRange node) => Extension -> node -> m ()
addEvidence :: (MonadState ExtMap m, HasRange node) => Extension -> node -> m node
addRelation_ :: (MonadState ExtMap m, HasRange node) => LogicalRelation Extension -> node -> m ()
addRelation :: (MonadState ExtMap m, HasRange node) => LogicalRelation Extension -> node -> m node
addEvidenceLoc' :: Ord k => k -> SrcSpan -> Map k [Occurence SrcSpan] -> Map k [Occurence SrcSpan]
addEvidenceLoc :: MonadState ExtMap m => Extension -> SrcSpan -> m ()
addRelationLoc :: MonadState ExtMap m => LogicalRelation Extension -> SrcSpan -> m ()
isTurnedOn :: Extension -> ExtMonad Bool
isTurnedOff :: Extension -> ExtMonad Bool
conditional :: (node -> ExtMonad node) -> Extension -> node -> ExtMonad node
conditionalNot :: (node -> ExtMonad node) -> Extension -> node -> ExtMonad node
conditionalAny :: (node -> ExtMonad node) -> [Extension] -> node -> ExtMonad node
conditionalAdd :: HasRange node => Extension -> node -> ExtMonad node
runExtMonadIO :: ExtMonad a -> IO a
runExtMonadGHC :: ExtMonad a -> Ghc a

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.Instances.AppSelector
type family HasChecker node

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.SupportedExtensions
isSupported :: Extension -> Bool
fullyHandledExtensions :: [Extension]
syntacticExtensions :: [Extension]
derivingExtensions :: [Extension]
typeClassExtensions :: [Extension]
typeSystemExtensions :: [Extension]
thExtensions :: [Extension]

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.Checkers
chkViewPatterns :: CheckNode Pattern
chkViewPatterns' :: CheckNode Pattern

-- | If UndecidableInstances is turned on, it checks whether any type class
--   or type family instances needs UndecidableInstances in the module.
gblChkUndecidableInstances :: CheckNode Module

-- | Checks whether any type class or type family instances needs
--   UndecidableInstances in the module.
gblChkUndecidableInstances' :: CheckNode Module

-- | If the type class instance requires UndecidableInstances, it adds the
--   occurence with location of the instance.
chkClsInst :: ClsInst -> ExtMonad ()

-- | Decides whether a type class instance requires UndecidableInstances.
clsInstNeedsUD :: ClsInst -> Bool

-- | If the type class instance requires UndecidableInstances, it adds the
--   occurence with location of the instance.
chkFamInst :: FamInst -> ExtMonad ()

-- | Decides whether a family instance requires UndecidableInstances. If it
--   is a data family instance, it does not need the extension.
famInstNeedsUD :: FamInst -> Bool

-- | Checks a declaration whether it needs UndecidableInstances. (If the
--   extension is turned on)
chkUndecidableInstancesDecl :: CheckNode Decl

-- | Checks a declaration whether it needs UndecidableInstances. If a
--   lookup is not successful, it keeps the extension.
chkUndecidableInstancesDecl' :: CheckNode Decl

-- | Checks a class declaration whether it has a type function in its
--   context, or a closed type family declaration needs
--   UndecidableInstances. For more information on the family check, see
--   checkFamInstRhs. May fail on lookup.
chkUndecidableInstancesDeclMaybe :: Decl -> MaybeT ExtMonad Decl
chkUnboxedTuplesExpr :: CheckNode Expr
chkUnboxedTuplesPat :: CheckNode Pattern
chkUnboxedTuplesType :: CheckNode Type
chkUnboxedTuplesExpr' :: CheckNode Expr
chkUnboxedTuplesPat' :: CheckNode Pattern
chkUnboxedTuplesType' :: CheckNode Type

-- | We need to check declarations because we want to avoid checking type
--   family instances
chkTypeSynonymInstancesDecl :: CheckNode Decl

-- | Checks an instance rule in declaration We need to check declarations
--   because we want to avoid checking type family instances
chkInstancesDeclWith :: CheckNode InstanceRule -> CheckNode Decl

-- | Checks and instance head in an instance rule
chkInstanceRuleWith :: CheckNode InstanceHead -> CheckNode InstanceRule

-- | Collects the type arguments in an instance declaration Type arguments
--   are the the types that the class is being instantiated with
collectTyArgs :: InstanceHead -> [Type]

-- | Checks a Type whether it contains any DeclHeads that amy need
--   TypeOperators
chkTypeOperatorsType :: CheckNode Type

-- | Checks an Assertion whether it contains any DeclHeads that amy need
--   TypeOperators
chkTypeOperatorsAssertion :: CheckNode Assertion

-- | Checks an InstanceHEad whether it contains any DeclHeads that amy need
--   TypeOperators
chkTypeOperatorsInstHead :: CheckNode InstanceHead

-- | Checks a Decl whether it contains any DeclHeads that amy need
--   TypeOperators We check Decls to avoid getting multiple occurences of
--   the same DeclHead (e.g. we would check it with and without
--   parentheses)
chkTypeOperatorsDecl :: CheckNode Decl
chkTypeOperatorsType' :: CheckNode Type
chkTypeOperatorsAssertion' :: CheckNode Assertion
chkTypeOperatorsInstHead' :: CheckNode InstanceHead
chkTypeOperatorsDecl' :: CheckNode Decl
isOperatorM :: DeclHead -> ExtMonad Bool

-- | Checks whether any name's corresponding type in the module contains a
--   type equality.
gblChkQNamesForTypeEq :: CheckNode Module

-- | Checks an operator for syntactic evidence of a ~ b type equality if
--   TypeFamilies or GADTs is turned on.
chkOperatorForTypeEq :: CheckNode Operator

-- | Checks a declaration if TypeFamilies is turned on.
chkTypeFamiliesDecl :: CheckNode Decl

-- | Checks a class element if TypeFamilies is turned on.
chkTypeFamiliesClassElement :: CheckNode ClassElement

-- | Checks an instance body if TypeFamilies is turned on.
chkTypeFamiliesInstBodyDecl :: CheckNode InstBodyDecl
chkTypeFamiliesDecl' :: CheckNode Decl
chkTypeFamiliesClassElement' :: CheckNode ClassElement
chkTypeFamiliesInstBodyDecl' :: CheckNode InstBodyDecl
chkOperatorForTypeEq' :: CheckNode Operator

-- | Checks whether a given name's has a type equality operator in it. If
--   the type lookup fails, it returns Nothing. If given a type variable,
--   it returns False.
chkQNameForTyEqn :: QualifiedName -> MaybeT ExtMonad Bool
gblChkQNamesForTypeEq' :: CheckNode Module
chkTupleSections :: CheckNode Expr
chkTupleSections' :: CheckNode Expr
chkTemplateHaskellSplice :: CheckNode Splice
chkTemplateHaskellQuasiQuote :: CheckNode QuasiQuote
chkTemplateHaskellBracket :: CheckNode Bracket
chkTemplateHaskellhNamePart :: CheckNode NamePart
chkTemplateHaskellNamePart' :: CheckNode NamePart
chkRecursiveDoExpr :: CheckNode Expr
chkRecursiveDoStmt :: CheckNode Stmt
chkRecordWildCardsPatField :: CheckNode PatternField
chkRecordWildCardsFieldUpdate :: CheckNode FieldUpdate
chkPatternSynonymsSyn :: CheckNode PatternSynonym
chkPatternSynonymsSyn' :: CheckNode PatternSynonym
chkPatternSynonymsTypeSig :: CheckNode PatternSignature
chkParallelListComp :: CheckNode Expr
chkOverloadedStringsLiteral :: CheckNode Literal
chkMultiWayIfExpr :: CheckNode Expr
chkMultiWayIfExpr' :: CheckNode Expr
chkMultiParamTypeClassesDecl :: CheckNode Decl

-- | Decides whether a class or instance declaration needs
--   MultiParamTypeClasses Also handles the NullaryTypeClasses case
chkMultiParamTypeClassesDecl' :: CheckNode Decl
collectTyVars :: DeclHead -> [TyVar]

-- | Decides whether an instance declaration needs MultiParamTypeClasses
--   Also handles the NullaryTypeClasses case
isMultiParamNeeded :: InstanceHead -> Bool
chkMagicHashLiteral :: CheckNode Literal
chkMagicHashNamePart :: CheckNode NamePart
chkMagicHashKind :: CheckNode Kind
chkMagicHashLiteral' :: CheckNode Literal
chkMagicHashNamePart' :: CheckNode NamePart
chkMagicHashKind' :: CheckNode Kind
chkLambdaCase :: CheckNode Expr
chkLambdaCase' :: CheckNode Expr
chkKindSignaturesKind :: CheckNode Kind

-- | Checks a GADT-style constructor if GADTSyntax is turned on. Sometimes
--   GADTSyntax is sufficient and GADTs is not even needed.
chkGADTsGadtConDecl :: CheckNode GadtConDecl

-- | Checks a data constructor declaration if GADTs or
--   ExistentialQuantification is turned on. This function is responsible
--   for checking ExistentialQuantification as well. (there is no separate
--   checker for that extension)
chkConDeclForExistentials :: CheckNode ConDecl

-- | Checks whether a GADTs-style constructor declaration requires GADTs.
--   If all data constructors are vanilla Haskell 98 data constructors ,
--   then only GADTSyntax is needed. If any constructor's lookup fails , we
--   add MissingInformation.
chkGADTsGadtConDecl' :: CheckNode GadtConDecl

-- | Extracts the name from a ConDecl, and checks whether it is a vanilla
--   data constructor. Ifthe lookup fails, adds MissingInformation.
chkConDeclForExistentials' :: CheckNode ConDecl
chkFunDeps :: CheckNode FunDepList
gblChkQNamesForFC :: CheckNode Module
chkFlexibleContexts :: CheckNode Context
chkFlexibleContexts' :: CheckNode Context
chkAssertion :: CheckNode Assertion
chkFlexibleContextsDecl :: CheckNode Decl
chkFlexibleContextsDecl' :: CheckNode Decl

-- | Checks whether all type class applications in a type synonym rhs (that
--   has kind Constraint) have only type variable heads. Returns False if a
--   lookup inside is not succesful. If it isn't applied to a type that has
--   kind Constraint, it may give false positive results.
chkClassesInside :: Type -> ExtMonad ()
chkQNameForFC :: QualifiedName -> ExtMonad Bool
gblChkQNamesForFC' :: CheckNode Module

-- | We need to check declarations because we want to avoid checking type
--   family instances
chkFlexibleInstancesDecl :: CheckNode Decl
refact :: (Data (node dom stage), Data (inner dom stage)) => (inner dom stage -> inner dom stage) -> node dom stage -> node dom stage

-- | Checks every single type argument in an instance declaration If the
--   class being instantiated could not have been looked up, it keeps
--   FlexibleInstances
chkInstanceHead :: CheckNode InstanceHead

-- | Checks a type argument of class whether it needs FlexibleInstances
--   First checks the structure of the type argument opaquely Then, for
--   type synonyms, it checks whether their GHC representation itself needs
--   the extension.
--   
--   Might find false positive occurences for phantom types: &gt; type
--   Phantom a b = [a] &gt; instance C (Phantom a a) &gt; instance C
--   (Phantom a Int)
chkTypeArg :: Class -> Type -> ExtMonad Type

-- | Checks a type argument of class whether it has only (distinct) type
--   variable arguments.
chkNormalTypeArg :: CheckNode Type
rmTypeMisc :: Type -> Type
tyArgNeedsFI :: Class -> Type -> Bool

-- | Checks whether a GHC.Type is an application, and has only (distinct)
--   type variable arguments Logic from TcValidity.tcInstHeadTyAppAllTyVars
hasOnlyDistinctTyVars :: Type -> Bool

-- | A local helper function from TcValidity
dropCasts :: Type -> Type

-- | A local helper function from TcValidity
dropCastsB :: TyVarBinder -> TyVarBinder
chkExplicitNamespacesIESpec :: CheckNode IESpec
chkExplicitForAllType :: CheckNode Type
chkExplicitForAllConDecl :: CheckNode ConDecl
chkExplicitForAllGadtConDecl :: CheckNode GadtConDecl
chkQuantifiedTyVarsWith :: HasRange a => (a -> TyVarList) -> CheckNode a
isStockClass :: Name -> Bool
stockClasses :: [Name]
gndNotNeeded :: Name -> Bool
gndNotNeededClasses :: [Name]
gndNeeded :: Name -> Bool
gndNeededClasses :: [Name]
gndNotAllowed :: Name -> Bool
gndNotAllowedClasses :: [Name]
whichExtension :: Name -> Maybe Extension
nameExtensionMap :: Map Name Extension
chkDerivings :: CheckNode Decl
chkDataDecl :: CheckNode Decl
chkGADTDataDecl :: CheckNode Decl
chkDataInstance :: CheckNode Decl
separateByKeyword :: DataOrNewtypeKeyword -> CheckNode Deriving
getStrategy :: Deriving -> Maybe DeriveStrategy
addExtension :: (MonadState ExtMap m, HasRange node) => Name -> node -> m node
addStockExtension :: CheckNode InstanceHead
chkByStrat :: CheckNode InstanceHead -> CheckNode Deriving
chkStrat :: DeriveStrategy -> CheckNode InstanceHead
chkDerivingClause :: CheckNode InstanceHead -> CheckNode Deriving
nameFromStock :: InstanceHead -> Maybe Name
chkClassForData :: CheckNode InstanceHead
chkClassForNewtype :: CheckNode InstanceHead
skipParens :: InstanceHead -> InstanceHead
chkStandaloneDeriving :: CheckNode Decl
decompRule :: InstanceRule -> (InstanceHead, Type)
getClassCon :: InstanceHead -> InstanceHead
rightmostType :: InstanceHead -> Type
isSynNewType :: Type -> ExtMonad Bool
chkDefaultSigs :: CheckNode ClassElement
gblChkCPP :: CheckNode Module
gblChkCPP' :: CheckNode Module
rmDefaultIncludes :: FilePath -> String -> String

-- | Returns the preprocessed source code. If it is not present, it returns
--   an empty string.
preprocessedSrc :: ModSummary -> String
strBufToStr :: StringBuffer -> String
chkConstrainedClassMethodsDecl :: CheckNode Decl

-- | Check a DeclHead for ConstrainedClassMethods. Adds the extension if it
--   is needed or the lookup fails.
chkCCMDeclHead :: CheckNode DeclHead

-- | Helper function for chkCCMDeclHead. True <a>=</a> Lookup is succesful
--   and ConstrainedClassMethods is needed False <a>=</a> Lookup is
--   succesful, but CCM is not needed, or the argument is not a class
--   DeclHead fails <a>=</a> Lookup is unsuccesful (either name or type
--   lookup)
chkCCMDeclHead' :: DeclHead -> MaybeT ExtMonad Bool

-- | Decides whether a class really needs the ConstrainedClassMethods
--   extension A class needs CCM iff at least one of its class methods has
--   a constraint with a non-empty type variable set, that contains only
--   class type variables.
classNeedsCCM :: Class -> Bool
chkConstraintKindsDecl :: CheckNode Decl
chkConstraintKindsDecl' :: CheckNode Decl
hasTyVarHeadAsserts :: Context -> Bool
hasAnyTyVarHeads :: Assertion -> Bool
chkBangPatterns :: CheckNode Pattern
chkBangPatterns' :: CheckNode Pattern
chkArrowsExpr :: CheckNode Expr
chkArrowsCmd :: CheckNode Cmd

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.Instances.Checkable
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Module
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Decl
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Pattern
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Expr
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Type
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.PatternField
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.FieldUpdate
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.PatternSynonym
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.PatternSignature
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Literal
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.NamePart
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Kind
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Splice
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.QuasiQuote
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Bracket
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.FunDepList
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.ClassElement
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Stmt
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Cmd
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.InstBodyDecl
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.IESpec
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Operator
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.GadtConDecl
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.ConDecl
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Assertion
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.InstanceHead
instance Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.ExtMonad.Checkable Language.Haskell.Tools.Rewrite.ElementTypes.Context

module Language.Haskell.Tools.Refactor.Builtin.ExtensionOrganizer.TraverseAST
traverseModule :: CheckNode Module

module Language.Haskell.Tools.Refactor.Builtin.ExtractBinding
extractBinding' :: String -> Maybe String -> RealSrcSpan -> LocalRefactoring
extractBindingRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.FloatOut
floatOut :: RealSrcSpan -> LocalRefactoring
floatOutRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.GenerateExports

-- | Creates an export list that imports standalone top-level definitions
--   with all of their contained definitions
generateExports :: LocalRefactoring
generateExportsRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.GenerateTypeSignature

-- | Perform the refactoring on either local or top-level definition
generateTypeSignature :: Simple Traversal Module DeclList -> Simple Traversal Module LocalBindList -> (forall d. BindingElem d => AnnList d -> Maybe ValueBind) -> LocalRefactoring
generateTypeSignature' :: RealSrcSpan -> LocalRefactoring
tryItOut :: String -> String -> IO ()
generateTypeSignatureRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.GetMatches
getMatchesQuery :: QueryChoice
getMatches :: RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue

-- | TODO: unpack forall, context types | TODO: care for infix constructors
getCtors :: Type -> QueryMonad [(String, [String])]
noSuccessMsg :: Type -> String
formatCtor :: DataCon -> (String, [String])

-- | TODO: Check for names in scope | TODO: Create names based on the type
createArgNames :: [Type] -> [String]


-- | Defines the inline binding refactoring that removes a value binding
--   and replaces all occurences with an expression equivalent to the body
--   of the binding.
module Language.Haskell.Tools.Refactor.Builtin.InlineBinding
inlineBinding :: RealSrcSpan -> Refactoring
tryItOut :: String -> String -> IO ()
inlineBindingRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.OrganizeExtensions
highlightExtensionsQuery :: QueryChoice
organizeExtensionsRefactoring :: RefactoringChoice
projectOrganizeExtensionsRefactoring :: RefactoringChoice
projectOrganizeExtensions :: ProjectRefactoring
tryOut :: String -> String -> IO ()
organizeExtensions :: LocalRefactoring

-- | Reduces default extension list (keeps unsupported extensions)
reduceExtensions :: UnnamedModule -> Ghc [Extension]

-- | Collect the required extensions in a module and returns a markers
--   associated with them
extensionMarkers :: UnnamedModule -> Ghc [Marker]

-- | Collects extensions induced by the source code (with location info)
collectExtensions :: UnnamedModule -> Ghc ExtMap

-- | Collects the required extensions from a module using the given
--   traversal method
collectExtensionsWith :: CheckNode UnnamedModule -> UnnamedModule -> Ghc ExtMap

-- | Expands every extension in a list, while not producing any duplicates.
expandExtensions :: [Extension] -> [Extension]

-- | Collects extensions enabled by default
collectDefaultExtensions :: UnnamedModule -> [Extension]

-- | Collects extensions enabled by default
collectTurnedOffExtensions :: UnnamedModule -> [Extension]

-- | Collects the string representation of the extensions in the module
getExtensions :: UnnamedModule -> [String]
toExt :: String -> Maybe Extension

module Language.Haskell.Tools.Refactor.Builtin.OrganizeImports
organizeImports :: LocalRefactoring
projectOrganizeImports :: ProjectRefactoring
organizeImportsRefactoring :: RefactoringChoice
projectOrganizeImportsRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin.RenameDefinition
renameDefinition :: Name -> [Name] -> String -> Refactoring
renameDefinition' :: RealSrcSpan -> String -> Refactoring
renameDefinitionRefactoring :: RefactoringChoice

module Language.Haskell.Tools.Refactor.Builtin
builtinRefactorings :: [RefactoringChoice]
builtinQueries :: [QueryChoice]
