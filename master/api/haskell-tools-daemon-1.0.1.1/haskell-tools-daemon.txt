-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Background process for Haskell-tools that editors can connect to.
--   
--   Background process for Haskell-tools that provides a way to use the
--   tools on a whole project. It also makes it possible to use the tools
--   on the project in a session, reloading modules when needed. The daemon
--   library is independent of the actual set of tools, and takes them as a
--   parameter, so the system can be easily extended by creating a simple
--   new Main module.
@package haskell-tools-daemon
@version 1.0.1.1


-- | Mapping between Cabal's and GHC's representation of language
--   extensions.
module Language.Haskell.Tools.Daemon.MapExtensions
setExtensionFlag' :: Extension -> DynFlags -> DynFlags
unSetExtensionFlag' :: Extension -> DynFlags -> DynFlags


-- | Creating a dependency graph of the modules loaded into a session. Code
--   copied from GHC because it is not public in GhcMake module
module Language.Haskell.Tools.Daemon.ModuleGraph
moduleGraphNodes :: Bool -> [ModSummary] -> (Graph SummaryNode, HscSource -> ModuleName -> Maybe SummaryNode)
getModFromNode :: SummaryNode -> ModSummary
dependentModules :: (ModSummary -> Ghc Bool) -> Ghc [ModSummary]
supportingModules :: (ModSummary -> Ghc Bool) -> Ghc [ModSummary]


-- | Setting the package database to use when compiling modules. The daemon
--   must have one single package database that cannot be changed after a
--   package is loaded using that package database. Available package
--   databases are the cabal global, the cabal sandbox, the stack or one
--   that had been explicitely set by a file path.
module Language.Haskell.Tools.Daemon.PackageDB

-- | Possible package database configurations.
data PackageDB

-- | Use the global cabal package database (like when using ghc).
DefaultDB :: PackageDB

-- | Use the sandboxed cabal package database.
CabalSandboxDB :: PackageDB

-- | Use the stack package databases (local and snapshot).
StackDB :: PackageDB

-- | Set the package database explicitely.
ExplicitDB :: [FilePath] -> PackageDB
[packageDBPath] :: PackageDB -> [FilePath]

-- | Decide which type of project we are dealing with based on the package
--   folders. Should only be invoked if the user did not select the
--   project-type.
decidePkgDB :: [FilePath] -> IO (Maybe PackageDB)

-- | Finds the location of the package database based on the configuration.
packageDBLoc :: PackageDB -> FilePath -> IO [FilePath]

-- | Gets the (probable) location of autogen folder depending on which type
--   of build we are using.
detectAutogen :: FilePath -> PackageDB -> IO (Maybe FilePath)
instance GHC.Generics.Generic Language.Haskell.Tools.Daemon.PackageDB.PackageDB
instance GHC.Show.Show Language.Haskell.Tools.Daemon.PackageDB.PackageDB
instance GHC.Classes.Eq Language.Haskell.Tools.Daemon.PackageDB.PackageDB
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.Tools.Daemon.PackageDB.PackageDB

module Language.Haskell.Tools.Daemon.Options

-- | Command line options for the daemon process.
data DaemonOptions
DaemonOptions :: Bool -> Int -> Bool -> SharedDaemonOptions -> DaemonOptions
[daemonVersion] :: DaemonOptions -> Bool
[portNumber] :: DaemonOptions -> Int
[silentMode] :: DaemonOptions -> Bool
[sharedOptions] :: DaemonOptions -> SharedDaemonOptions
parseDaemonCLI :: IO DaemonOptions

-- | Command line options shared by CLI and daemon.
data SharedDaemonOptions
SharedDaemonOptions :: Bool -> Maybe FilePath -> Bool -> Bool -> Maybe [String] -> Maybe PackageDB -> SharedDaemonOptions
[noWatch] :: SharedDaemonOptions -> Bool
[watchExe] :: SharedDaemonOptions -> Maybe FilePath
[generateCode] :: SharedDaemonOptions -> Bool
[disableHistory] :: SharedDaemonOptions -> Bool
[ghcFlags] :: SharedDaemonOptions -> Maybe [String]
[projectType] :: SharedDaemonOptions -> Maybe PackageDB
sharedOptionsParser :: Parser SharedDaemonOptions
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Options.DaemonOptions
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Options.SharedDaemonOptions


-- | This module declares the messages that can be sent from the client to
--   the daemon engine and from the engine to the client.
module Language.Haskell.Tools.Daemon.Protocol

-- | The messages expected from the client.
data ClientMessage

-- | A simple ping message to check that the server is running.
KeepAlive :: ClientMessage

-- | A message that instructs the server to reset its internal state and
--   re-load loaded packages.
Reset :: ClientMessage

-- | Tells the client version and asks the servers version.
Handshake :: [Int] -> ClientMessage
[clientVersion] :: ClientMessage -> [Int]

-- | Sets the package database for the engine to use.
SetPackageDB :: PackageDB -> ClientMessage
[pkgDB] :: ClientMessage -> PackageDB

-- | Registers packages to the engine. They will be subject to subsequent
--   refactorings. Will cause the packages to be loaded, resulting in
--   LoadingModules, LoadedModule or CompilationProblem responses.
AddPackages :: [FilePath] -> ClientMessage
[addedPathes] :: ClientMessage -> [FilePath]

-- | Deregisters the given packages from the engine. They will not be
--   subjects of further refactorings.
RemovePackages :: [FilePath] -> ClientMessage
[removedPathes] :: ClientMessage -> [FilePath]

-- | Sets the working directory for the compilation. Important when
--   compiling code that loads resources based on relative pathes.
SetWorkingDir :: FilePath -> ClientMessage
[newWorkingDir] :: ClientMessage -> FilePath

-- | Sets the compilation flags. The unused flags are returned via the
--   UnusedFlags response.
SetGHCFlags :: [String] -> ClientMessage
[ghcFlags] :: ClientMessage -> [String]

-- | Orders the engine to perform the refactoring on the module given with
--   the selection and details. Successful refactorings will cause
--   re-loading of modules. If <a>shutdownAfter</a> or <a>diffMode</a> is
--   not set, after the refactoring, modules are re-loaded, LoadingModules,
--   LoadedModule responses are sent.
PerformRefactoring :: String -> FilePath -> String -> [String] -> Bool -> Bool -> ClientMessage
[refactoring] :: ClientMessage -> String
[modulePath] :: ClientMessage -> FilePath
[editorSelection] :: ClientMessage -> String

-- | Additional details for the refactoring like the names of generated
--   definitions.
[details] :: ClientMessage -> [String]

-- | Stop the daemon after performing the refactoring.
[shutdownAfter] :: ClientMessage -> Bool

-- | Don't change the files, send back the result as a unified diff.
[diffMode] :: ClientMessage -> Bool

-- | Orders the engine to perform a query on the module given with the
--   selection and details.
PerformQuery :: String -> FilePath -> String -> [String] -> Bool -> ClientMessage
[query] :: ClientMessage -> String
[modulePath] :: ClientMessage -> FilePath
[editorSelection] :: ClientMessage -> String

-- | Additional details for the refactoring like the names of generated
--   definitions.
[details] :: ClientMessage -> [String]

-- | Stop the daemon after performing the refactoring.
[shutdownAfter] :: ClientMessage -> Bool

-- | Asks the daemon to undo the last refactoring.
UndoLast :: ClientMessage

-- | Stops the engine. It replies with Disconnected.
Disconnect :: ClientMessage

-- | Instructs the engine to re-load a changed module. LoadingModules,
--   LoadedModule responses may be sent.
ReLoad :: [FilePath] -> [FilePath] -> [FilePath] -> ClientMessage
[addedModules] :: ClientMessage -> [FilePath]
[changedModules] :: ClientMessage -> [FilePath]
[removedModules] :: ClientMessage -> [FilePath]

-- | Stops the server. OBSOLATE
Stop :: ClientMessage

-- | The possible responses that the server can give.
data ResponseMsg

-- | A response to KeepAlive
KeepAliveResponse :: ResponseMsg

-- | Tells the version of the server.
HandshakeResponse :: [Int] -> ResponseMsg
[serverVersion] :: ResponseMsg -> [Int]

-- | An error message marking internal problems or user mistakes. TODO:
--   separate internal problems and user mistakes.
ErrorMessage :: String -> ResponseMsg
[errorMsg] :: ResponseMsg -> String

-- | A response that tells there are errors in the source code given.
CompilationProblem :: [Marker] -> [String] -> ResponseMsg
[markers] :: ResponseMsg -> [Marker]
[errorHints] :: ResponseMsg -> [String]

-- | Information about changes that would be caused by the refactoring.
DiffInfo :: String -> ResponseMsg
[diffInfo] :: ResponseMsg -> String

-- | The traversal of the project is done, now the engine is loading the
--   given modules.
LoadingModules :: [FilePath] -> ResponseMsg
[modulesToLoad] :: ResponseMsg -> [FilePath]

-- | The engine has loaded the given module.
LoadedModule :: FilePath -> String -> ResponseMsg
[loadedModulePath] :: ResponseMsg -> FilePath
[loadedModuleName] :: ResponseMsg -> String

-- | The result of querying the program representation.
QueryResult :: String -> Value -> ResponseMsg
[queryName] :: ResponseMsg -> String
[queryResult] :: ResponseMsg -> Value

-- | Returns the flags that are not used by the engine.
UnusedFlags :: [String] -> ResponseMsg
[unusedFlags] :: ResponseMsg -> [String]

-- | The engine has closed the connection.
Disconnected :: ResponseMsg
data Marker
Marker :: SrcSpan -> Severity -> String -> Marker
[location] :: Marker -> SrcSpan
[severity] :: Marker -> Severity
[message] :: Marker -> String
data Severity
Error :: Severity
Warning :: Severity
Info :: Severity
data UndoRefactor
RemoveAdded :: FilePath -> UndoRefactor
[undoRemovePath] :: UndoRefactor -> FilePath
RestoreRemoved :: FilePath -> String -> UndoRefactor
[undoRestorePath] :: UndoRefactor -> FilePath
[undoRestoreContents] :: UndoRefactor -> String
UndoChanges :: FilePath -> FileDiff -> UndoRefactor
[undoChangedPath] :: UndoRefactor -> FilePath
[undoDiff] :: UndoRefactor -> FileDiff
type FileDiff = [(Int, Int, String)]
instance Control.DeepSeq.NFData Language.Haskell.Tools.Daemon.Protocol.UndoRefactor
instance GHC.Generics.Generic Language.Haskell.Tools.Daemon.Protocol.UndoRefactor
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Protocol.UndoRefactor
instance GHC.Generics.Generic Language.Haskell.Tools.Daemon.Protocol.ResponseMsg
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Protocol.ResponseMsg
instance GHC.Classes.Eq Language.Haskell.Tools.Daemon.Protocol.Marker
instance GHC.Generics.Generic Language.Haskell.Tools.Daemon.Protocol.Marker
instance GHC.Classes.Eq Language.Haskell.Tools.Daemon.Protocol.Severity
instance GHC.Generics.Generic Language.Haskell.Tools.Daemon.Protocol.Severity
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Protocol.Severity
instance GHC.Generics.Generic Language.Haskell.Tools.Daemon.Protocol.ClientMessage
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Protocol.ClientMessage
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Daemon.Protocol.UndoRefactor
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Daemon.Protocol.ResponseMsg
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Protocol.Marker
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Daemon.Protocol.Marker
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Daemon.Protocol.Severity
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.Tools.Daemon.Protocol.ClientMessage
instance Data.Aeson.Types.ToJSON.ToJSON SrcLoc.SrcSpan


-- | Defines different working modes for the daemon. It can work by using a
--   socket connection or channels to communicate with the client. When the
--   daemon is used by CLI, it uses channel if it communicates with an
--   editor plugin it uses the socket connection.
module Language.Haskell.Tools.Daemon.Mode

-- | An abstraction over the connection to the client.
data WorkingMode a
WorkingMode :: (Int -> IO a) -> (a -> IO ()) -> (a -> ResponseMsg -> IO ()) -> (a -> IO [Either String ClientMessage]) -> WorkingMode a
[daemonConnect] :: WorkingMode a -> Int -> IO a
[daemonDisconnect] :: WorkingMode a -> a -> IO ()
[daemonSend] :: WorkingMode a -> a -> ResponseMsg -> IO ()
[daemonReceive] :: WorkingMode a -> a -> IO [Either String ClientMessage]

-- | Connect to the client running in a separate process using socket
--   connection
socketMode :: WorkingMode (Socket, Socket)

-- | Connect to the client running in the same process using a channel
channelMode :: WorkingMode (Chan ResponseMsg, Chan ClientMessage)


-- | Representation of the modules and packages in the daemon session.
module Language.Haskell.Tools.Daemon.Representation

-- | The modules of a library, executable, test or benchmark. A package
--   contains one or more module collection.
data ModuleCollection k
ModuleCollection :: ModuleCollectionId -> Bool -> FilePath -> [FilePath] -> [(ModuleNameStr, FilePath)] -> (Map k ModuleRecord) -> (DynFlags -> IO DynFlags) -> (DynFlags -> IO DynFlags) -> [ModuleCollectionId] -> ModuleCollection k
[_mcId] :: ModuleCollection k -> ModuleCollectionId
[_mcLoadDone] :: ModuleCollection k -> Bool
[_mcRoot] :: ModuleCollection k -> FilePath
[_mcSourceDirs] :: ModuleCollection k -> [FilePath]
[_mcModuleFiles] :: ModuleCollection k -> [(ModuleNameStr, FilePath)]
[_mcModules] :: ModuleCollection k -> (Map k ModuleRecord)

-- | Sets up the ghc environment for compiling the modules of this
--   collection
[_mcFlagSetup] :: ModuleCollection k -> (DynFlags -> IO DynFlags)

-- | Sets up the ghc environment for dependency analysis
[_mcLoadFlagSetup] :: ModuleCollection k -> (DynFlags -> IO DynFlags)
[_mcDependencies] :: ModuleCollection k -> [ModuleCollectionId]
modCollToSfk :: ModuleCollection ModuleNameStr -> ModuleCollection SourceFileKey

-- | The state of a module.
data ModuleRecord
ModuleNotLoaded :: CodeGenPolicy -> Bool -> ModuleRecord
[_modRecCodeGen] :: ModuleRecord -> CodeGenPolicy
[_recModuleExposed] :: ModuleRecord -> Bool
ModuleParsed :: UnnamedModule -> ModSummary -> ModuleRecord
[_parsedRecModule] :: ModuleRecord -> UnnamedModule
[_modRecMS] :: ModuleRecord -> ModSummary
ModuleRenamed :: UnnamedModule -> ModSummary -> ModuleRecord
[_renamedRecModule] :: ModuleRecord -> UnnamedModule
[_modRecMS] :: ModuleRecord -> ModSummary
ModuleTypeChecked :: UnnamedModule -> ModSummary -> CodeGenPolicy -> ModuleRecord
[_typedRecModule] :: ModuleRecord -> UnnamedModule
[_modRecMS] :: ModuleRecord -> ModSummary
[_modRecCodeGen] :: ModuleRecord -> CodeGenPolicy
isLoaded :: ModuleRecord -> Bool
data CodeGenPolicy
NoCodeGen :: CodeGenPolicy
InterpretedCode :: CodeGenPolicy
GeneratedCode :: CodeGenPolicy

-- | An alias for module names
type ModuleNameStr = String

-- | This data structure identifies a module collection.
data ModuleCollectionId
DirectoryMC :: FilePath -> ModuleCollectionId
LibraryMC :: String -> ModuleCollectionId
ExecutableMC :: String -> String -> ModuleCollectionId
TestSuiteMC :: String -> String -> ModuleCollectionId
BenchmarkMC :: String -> String -> ModuleCollectionId
mcSourceDirs :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) [FilePath] [FilePath]
mcRoot :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) FilePath FilePath
mcModules :: forall k_a14Vb k'_a15pR. Lens (ModuleCollection k_a14Vb) (ModuleCollection k'_a15pR) (Map k_a14Vb ModuleRecord) (Map k'_a15pR ModuleRecord)
mcModuleFiles :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) [(ModuleNameStr, FilePath)] [(ModuleNameStr, FilePath)]
mcLoadFlagSetup :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) (DynFlags -> IO DynFlags) (DynFlags -> IO DynFlags)
mcLoadDone :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) Bool Bool
mcId :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) ModuleCollectionId ModuleCollectionId
mcFlagSetup :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) (DynFlags -> IO DynFlags) (DynFlags -> IO DynFlags)
mcDependencies :: forall k_a14Vb. Lens (ModuleCollection k_a14Vb) (ModuleCollection k_a14Vb) [ModuleCollectionId] [ModuleCollectionId]
typedRecModule :: Partial ModuleRecord ModuleRecord UnnamedModule UnnamedModule
renamedRecModule :: Partial ModuleRecord ModuleRecord UnnamedModule UnnamedModule
recModuleExposed :: Partial ModuleRecord ModuleRecord Bool Bool
parsedRecModule :: Partial ModuleRecord ModuleRecord UnnamedModule UnnamedModule
modRecMS :: Partial ModuleRecord ModuleRecord ModSummary ModSummary
modRecCodeGen :: Partial ModuleRecord ModuleRecord CodeGenPolicy CodeGenPolicy
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Representation.ModuleRecord
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Representation.ModuleCollectionId
instance GHC.Classes.Ord Language.Haskell.Tools.Daemon.Representation.ModuleCollectionId
instance GHC.Classes.Eq Language.Haskell.Tools.Daemon.Representation.ModuleCollectionId
instance GHC.Show.Show Language.Haskell.Tools.Daemon.Representation.CodeGenPolicy
instance GHC.Classes.Ord Language.Haskell.Tools.Daemon.Representation.CodeGenPolicy
instance GHC.Classes.Eq Language.Haskell.Tools.Daemon.Representation.CodeGenPolicy
instance GHC.Classes.Eq (Language.Haskell.Tools.Daemon.Representation.ModuleCollection k)
instance GHC.Show.Show k => GHC.Show.Show (Language.Haskell.Tools.Daemon.Representation.ModuleCollection k)


-- | Collecting modules contained in a module collection (library,
--   executable, testsuite or benchmark). Gets names, source file
--   locations, compilation and load flags for these modules.
module Language.Haskell.Tools.Daemon.GetModules

-- | Gets all ModuleCollections from a list of source directories. It also
--   orders the source directories that are package roots so that they can
--   be loaded in the order they are defined (no backward imports). This
--   matters in those cases because for them there can be special
--   compilation flags.
getAllModules :: [FilePath] -> IO [ModuleCollection ModuleNameStr]

-- | Sorts model collection in an order to remove all backward references.
--   Works because module collections defined by directories cannot be
--   recursive.
orderMCs :: [ModuleCollection k] -> [ModuleCollection k]

-- | Get modules of the project with the indicated root directory. If there
--   is a cabal file, it uses that, otherwise it just scans the directory
--   recursively for haskell sourcefiles. Only returns the non-boot haskell
--   modules, the boot modules will be found during loading.
getModules :: FilePath -> IO [ModuleCollection ModuleNameStr]

-- | Load the module giving a directory. All modules loaded from the folder
--   and subfolders.
modulesFromDirectory :: FilePath -> FilePath -> IO [String]
srcDirFromRoot :: FilePath -> String -> FilePath

-- | Load the module using a cabal file. The modules described in the cabal
--   file will be loaded. The flags and extensions set in the cabal file
--   will be used by default.
modulesFromCabalFile :: FilePath -> FilePath -> IO [ModuleCollection ModuleNameStr]
data UnsupportedPackage
UnsupportedPackage :: String -> UnsupportedPackage

-- | Extract module-related information from different kind of package
--   components (library, executable, test-suite or benchmark).
class ToModuleCollection t

-- | Creates a key for registering this package component.
mkModuleCollKey :: ToModuleCollection t => PackageName -> t -> ModuleCollectionId

-- | Gets the build info field from a package component.
getBuildInfo :: ToModuleCollection t => t -> BuildInfo

-- | Get the names of all the modules used by this package component.
getModuleNames :: ToModuleCollection t => t -> [ModuleName]

-- | Gets if some of the modules are defined is source files that are not
--   in the expected location or named as expected.
getModuleSourceFiles :: ToModuleCollection t => t -> [(ModuleName, FilePath)]

-- | Checks if a module is exposed by the package component, so it is
--   necessary to compile. Some of the components may have modules that are
--   only conditionally imported by other modules.
needsToCompile :: ToModuleCollection t => t -> ModuleName -> Bool

-- | Gets the Main module in the case of executables, benchmarks and test
--   suites.
getMain :: ToModuleCollection t => t -> String

-- | A default method of getting the main module using the ghc-options
--   field, checking for the option -main-is.
getMain' :: BuildInfo -> String

-- | Checks if the module collection created from a folder without .cabal
--   file.
isDirectoryMC :: ModuleCollectionId -> Bool

-- | Modify the dynamic flags to match the dependencies requested in the
--   .cabal file.
applyDependencies :: [ModuleCollectionId] -> [ModuleCollectionId] -> DynFlags -> DynFlags

-- | Only use the dependencies that are explicitely enabled. (As cabal does
--   opposed to as ghc does.)
onlyUseEnabled :: DynFlags -> DynFlags

-- | Transform dependencies of a module collection into the package flags
--   of the GHC API
dependencyToPkgFlag :: [ModuleCollectionId] -> ModuleCollectionId -> Maybe (PackageFlag)

-- | Sets the configuration for loading all the modules from the whole
--   project. Combines the configuration of all package fragments. This
--   solution is not perfect (it would be better to load all package
--   fragments separately), but it is how it works. See
--   <a>loadFlagsFromBuildInfo</a>.
setupLoadFlags :: [ModuleCollectionId] -> [FilePath] -> [ModuleCollectionId] -> (DynFlags -> IO DynFlags) -> DynFlags -> IO DynFlags

-- | Collects the compilation options and enabled extensions from Cabal's
--   build info representation. This setup will be used when loading all
--   packages in the project. See <a>setupLoadFlags</a>.
loadFlagsFromBuildInfo :: BuildInfo -> DynFlags -> IO DynFlags

-- | Collects the compilation options and enabled extensions from Cabal's
--   build info representation for a single module. See
--   <tt>compileInContext</tt>.
flagsFromBuildInfo :: BuildInfo -> DynFlags -> IO DynFlags
instance GHC.Show.Show Language.Haskell.Tools.Daemon.GetModules.UnsupportedPackage
instance Language.Haskell.Tools.Daemon.GetModules.ToModuleCollection Distribution.Types.Library.Library
instance Language.Haskell.Tools.Daemon.GetModules.ToModuleCollection Distribution.Types.Executable.Executable
instance Language.Haskell.Tools.Daemon.GetModules.ToModuleCollection Distribution.Types.TestSuite.TestSuite
instance Language.Haskell.Tools.Daemon.GetModules.ToModuleCollection Distribution.Types.Benchmark.Benchmark
instance GHC.Exception.Exception Language.Haskell.Tools.Daemon.GetModules.UnsupportedPackage


-- | Handlers for common errors in Haskell-tools daemon.
module Language.Haskell.Tools.Daemon.ErrorHandling
userExceptionHandlers :: (String -> IO a) -> ([Marker] -> [String] -> IO a) -> [Handler a]

-- | Handlers for generic exceptions: <a>IOException</a>,
--   <a>AsyncException</a>, <a>SomeException</a>.
exceptionHandlers :: IO () -> (String -> IO ()) -> [Handler ()]
getProblems :: SourceError -> ([Marker], [String])

-- | Hint text and continuation suggestion for different kinds of errors
--   based on pattern matching on error text.
handleGHCException :: String -> Maybe (String, Bool)

-- | Hint text and continuation suggestion for different kinds of source
--   problems based on pattern matching on error text.
handleSourceProblem :: String -> Maybe String

module Language.Haskell.Tools.Daemon.State

-- | The actual state of the daemon process. Contains loaded modules and
--   user settings. The GHC state is handled separately.
data DaemonSessionState
DaemonSessionState :: [ModuleCollection SourceFileKey] -> Maybe (PackageDB, Bool) -> (DynFlags -> DynFlags) -> (DynFlags -> DynFlags) -> [FilePath] -> Bool -> [[UndoRefactor]] -> Maybe WatchProcess -> [ThreadId] -> Set FilePath -> DaemonSessionState

-- | The package components loaded into the session.
[_refSessMCs] :: DaemonSessionState -> [ModuleCollection SourceFileKey]

-- | The package database that is selected and a flag to decide if it is
--   forced.
[_packageDB] :: DaemonSessionState -> Maybe (PackageDB, Bool)

-- | GHC flags for compiling modules. Overrides settings in cabal files.
[_ghcFlagsSet] :: DaemonSessionState -> DynFlags -> DynFlags
[_pkgDbFlags] :: DaemonSessionState -> DynFlags -> DynFlags

-- | The pathes where the package databases are located.
[_packageDBLocs] :: DaemonSessionState -> [FilePath]

-- | True if in the process of shutting down the session.
[_exiting] :: DaemonSessionState -> Bool

-- | True if in the process of shutting down the session.
[_undoStack] :: DaemonSessionState -> [[UndoRefactor]]

-- | Information about the file system watch process.
[_watchProc] :: DaemonSessionState -> Maybe WatchProcess

-- | Extra threads started for handling the information from the watch
--   process.
[_watchThreads] :: DaemonSessionState -> [ThreadId]

-- | Marks files as being modified by this process Changes detected on
--   marked files will not invalidate refactoring history.
[_touchedFiles] :: DaemonSessionState -> Set FilePath

-- | An initial state of a daemon session.
initSession :: DaemonSessionState
resetSession :: DaemonSessionState -> DaemonSessionState
watchThreads :: Lens DaemonSessionState DaemonSessionState [ThreadId] [ThreadId]
watchProc :: Lens DaemonSessionState DaemonSessionState (Maybe WatchProcess) (Maybe WatchProcess)
undoStack :: Lens DaemonSessionState DaemonSessionState [[UndoRefactor]] [[UndoRefactor]]
touchedFiles :: Lens DaemonSessionState DaemonSessionState (Set FilePath) (Set FilePath)
refSessMCs :: Lens DaemonSessionState DaemonSessionState [ModuleCollection SourceFileKey] [ModuleCollection SourceFileKey]
pkgDbFlags :: Lens DaemonSessionState DaemonSessionState (DynFlags -> DynFlags) (DynFlags -> DynFlags)
packageDBLocs :: Lens DaemonSessionState DaemonSessionState [FilePath] [FilePath]
packageDB :: Lens DaemonSessionState DaemonSessionState (Maybe (PackageDB, Bool)) (Maybe (PackageDB, Bool))
ghcFlagsSet :: Lens DaemonSessionState DaemonSessionState (DynFlags -> DynFlags) (DynFlags -> DynFlags)
exiting :: Lens DaemonSessionState DaemonSessionState Bool Bool


-- | Utility operations for the reprsentation of module collections.
module Language.Haskell.Tools.Daemon.Utils

-- | Get the name of a module collection from its Id.
moduleCollectionPkgId :: ModuleCollectionId -> Maybe String

-- | Find the module collection where the given module is contained. Based
--   on module name.
lookupModuleColl :: String -> [ModuleCollection SourceFileKey] -> Maybe (ModuleCollection SourceFileKey)

-- | Find the module collection where the given module is contained. Based
--   on source file name.
lookupSourceFileColl :: FilePath -> [ModuleCollection SourceFileKey] -> Maybe (ModuleCollection SourceFileKey)

-- | Find the module collection where the given module is contained. Based
--   on source file name and module name.
lookupModuleCollection :: ModSummary -> [ModuleCollection SourceFileKey] -> Maybe (ModuleCollection SourceFileKey)

-- | Find the module with the given name. Based on module name.
lookupModuleInSCs :: String -> [ModuleCollection SourceFileKey] -> Maybe (SourceFileKey, ModuleRecord)

-- | Find the module with the given name. Based on source file name.
lookupModInSCs :: SourceFileKey -> [ModuleCollection SourceFileKey] -> Maybe (SourceFileKey, ModuleRecord)

-- | Get the module with the given name and source file key.
lookupSFKInSCs :: SourceFileKey -> [ModuleCollection SourceFileKey] -> Maybe ModuleRecord

-- | Remove a module with the given name. Based on module name.
removeModule :: String -> [ModuleCollection SourceFileKey] -> [ModuleCollection SourceFileKey]

-- | Remove a module with the given name from a module collection. Based on
--   module name and file path.
removeModuleMS :: ModSummary -> Map SourceFileKey ModuleRecord -> Map SourceFileKey ModuleRecord

-- | Check if the given module needs code generation. Finds the module if
--   no source file name is present and module names check or if both
--   module names and source file names check.
needsGeneratedCode :: SourceFileKey -> [ModuleCollection SourceFileKey] -> CodeGenPolicy

-- | Marks the given module for code generation. Finds the module if no
--   source file name is present and module names check or if both module
--   names and source file names check. Idempotent operation.
codeGeneratedFor :: SourceFileKey -> CodeGenPolicy -> [ModuleCollection SourceFileKey] -> [ModuleCollection SourceFileKey]

-- | Check if the given module has been already loaded. Based on both
--   module name and source file name.
isAlreadyLoaded :: SourceFileKey -> CodeGenPolicy -> [ModuleCollection SourceFileKey] -> Bool

-- | Insert a module with a source file key to our database if it wasn't
--   there already
insertIfMissing :: SourceFileKey -> [ModuleCollection SourceFileKey] -> [ModuleCollection SourceFileKey]


-- | Common operations for managing Daemon-tools sessions, for example
--   loading whole packages or re-loading modules when they are changed.
--   Maintains the state of the compilation with loaded modules. Contains
--   checks for compiling the modules to code when Template Haskell is
--   used.
module Language.Haskell.Tools.Daemon.Session
type DaemonSession a = StateT DaemonSessionState Ghc a

-- | Load packages from the given directories. Loads modules, performs the
--   given callback action, warns for duplicate modules.
loadPackagesFrom :: (ModSummary -> IO ()) -> ([ModSummary] -> IO ()) -> (DaemonSessionState -> FilePath -> IO [FilePath]) -> [FilePath] -> DaemonSession [SourceError]

-- | Loads the packages that are declared visible (by .cabal file).
loadVisiblePackages :: DaemonSession ()

-- | Get the module that is selected for refactoring and all the other
--   modules.
getFileMods :: String -> DaemonSession (Maybe (SourceFileKey, UnnamedModule), [(SourceFileKey, UnnamedModule)])

-- | Reload the modules that have been changed (given by predicate). Pefrom
--   the callback.
reloadChangedModules :: (ModSummary -> IO a) -> ([ModSummary] -> IO ()) -> (ModSummary -> Bool) -> DaemonSession [a]

-- | Clears the given modules from the GHC state to enable re-loading them
--   From the Haskell-tools state we only clear them individually, when
--   their module collection is determined.
clearModules :: [ModSummary] -> DaemonSession ()

-- | Get all modules that can be accessed from a given set of modules. Can
--   be used to select which modules need to be reloaded after a change.
getReachableModules :: ([ModSummary] -> IO ()) -> (ModSummary -> Bool) -> DaemonSession [ModSummary]

-- | Reload a given module. Perform a callback.
reloadModule :: (ModSummary -> IO a) -> ModSummary -> DaemonSession a

-- | Select which module collection we think the module is in
decideMC :: ModSummary -> [ModuleCollection SourceFileKey] -> ModuleCollection SourceFileKey

-- | Prepares the DynFlags for the compilation of a module
withFlagsForModule :: ModuleCollection SourceFileKey -> DaemonSession a -> DaemonSession a

-- | Prepares the DynFlags for travesing the module graph
withLoadFlagsForModules :: [ModuleCollection SourceFileKey] -> DaemonSession a -> DaemonSession a

-- | Finds out if a newly added module forces us to generate code for
--   another one. If the other is already loaded it will be reloaded.
checkEvaluatedMods :: [ModSummary] -> DaemonSession ()

-- | Re-load the module with code generation enabled. Must be used when the
--   module had already been loaded, but code generation were not enabled
--   by then.
codeGenForModule :: [ModuleCollection SourceFileKey] -> CodeGenPolicy -> ModSummary -> DaemonSession ()

-- | Check which modules can be reached from the module, if it uses
--   template haskell. A definition that needs code generation can be
--   inside a module that does not uses the TemplateHaskell extension.
getEvaluatedMods :: [ModSummary] -> (ModSummary -> IO DynFlags) -> Ghc ([ModSummary], [ModSummary])

module Paths_haskell_tools_daemon
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath


-- | Resolves how the daemon should react to individual requests from the
--   client.
module Language.Haskell.Tools.Daemon.Update

-- | This function does the real job of acting upon client messages in a
--   stateful environment of a client.
updateClient :: DaemonOptions -> MVar [Marker] -> [RefactoringChoice] -> [QueryChoice] -> (ResponseMsg -> IO ()) -> ClientMessage -> DaemonSession Bool

-- | Updates the state of the tool after some files have been changed
--   (possibly by another application)
updateForFileChanges :: (ResponseMsg -> IO ()) -> MVar [Marker] -> [FilePath] -> [FilePath] -> [FilePath] -> DaemonSession ()
initGhcSession :: Bool -> IO (Session, MVar [Marker])


-- | Controls the file system watching in the daemon. The file system
--   watching must run in a separate process to prevent blocking because of
--   file operations interfering with watch.
module Language.Haskell.Tools.Daemon.Watch

-- | Starts the watch process and a thread that receives notifications from
--   it. The notification thread will invoke updates on the daemon state to
--   re-load files.
createWatchProcess' :: Maybe FilePath -> Session -> MVar DaemonSessionState -> MVar [Marker] -> (ResponseMsg -> IO ()) -> IO (Maybe WatchProcess, [ThreadId])

-- | Stops the watch process and all threads associated with it.
stopWatch :: WatchProcess -> [ThreadId] -> IO ()


-- | The central module for the background process of Haskell-tools. Starts
--   the daemon process and updates it for each client request in a loop.
--   After this releases the resources and terminates.
module Language.Haskell.Tools.Daemon

-- | Starts the daemon process. This will not return until the daemon
--   stops. You can use this entry point when the other endpoint of the
--   client connection is not needed, for example, when you use socket
--   connection to connect to the daemon process.
runDaemon' :: [RefactoringChoice] -> [QueryChoice] -> DaemonOptions -> IO ()

-- | Starts the daemon process. This will not return until the daemon
--   stops. The daemon process is parameterized by the refactorings you can
--   use in it. This entry point gives back the other endpoint of the
--   connection so it can be used to run the daemon in the same process.
runDaemon :: [RefactoringChoice] -> [QueryChoice] -> WorkingMode a -> MVar a -> DaemonOptions -> IO ()

-- | Starts the server loop, receiving requests from the client and updated
--   the server state according to these.
serverLoop :: [RefactoringChoice] -> [QueryChoice] -> WorkingMode a -> a -> DaemonOptions -> Session -> MVar DaemonSessionState -> MVar [Marker] -> IO ()

-- | Responds to a client request by modifying the daemon and GHC state
--   accordingly.
respondTo :: DaemonOptions -> [RefactoringChoice] -> [QueryChoice] -> Session -> MVar DaemonSessionState -> (ResponseMsg -> IO ()) -> MVar [Marker] -> ClientMessage -> IO Bool
