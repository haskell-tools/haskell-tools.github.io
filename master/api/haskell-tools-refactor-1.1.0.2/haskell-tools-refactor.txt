-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Refactoring Tool for Haskell
--   
--   Contains a set of refactorings based on the Haskell-Tools framework to
--   easily transform a Haskell program. For the descriptions of the
--   implemented refactorings, see the homepage.
@package haskell-tools-refactor
@version 1.1.0.2


-- | Representation of modules, their collections, refactoring changes and
--   exceptions.
module Language.Haskell.Tools.Refactor.Representation

-- | A type for the input and result of refactoring a module
type UnnamedModule = Ann UModule IdDom SrcTemplateStage

-- | The name of the module and the AST
type ModuleDom = (SourceFileKey, UnnamedModule)

-- | Module name and marker to separate .hs-boot module definitions.
--   Specifies a source file in a working directory.
data SourceFileKey
SourceFileKey :: FilePath -> String -> SourceFileKey
[_sfkFileName] :: SourceFileKey -> FilePath
[_sfkModuleName] :: SourceFileKey -> String

-- | Change in the project, modification or removal of a module.
data RefactorChange
ContentChanged :: ModuleDom -> RefactorChange
[fromContentChanged] :: RefactorChange -> ModuleDom
ModuleRemoved :: String -> RefactorChange
[removedModuleName] :: RefactorChange -> String
ModuleCreated :: String -> UnnamedModule -> SourceFileKey -> RefactorChange
[createdModuleName] :: RefactorChange -> String
[createdModuleContent] :: RefactorChange -> UnnamedModule
[sameLocation] :: RefactorChange -> SourceFileKey

-- | Exceptions that can occur while loading modules or during internal
--   operations (not during performing the refactor).
data RefactorException
IllegalExtensions :: [String] -> RefactorException
SourceCodeProblem :: ErrorMessages -> RefactorException
UnknownException :: String -> RefactorException

-- | Transforms module name to a .hs file name relative to the source root
--   directory.
moduleSourceFile :: String -> FilePath

-- | Transforms a source root relative file name into module name.
sourceFileModule :: FilePath -> String
sfkModuleName :: Lens SourceFileKey SourceFileKey String String
sfkFileName :: Lens SourceFileKey SourceFileKey FilePath FilePath
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.RefactorException
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Classes.Ord Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Exception.Exception Language.Haskell.Tools.Refactor.Representation.RefactorException
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.RefactorChange
instance GHC.Show.Show ErrUtils.ErrorMessages


-- | Types and instances for monadic refactorings. The refactoring monad
--   provides automatic importing, keeping important source fragments (such
--   as preprocessor pragmas), and providing contextual information for
--   refactorings.
module Language.Haskell.Tools.Refactor.Monad

-- | A monad that can be used to refactor
class Monad m => RefactorMonad m
refactError :: RefactorMonad m => String -> m a
liftGhc :: RefactorMonad m => Ghc a -> m a

-- | A refactoring that only affects one module
type LocalRefactoring = UnnamedModule -> LocalRefactor UnnamedModule

-- | The type of a refactoring
type Refactoring = ModuleDom -> [ModuleDom] -> Refactor [RefactorChange]

-- | The type of a refactoring that affects the whole project.
type ProjectRefactoring = [ModuleDom] -> Refactor [RefactorChange]

-- | The refactoring monad for a given module
type LocalRefactor = LocalRefactorT Refactor

-- | The refactoring monad for the whole project
type Refactor = ExceptT String Ghc

-- | Input and output information for the refactoring TODO: use multiple
--   states instead of Either
newtype LocalRefactorT m a
LocalRefactorT :: WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a -> LocalRefactorT m a
[fromRefactorT] :: LocalRefactorT m a -> WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a

-- | The information a refactoring can use
data RefactorCtx
RefactorCtx :: Module -> Ann UModule IdDom SrcTemplateStage -> [Ann UImportDecl IdDom SrcTemplateStage] -> RefactorCtx

-- | The name of the module being refactored. Used for accessing implicit
--   imports.
[refModuleName] :: RefactorCtx -> Module
[refCtxRoot] :: RefactorCtx -> Ann UModule IdDom SrcTemplateStage
[refCtxImports] :: RefactorCtx -> [Ann UImportDecl IdDom SrcTemplateStage]
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => Control.Monad.Writer.Class.MonadWriter [Data.Either.Either Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)] (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Language.Haskell.Tools.Refactor.Monad.RefactorCtx (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad Language.Haskell.Tools.Refactor.Monad.LocalRefactor
instance Control.Monad.Trans.Class.MonadTrans Language.Haskell.Tools.Refactor.Monad.LocalRefactorT
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad Language.Haskell.Tools.Refactor.Monad.Refactor
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad m => Language.Haskell.Tools.Refactor.Monad.RefactorMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad m => Language.Haskell.Tools.Refactor.Monad.RefactorMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GhcMonad.GhcMonad m, GHC.Base.Monoid s) => GhcMonad.GhcMonad (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (Exception.ExceptionMonad m, GHC.Base.Monoid s) => Exception.ExceptionMonad (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.State.Strict.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.State.Lazy.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.Reader.ReaderT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Reader.ReaderT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.Except.ExceptT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Except.ExceptT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Maybe.MaybeT m)


-- | Operations for changing the AST
module Language.Haskell.Tools.Refactor.Utils.AST

-- | Remove an element from the AST while keeping the textual parts of it
--   that should not be removed (like preprocessor pragmas).
removeChild :: (SourceInfoTraversal e) => e dom SrcTemplateStage -> LocalRefactor ()

-- | Remove a separator from the AST while keeping the textual parts of it
--   that should not be removed (like preprocessor pragmas).
removeSeparator :: ([SourceTemplateTextElem], SrcSpan) -> LocalRefactor ()


-- | Utilities for transformations that work on both top-level and local
--   definitions
module Language.Haskell.Tools.Refactor.Utils.BindingElem

-- | A type class for handling definitions that can appear as both
--   top-level and local definitions
class NamedElement d => BindingElem d

-- | Accesses a type signature definition in a local or top-level
--   definition
sigBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) TypeSignature

-- | Accesses a value or function definition in a local or top-level
--   definition
valBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) ValueBind

-- | Accesses a type signature definition in a local or top-level
--   definition
fixitySig :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) FixitySignature

-- | Creates a new definition from a type signature
createTypeSig :: BindingElem d => TypeSignature -> Ann d IdDom SrcTemplateStage

-- | Creates a new definition from a value or function definition
createBinding :: BindingElem d => ValueBind -> Ann d IdDom SrcTemplateStage

-- | Creates a new fixity signature
createFixitySig :: BindingElem d => FixitySignature -> Ann d IdDom SrcTemplateStage

-- | Checks if a given definition is a type signature
isTypeSig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a function or value binding
isBinding :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a fixity signature
isFixitySig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool
getValBindInList :: BindingElem d => RealSrcSpan -> AnnList d -> Maybe ValueBind
valBindsInList :: BindingElem d => Simple Traversal (AnnList d) ValueBind
instance Language.Haskell.Tools.Refactor.Utils.BindingElem.BindingElem Language.Haskell.Tools.AST.Representation.Decls.UDecl
instance Language.Haskell.Tools.Refactor.Utils.BindingElem.BindingElem Language.Haskell.Tools.AST.Representation.Binds.ULocalBind

module Language.Haskell.Tools.Refactor.Utils.Debug
debugM :: (Monad m, Show a) => m a -> m a
debug :: Show a => a -> a

-- | Displays True iff the wrapped value is a Just
debugMaybeT :: Monad m => MaybeT m a -> MaybeT m a
showOutputable :: Outputable a => a -> String
showName :: Name -> String
showOp :: Operator -> String

module Language.Haskell.Tools.Refactor.Utils.Extensions

-- | Expands an extension into all the extensions it implies (keeps
--   original as well)
expandExtension :: Extension -> [Extension]

-- | Replaces deprecated extensions with their new counterpart
replaceDeprecated :: Extension -> Extension
turnOn :: Bool
turnOff :: Bool
impliedXFlags :: [(Extension, Bool, Extension)]

-- | These extensions' GHC representation name differs from their actual
--   name
irregularExtensions :: [(String, String)]

-- | Canonicalize extensions. This is a helper function for parsing
--   extensions This way we can say <tt>read . canonExt</tt> to parse any
--   extension string
canonExt :: String -> String

-- | Serializes the extension's GHC name into its LANGUAGE pragma name.
--   Should be always used in composition with show (<tt>seriealizeExt .
--   show</tt>) when refactoring extensions. This function also replaces
--   depracted extensions with their new versions.
serializeExt :: String -> String

-- | Map the cabal extensions to the ones that GHC recognizes
translateExtension :: KnownExtension -> Maybe Extension

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension


-- | Utilities to modify the indentation of AST fragments
module Language.Haskell.Tools.Refactor.Utils.Indentation

-- | Set the minimal indentation recursively for a part of the AST
setMinimalIndent :: SourceInfoTraversal elem => Int -> elem dom SrcTemplateStage -> elem dom SrcTemplateStage


-- | Defines operation on AST lists. AST lists carry source information so
--   simple list modification is not enough.
module Language.Haskell.Tools.Refactor.Utils.Lists

-- | Filters the elements of the list. By default it removes the separator
--   before the element. Of course, if the first element is removed, the
--   following separator is removed as well.
filterList :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e
filterListIndexed :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e

-- | A version of filterList that cares about keeping non-removable code
--   elements (like preprocessor pragmas)
filterListSt :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | A version of filterListIndexed that cares about keeping non-removable
--   code elements (like preprocessor pragmas)
filterListIndexedSt :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | Selects the given indices from a list
sublist :: [Int] -> [a] -> [a]

-- | Selects all but the given indices from a list
notSublist :: [Int] -> [a] -> [a]

-- | Inserts the element in the places where the two positioning functions
--   (one checks the element before, one the element after) allows the
--   placement.
insertWhere :: Bool -> Ann e IdDom SrcTemplateStage -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> AnnList e -> AnnList e

-- | Checks where the element will be inserted given the two positioning
--   functions.
insertIndex :: (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> [Ann e IdDom SrcTemplateStage] -> Maybe Int

-- | Gets the elements and separators from a list. The first separator is
--   zipped to the second element. To the first element, the "" string is
--   zipped.
zipWithSeparators :: AnnList e -> [(([SourceTemplateTextElem], SrcSpan), Ann e IdDom SrcTemplateStage)]


-- | Helper functions for defining refactorings.
module Language.Haskell.Tools.Refactor.Utils.Helpers
replaceWithJust :: Ann e IdDom SrcTemplateStage -> AnnMaybe e -> AnnMaybe e
replaceWithNothing :: AnnMaybe e -> AnnMaybe e

-- | Remove the container (where or let) when the last binding is removed.
removeEmptyBnds :: Simple Traversal Module ValueBind -> Simple Traversal Module Expr -> Module -> Module

-- | Puts the elements in the orginal order and remove duplicates (elements
--   with the same source range)
normalizeElements :: [Ann e dom SrcTemplateStage] -> [Ann e dom SrcTemplateStage]

-- | Groups elements together into equivalence groups.
groupElemsBy :: Ord k => (a -> k) -> [a] -> [[a]]

-- | Chooses a representative element for each equivalence group, and pairs
--   them with their corresponding group.
reprElems :: [[a]] -> [(a, [a])]

-- | Sorts the elements of a list into equivalence groups based on a
--   function, then chooses a representative element for each group, and
--   pairs them with their corresponding group.
equivalenceGroupsBy :: Ord k => (a -> k) -> [a] -> [(a, [a])]

module Language.Haskell.Tools.Refactor.Utils.Maybe
isJustT :: Monad m => MaybeT m a -> m Bool
isNothingT :: Monad m => MaybeT m a -> m Bool
liftMaybe :: Monad m => Maybe a -> MaybeT m a
fromMaybeT :: Monad m => a -> MaybeT m a -> m a
fromMaybeTM :: Monad m => m a -> MaybeT m a -> m a
maybeT :: Monad m => b -> (a -> b) -> MaybeT m a -> m b
maybeTM :: Monad m => m b -> (a -> m b) -> MaybeT m a -> m b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: * -> *) a
MaybeT :: m Maybe a -> MaybeT a
[runMaybeT] :: MaybeT a -> m Maybe a


-- | Basic utilities and types for defining refactorings.
module Language.Haskell.Tools.Refactor.Utils.Monadic

-- | Performs the given refactoring, transforming it into a Ghc action
runRefactor :: ModuleDom -> [ModuleDom] -> Refactoring -> Ghc (Either String [RefactorChange])

-- | Wraps a refactoring that only affects one module. Performs the
--   per-module finishing touches.
localRefactoring :: LocalRefactoring -> Refactoring

-- | Transform the result of the local refactoring
localRefactoringRes :: ((UnnamedModule -> UnnamedModule) -> a -> a) -> UnnamedModule -> LocalRefactor a -> Refactor a

-- | Re-inserts the elements removed from the AST that should be kept (for
--   example preprocessor directives)
insertText :: SourceInfoTraversal p => [(SrcSpan, String, String)] -> p dom SrcTemplateStage -> p dom SrcTemplateStage

-- | Adds the imports that bring names into scope that are needed by the
--   refactoring
addGeneratedImports :: [Name] -> Module -> Module
registeredNamesFromPrelude :: [Name]
otherNamesFromPrelude :: [String]
qualifiedName :: Name -> String
referenceName :: Name -> LocalRefactor (Ann UName IdDom SrcTemplateStage)
referenceOperator :: Name -> LocalRefactor (Ann UOperator IdDom SrcTemplateStage)

-- | Create a name that references the definition. Generates an import if
--   the definition is not yet imported.
referenceName' :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> LocalRefactor (Ann nt IdDom SrcTemplateStage)

-- | Reference the name by the shortest suitable import
referenceBy :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> [Ann UImportDecl IdDom SrcTemplateStage] -> Ann nt IdDom SrcTemplateStage


-- | Defines utility methods that prepare Haskell modules for refactoring
module Language.Haskell.Tools.Refactor.Prepare

-- | Type synonym for module names.
type ModuleName = String

-- | A quick function to try the refactorings
tryRefactor :: (RealSrcSpan -> Refactoring) -> String -> ModuleName -> IO ()

-- | Adjust the source range to be applied to the refactored module
correctRefactorSpan :: UnnamedModule -> RealSrcSpan -> RealSrcSpan

-- | Set the given flags for the GHC session. Also gives back a change
--   function that you can use to apply the settings to any flags. Prints
--   out errors and warnings
useFlags :: [String] -> Ghc ([String], DynFlags -> DynFlags)
pprWarning :: Warn -> SDoc
pprErr :: Err -> SDoc

-- | Reloads the package database based on the session flags
reloadPkgDb :: Ghc ()

-- | Initialize GHC flags to default values that support refactoring
initGhcFlags :: Ghc ()
initGhcFlagsForTest :: Ghc ()

-- | Sets up basic flags and settings for GHC
initGhcFlags' :: Bool -> Bool -> Ghc ()

-- | Use the given source directories when searching for imported modules
useDirs :: [FilePath] -> Ghc ()

-- | Don't use the given source directories when searching for imported
--   modules
deregisterDirs :: [FilePath] -> Ghc ()

-- | Translates module name and working directory into the name of the file
--   where the given module should be defined
toFileName :: FilePath -> ModuleName -> FilePath

-- | Translates module name and working directory into the name of the file
--   where the boot module should be defined
toBootFileName :: FilePath -> ModuleName -> FilePath

-- | Get the source directory where the module is located.
getSourceDir :: ModSummary -> IO FilePath

-- | Gets the path to the source file of the module.
getModSumOrig :: ModSummary -> FilePath
keyFromMS :: ModSummary -> SourceFileKey

-- | Gets the module name
getModSumName :: ModSummary -> String

-- | Load the AST of a module given by the working directory and module
--   name.
loadModuleAST :: FilePath -> ModuleName -> Ghc TypedModule

-- | Load the summary of a module given by the working directory and module
--   name.
loadModule :: FilePath -> ModuleName -> Ghc ModSummary

-- | The final version of our AST, with type infromation added
type TypedModule = Ann UModule IdDom SrcTemplateStage

-- | Get the typed representation of a Haskell module.
parseTyped :: ModSummary -> Ghc TypedModule
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension
trfProblem :: String -> a

-- | Modifies the dynamic flags for performing a ghc task
withAlteredDynFlags :: GhcMonad m => (DynFlags -> m DynFlags) -> m a -> m a

-- | Forces the code generation for a given module
forceCodeGen :: ModSummary -> ModSummary
codeGenDfs :: DynFlags -> DynFlags

-- | Forces ASM code generation for a given module
forceAsmGen :: ModSummary -> ModSummary

-- | Normalizes the flags for a module summary
modSumNormalizeFlags :: ModSummary -> ModSummary

-- | Removes all flags that are unintelligable for refactoring
normalizeFlags :: DynFlags -> DynFlags

-- | Read a source range from our textual format:
--   <tt>line:col-line:col</tt> or <tt>line:col</tt>
readSrcSpan :: String -> RealSrcSpan

-- | Read a source location from our format: <tt>line:col</tt>
readSrcLoc :: String -> RealSrcLoc
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Prepare.UnsupportedExtension
instance GHC.Exception.Exception Language.Haskell.Tools.Refactor.Prepare.UnsupportedExtension


-- | Defines a representation to represent refactorings that can be
--   executed on the codebase. Refactorings are differentiated on their
--   signatures (inputs needed to execute).
module Language.Haskell.Tools.Refactor.Refactoring

-- | The signature and behavior of one refactoring that can be executed.
data RefactoringChoice
NamingRefactoring :: String -> RealSrcSpan -> String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoring] :: RefactoringChoice -> RealSrcSpan -> String -> Refactoring
NamingRefactoringIndent :: String -> RealSrcSpan -> String -> Maybe String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoringIndent] :: RefactoringChoice -> RealSrcSpan -> String -> Maybe String -> Refactoring
SelectionRefactoring :: String -> RealSrcSpan -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[selectionRefactoring] :: RefactoringChoice -> RealSrcSpan -> Refactoring
ModuleRefactoring :: String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[moduleRefactoring] :: RefactoringChoice -> Refactoring
ProjectRefactoring :: String -> ProjectRefactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[projectRefactoring] :: RefactoringChoice -> ProjectRefactoring

-- | Executes a given command (choosen from the set of available
--   refactorings) on the selected module and given other modules.
performCommand :: [RefactoringChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String [RefactorChange])

-- | Gets the name of possible refactorings.
refactorCommands :: [RefactoringChoice] -> [String]

module Language.Haskell.Tools.Refactor.Querying
type QueryType = String
type QueryMonad = ExceptT String Ghc
data QueryValue
GeneralQuery :: Value -> QueryValue
MarkerQuery :: [Marker] -> QueryValue
data QueryChoice
LocationQuery :: String -> RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue -> QueryChoice
[queryName] :: QueryChoice -> String
[locationQuery] :: QueryChoice -> RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
GlobalQuery :: String -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue -> QueryChoice
[queryName] :: QueryChoice -> String
[globalQuery] :: QueryChoice -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
data Marker
Marker :: SrcSpan -> Severity -> String -> Marker
[location] :: Marker -> SrcSpan
[severity] :: Marker -> Severity
[message] :: Marker -> String
data Severity
Error :: Severity
Warning :: Severity
Info :: Severity
decompQuery :: QueryValue -> (QueryType, Value)
queryCommands :: [QueryChoice] -> [String]
queryError :: String -> QueryMonad a
performQuery :: [QueryChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String (QueryType, Value))
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Querying.QueryValue
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Querying.QueryValue
instance GHC.Generics.Generic Language.Haskell.Tools.Refactor.Querying.QueryValue
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Querying.Marker
instance GHC.Generics.Generic Language.Haskell.Tools.Refactor.Querying.Marker
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Querying.Severity
instance GHC.Generics.Generic Language.Haskell.Tools.Refactor.Querying.Severity
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Querying.Severity
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Refactor.Querying.QueryValue
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Refactor.Querying.Marker
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Querying.Marker
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Tools.Refactor.Querying.Severity
instance Data.Aeson.Types.ToJSON.ToJSON SrcLoc.SrcSpan


-- | Defines utility operations on Haskell names such as checking if a
--   given identifier is a correct name for a certain kind of Haskell
--   construct.
module Language.Haskell.Tools.Refactor.Utils.Name

-- | Different classes of definitions that have different kind of names.
data NameClass

-- | Normal value definitions: functions, variables
Variable :: NameClass

-- | Data constructors
Ctor :: NameClass

-- | Functions with operator-like names
ValueOperator :: NameClass

-- | Constructors with operator-like names
DataCtorOperator :: NameClass

-- | UType definitions with operator-like names
SynonymOperator :: NameClass

-- | Get which category does a given name belong to
classifyName :: RefactorMonad m => Name -> m NameClass

-- | Checks if a given name is a valid module name
validModuleName :: String -> Maybe String

-- | Check if a given name is valid for a given kind of definition
nameValid :: NameClass -> String -> Maybe String
isIdChar :: Char -> Bool
isOperatorChar :: Char -> Bool

module Language.Haskell.Tools.Refactor.Utils.NameLookup
opSemName :: Operator -> Maybe Name
declHeadQName :: DeclHead -> QualifiedName
declHeadSemName :: DeclHead -> Maybe Name
instHeadSemName :: InstanceHead -> Maybe Name

-- | Collects the qualified names of the class heads in an assertion.
assertionQNames :: Assertion -> [QualifiedName]

-- | Collects the semantic names of the class heads in an assertion.
assertionSemNames :: Assertion -> [Name]

-- | Extracts the name of a type. In case of a type application, it finds
--   the type being applied. It works only for unambiguous types, so it
--   won't work for tuples.
nameFromType :: Type -> Maybe Name
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Name.Name
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Language.Haskell.Tools.Rewrite.ElementTypes.Operator
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Language.Haskell.Tools.Rewrite.ElementTypes.DeclHead
instance Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo' Language.Haskell.Tools.Rewrite.ElementTypes.InstanceHead

module Language.Haskell.Tools.Refactor.Utils.Type
typeExpr :: Expr -> Ghc Type
appTypeMatches :: [ClsInst] -> Type -> [Type] -> Maybe (TCvSubst, Type)
literalType :: Literal -> Ghc Type

module Language.Haskell.Tools.Refactor.Utils.TypeLookup
type ClosedTyFam = CoAxiom Branched
hasConstraintKind :: Type -> Bool

-- | Looks up the Type of an entity with an Id of any locality. If the
--   entity being scrutinised is a type variable, it fails.
lookupTypeFromId :: (HasIdInfo' id, GhcMonad m) => id -> MaybeT m Type

-- | Looks up the Type or the Kind of an entity that has an Id. Note: In
--   some cases we only get the Kind of the Id (e.g. for type constructors)
typeOrKindFromId :: HasIdInfo' id => id -> Type

-- | Extracts a Type from a TyThing when possible.
typeFromTyThing :: TyThing -> Maybe Type

-- | Looks up a GHC Type from a Haskell Tools Name (given the name is
--   global) For an identifier, it returns its type. For a data
--   constructor, it returns its type. For a pattern synonym, it returns
--   its builder's type. For a type synonym constructor, it returns its
--   right-hand side. For a coaxiom, it fails.
lookupTypeFromGlobalName :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Name corresponding to a type synonym
lookupTypeSynRhs :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type
lookupSynDef :: TyThing -> Maybe TyCon
tyconFromTyThing :: TyThing -> Maybe TyCon
tyconFromGHCType :: Type -> Maybe TyCon
isNewtype :: GhcMonad m => Type -> m Bool
lookupType :: GhcMonad m => Type -> MaybeT m TyThing

-- | Looks up a GHC.Class from something that has a type class constructor
--   in it Fails if the argument does not contain a class type constructor
lookupClassWith :: GhcMonad m => (a -> MaybeT m Name) -> a -> MaybeT m Class
lookupClass :: (GhcMonad m, HasNameInfo' n) => n -> MaybeT m Class
lookupClassFromInstance :: GhcMonad m => InstanceHead -> MaybeT m Class
lookupClassFromDeclHead :: GhcMonad m => DeclHead -> MaybeT m Class

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Type corresponding to a type synonym
semanticsTypeSynRhs :: GhcMonad m => Type -> MaybeT m Type

-- | Converts a global Haskell Tools type to a GHC type
semanticsType :: GhcMonad m => Type -> MaybeT m Type
isNewtypeTyCon :: TyThing -> Bool

-- | Looks up the given name, extracts something out of it. If the
--   extraction is not succesful, it returns False, if it is successful,
--   then checks the result against the predicate. The reasoning behind
--   this, is that the predicate can only be satisfied by a proper name.
satisfies :: (HasNameInfo' n, GhcMonad m) => (TyThing -> Maybe a) -> (a -> Bool) -> n -> MaybeT m Bool

-- | Decides whether a given name is a type family constructor. Fails if
--   the lookup is not successful.
isClassTyConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Decides whether a given name is a standard Haskell98 data constructor.
--   Fails if the lookup is not successful.
isVanillaDataConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Looks up a closed type family from a name.
lookupClosedTyFam :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m ClosedTyFam

-- | Extract the CoAxioms from a TyThing representing a closed type family.
coAxiomFromTyThing :: TyThing -> Maybe (CoAxiom Branched)

-- | Determines whether a Type itself has a type variable head.
hasTyVarHead :: Type -> Bool
instance GHC.Classes.Eq TyCoRep.Type


-- | Defines the API for refactorings
module Language.Haskell.Tools.Refactor

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: () => b -> a -> b -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: () => Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: () => Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: () => [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: () => [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: () => a -> Maybe b -> [a] -> [b]

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: () => String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: () => String -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: () => String -> a -> a

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <tt>MonadIO</tt>, <tt>liftIO . traceIO</tt> may be a
--   better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   "hello
--   hello"
--   </pre>
traceId :: String -> String

putTraceMsg :: String -> IO ()

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: () => Maybe a -> a

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: * -> *) a
MaybeT :: m Maybe a -> MaybeT a
[runMaybeT] :: MaybeT a -> m Maybe a
inScope :: Name -> Scope -> Bool

-- | Compares two source spans based on their lengths. Can only used for
--   NESTED spans.
compareRangeLength :: SrcSpan -> SrcSpan -> Ordering

-- | Get the shortest source range that contains the given
getNodeContaining :: (Biplate Ann node dom stage Ann inner dom stage, SourceInfo stage, HasRange Ann inner dom stage) => RealSrcSpan -> Ann node dom stage -> Maybe Ann inner dom stage

-- | Get the nodes that have exactly the given range
nodesWithRange :: (Biplate Ann node dom stage Ann inner dom stage, SourceInfo stage) => RealSrcSpan -> Simple Traversal Ann node dom stage Ann inner dom stage

-- | Return true if the node contains a given range
isContained :: HasRange inner dom stage => RealSrcSpan -> inner dom stage -> Bool

-- | Get all nodes that are contained in a given source range
nodesContained :: (HasRange inner dom stage, Biplate node dom stage inner dom stage) => RealSrcSpan -> Simple Traversal node dom stage inner dom stage

-- | Return true if the node contains a given range
isInside :: HasRange inner dom stage => RealSrcSpan -> inner dom stage -> Bool

-- | Get all nodes that contain a given source range
nodesContaining :: (HasRange inner dom stage, Biplate node dom stage inner dom stage) => RealSrcSpan -> Simple Traversal node dom stage inner dom stage

-- | Access the semantic information of an AST node.
semantics :: RefMonads w r => Reference w r MU MU Ann elem dom stage Ann elem dom stage SemanticInfo dom elem SemanticInfo dom elem
valBindPats :: (RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU Ann UValueBind dom stage Ann UValueBind dom stage Ann UPattern dom stage Ann UPattern dom stage

-- | A reference to access type arguments to a type constructor call that
--   may be universally qualified or parenthesized.
typeParams :: (RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage

-- | Accesses that name of a declaration through the declaration head.
declHeadNames :: (RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UQualifiedName dom stage Ann UQualifiedName dom stage

-- | Accesses the name of a function or value binding
bindingName :: (RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU Ann UValueBind dom stage Ann UValueBind dom stage Ann UQualifiedName dom stage Ann UQualifiedName dom stage

-- | Does the import declaration import all elements that are not excluded
--   explicitly?
importIsHiding :: () => Ann UImportDecl dom stage -> Bool

-- | Does the import declaration import only the explicitly listed
--   elements?
importIsExact :: () => Ann UImportDecl dom stage -> Bool

-- | A class to access the names of named elements. Have to locate where
--   does the AST element store its name. The returned name will be the one
--   that was marked isDefining.
class NamedElement (elem :: * -> * -> *)
elementName :: (NamedElement elem, RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU Ann elem dom st Ann elem dom st Ann UQualifiedName dom st Ann UQualifiedName dom st
stringNodeStr :: RefMonads w r => Reference w r MU MU Ann UStringNode dom stage Ann UStringNode dom stage String String
simpleNameStr :: RefMonads w r => Reference w r MU MU Ann UNamePart dom stage Ann UNamePart dom stage String String
unqualifiedName :: RefMonads w r => Reference w r MU MU Ann UQualifiedName dom stage Ann UQualifiedName dom stage Ann UNamePart dom stage Ann UNamePart dom stage
qualifiers :: RefMonads w r => Reference w r MU MU Ann UQualifiedName dom stage Ann UQualifiedName dom stage AnnListG UNamePart dom stage AnnListG UNamePart dom stage
simpleName :: RefMonads w r => Reference w r MU MU Ann UName dom stage Ann UName dom stage Ann UQualifiedName dom stage Ann UQualifiedName dom stage
operatorName :: RefMonads w r => Reference w r MU MU Ann UOperator dom stage Ann UOperator dom stage Ann UQualifiedName dom stage Ann UQualifiedName dom stage
promotedStringValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPromoted t dom stage Ann UPromoted t dom stage String String
promotedIntValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPromoted t dom stage Ann UPromoted t dom stage Integer Integer
promotedElements :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPromoted t dom stage Ann UPromoted t dom stage AnnListG t dom stage AnnListG t dom stage
promotedConName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPromoted t dom stage Ann UPromoted t dom stage Ann UName dom stage Ann UName dom stage
stringLitValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULiteral dom stage Ann ULiteral dom stage String String
intLitValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULiteral dom stage Ann ULiteral dom stage Integer Integer
fracLitValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULiteral dom stage Ann ULiteral dom stage Rational Rational
floatLitValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULiteral dom stage Ann ULiteral dom stage Rational Rational
charLitValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULiteral dom stage Ann ULiteral dom stage Char Char
bracketType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UBracket dom stage Ann UBracket dom stage Ann UType dom stage Ann UType dom stage
bracketPattern :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UBracket dom stage Ann UBracket dom stage Ann UPattern dom stage Ann UPattern dom stage
bracketExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UBracket dom stage Ann UBracket dom stage Ann UExpr dom stage Ann UExpr dom stage
bracketDecl :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UBracket dom stage Ann UBracket dom stage AnnListG UDecl dom stage AnnListG UDecl dom stage
qqString :: RefMonads w r => Reference w r MU MU Ann QQString dom stage Ann QQString dom stage String String
qqExprName :: RefMonads w r => Reference w r MU MU Ann UQuasiQuote dom stage Ann UQuasiQuote dom stage Ann UName dom stage Ann UName dom stage
qqExprBody :: RefMonads w r => Reference w r MU MU Ann UQuasiQuote dom stage Ann UQuasiQuote dom stage Ann QQString dom stage Ann QQString dom stage
spliceId :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann USplice dom stage Ann USplice dom stage Ann UName dom stage Ann UName dom stage
spliceExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann USplice dom stage Ann USplice dom stage Ann UExpr dom stage Ann UExpr dom stage
fieldPatternWildcard :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatternField dom stage Ann UPatternField dom stage Ann UFieldWildcard dom stage Ann UFieldWildcard dom stage
fieldPatternName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatternField dom stage Ann UPatternField dom stage Ann UName dom stage Ann UName dom stage
fieldPattern :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatternField dom stage Ann UPatternField dom stage Ann UPattern dom stage Ann UPattern dom stage
patternType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UType dom stage Ann UType dom stage
patternSumPlaceholdersBefore :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage AnnListG UUnboxedSumPlaceHolder dom stage AnnListG UUnboxedSumPlaceHolder dom stage
patternSumPlaceholdersAfter :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage AnnListG UUnboxedSumPlaceHolder dom stage AnnListG UUnboxedSumPlaceHolder dom stage
patternSplice :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann USplice dom stage Ann USplice dom stage
patternRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UPattern dom stage Ann UPattern dom stage
patternOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UOperator dom stage Ann UOperator dom stage
patternName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UName dom stage Ann UName dom stage
patternLiteral :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann ULiteral dom stage Ann ULiteral dom stage
patternLit :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann ULiteral dom stage Ann ULiteral dom stage
patternLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UPattern dom stage Ann UPattern dom stage
patternInner :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UPattern dom stage Ann UPattern dom stage
patternFields :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage AnnListG UPatternField dom stage AnnListG UPatternField dom stage
patternExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UExpr dom stage Ann UExpr dom stage
patternElems :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage AnnListG UPattern dom stage AnnListG UPattern dom stage
patternArgs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage AnnListG UPattern dom stage AnnListG UPattern dom stage
patQQ :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPattern dom stage Ann UPattern dom stage Ann UQuasiQuote dom stage Ann UQuasiQuote dom stage
cmdThen :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage
cmdStmts :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage AnnListG UCmdStmt dom stage AnnListG UCmdStmt dom stage
cmdRightCmd :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage
cmdRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UExpr dom stage Ann UExpr dom stage
cmdOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UName dom stage Ann UName dom stage
cmdLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UExpr dom stage Ann UExpr dom stage
cmdLeftCmd :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage
cmdInnerCmds :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage AnnListG UCmd dom stage AnnListG UCmd dom stage
cmdInnerCmd :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage
cmdInner :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage
cmdExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UExpr dom stage Ann UExpr dom stage
cmdElse :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage Ann UCmd dom stage
cmdBinds :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage AnnListG ULocalBind dom stage AnnListG ULocalBind dom stage
cmdBindings :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage AnnListG UPattern dom stage AnnListG UPattern dom stage
cmdArrowOp :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UArrowAppl dom stage Ann UArrowAppl dom stage
cmdApplied :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage Ann UExpr dom stage Ann UExpr dom stage
cmdAlts :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCmd dom stage Ann UCmd dom stage AnnListG UCmdAlt dom stage AnnListG UCmdAlt dom stage
compStmts :: RefMonads w r => Reference w r MU MU Ann UListCompBody dom stage Ann UListCompBody dom stage AnnListG UCompStmt dom stage AnnListG UCompStmt dom stage
usingExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCompStmt dom stage Ann UCompStmt dom stage AnnMaybeG UExpr dom stage AnnMaybeG UExpr dom stage
thenExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCompStmt dom stage Ann UCompStmt dom stage Ann UExpr dom stage Ann UExpr dom stage
compStmt :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCompStmt dom stage Ann UCompStmt dom stage Ann UStmt dom stage Ann UStmt dom stage
byExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCompStmt dom stage Ann UCompStmt dom stage AnnMaybeG UExpr dom stage AnnMaybeG UExpr dom stage
stmtPattern :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UStmt' expr dom stage Ann UStmt' expr dom stage Ann UPattern dom stage Ann UPattern dom stage
stmtExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UStmt' expr dom stage Ann UStmt' expr dom stage Ann expr dom stage Ann expr dom stage
stmtBinds :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UStmt' expr dom stage Ann UStmt' expr dom stage AnnListG ULocalBind dom stage AnnListG ULocalBind dom stage
cmdStmtBinds :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UStmt' expr dom stage Ann UStmt' expr dom stage AnnListG UStmt' expr dom stage AnnListG UStmt' expr dom stage
caseGuardStmts :: RefMonads w r => Reference w r MU MU Ann UGuardedCaseRhs' expr dom stage Ann UGuardedCaseRhs' expr dom stage AnnListG URhsGuard dom stage AnnListG URhsGuard dom stage
caseGuardExpr :: RefMonads w r => Reference w r MU MU Ann UGuardedCaseRhs' expr dom stage Ann UGuardedCaseRhs' expr dom stage Ann expr dom stage Ann expr dom stage
rhsCaseGuards :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCaseRhs' expr dom stage Ann UCaseRhs' expr dom stage AnnListG UGuardedCaseRhs' expr dom stage AnnListG UGuardedCaseRhs' expr dom stage
rhsCaseExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UCaseRhs' expr dom stage Ann UCaseRhs' expr dom stage Ann expr dom stage Ann expr dom stage
pragmaStr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExprPragma dom stage Ann UExprPragma dom stage Ann UStringNode dom stage Ann UStringNode dom stage
pragmaSrcRange :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExprPragma dom stage Ann UExprPragma dom stage Ann USourceRange dom stage Ann USourceRange dom stage
tupSecExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTupSecElem dom stage Ann UTupSecElem dom stage Ann UExpr dom stage Ann UExpr dom stage
fieldWildcard :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UFieldUpdate dom stage Ann UFieldUpdate dom stage Ann UFieldWildcard dom stage Ann UFieldWildcard dom stage
fieldValue :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UFieldUpdate dom stage Ann UFieldUpdate dom stage Ann UExpr dom stage Ann UExpr dom stage
fieldUpdateName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UFieldUpdate dom stage Ann UFieldUpdate dom stage Ann UName dom stage Ann UName dom stage
fieldName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UFieldUpdate dom stage Ann UFieldUpdate dom stage Ann UName dom stage Ann UName dom stage
altRhs :: RefMonads w r => Reference w r MU MU Ann UAlt' expr dom stage Ann UAlt' expr dom stage Ann UCaseRhs' expr dom stage Ann UCaseRhs' expr dom stage
altPattern :: RefMonads w r => Reference w r MU MU Ann UAlt' expr dom stage Ann UAlt' expr dom stage Ann UPattern dom stage Ann UPattern dom stage
altBinds :: RefMonads w r => Reference w r MU MU Ann UAlt' expr dom stage Ann UAlt' expr dom stage AnnMaybeG ULocalBinds dom stage AnnMaybeG ULocalBinds dom stage
tupleSectionElems :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UTupSecElem dom stage AnnListG UTupSecElem dom stage
tupleElems :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UExpr dom stage AnnListG UExpr dom stage
quotedName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UName dom stage Ann UName dom stage
procPattern :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UPattern dom stage Ann UPattern dom stage
procExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UCmd dom stage Ann UCmd dom stage
listElems :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UExpr dom stage AnnListG UExpr dom stage
innerExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UType dom stage Ann UType dom stage
exprThen :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprSumPlaceholdersBefore :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UUnboxedSumPlaceHolder dom stage AnnListG UUnboxedSumPlaceHolder dom stage
exprSumPlaceholdersAfter :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UUnboxedSumPlaceHolder dom stage AnnListG UUnboxedSumPlaceHolder dom stage
exprStmts :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UStmt dom stage AnnListG UStmt dom stage
exprSplice :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann USplice dom stage Ann USplice dom stage
exprSig :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UType dom stage Ann UType dom stage
exprRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprRecName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UName dom stage Ann UName dom stage
exprRecFields :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UFieldUpdate dom stage AnnListG UFieldUpdate dom stage
exprQQ :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UQuasiQuote dom stage Ann UQuasiQuote dom stage
exprPragma :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExprPragma dom stage Ann UExprPragma dom stage
exprOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UOperator dom stage Ann UOperator dom stage
exprName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UName dom stage Ann UName dom stage
exprLit :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann ULiteral dom stage Ann ULiteral dom stage
exprLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprInner :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprIfAlts :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UGuardedCaseRhs dom stage AnnListG UGuardedCaseRhs dom stage
exprFunBind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG ULocalBind dom stage AnnListG ULocalBind dom stage
exprFun :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprElse :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprCond :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprCase :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprBracket :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UBracket dom stage Ann UBracket dom stage
exprBindings :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UPattern dom stage AnnListG UPattern dom stage
exprArg :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
exprAlts :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UAlt dom stage AnnListG UAlt dom stage
enumToFix :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
enumTo :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnMaybeG UExpr dom stage AnnMaybeG UExpr dom stage
enumThen :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnMaybeG UExpr dom stage AnnMaybeG UExpr dom stage
enumFrom :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
doKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UDoKind dom stage Ann UDoKind dom stage
compExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage Ann UExpr dom stage
compBody :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage AnnListG UListCompBody dom stage AnnListG UListCompBody dom stage
arrowAppl :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExpr dom stage Ann UExpr dom stage Ann UArrowAppl dom stage Ann UArrowAppl dom stage
innerAsserts :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage AnnListG UAssertion dom stage AnnListG UAssertion dom stage
assertTypes :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage AnnListG UType dom stage AnnListG UType dom stage
assertRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage Ann UType dom stage Ann UType dom stage
assertOp :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage Ann UOperator dom stage Ann UOperator dom stage
assertLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage Ann UType dom stage Ann UType dom stage
assertImplVar :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage Ann UName dom stage Ann UName dom stage
assertImplType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage Ann UType dom stage Ann UType dom stage
assertClsName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAssertion dom stage Ann UAssertion dom stage Ann UName dom stage Ann UName dom stage
contextAssertion :: RefMonads w r => Reference w r MU MU Ann UContext dom stage Ann UContext dom stage Ann UAssertion dom stage Ann UAssertion dom stage
kindVar :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UName dom stage Ann UName dom stage
kindType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UType dom stage Ann UType dom stage
kindRight :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindPromoted :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UPromoted UKind dom stage Ann UPromoted UKind dom stage
kindParen :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindLeft :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindElems :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage AnnListG UKind dom stage AnnListG UKind dom stage
kindElem :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindAppOp :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UOperator dom stage Ann UOperator dom stage
kindAppFun :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
kindAppArg :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage Ann UKind dom stage
typeWildcardName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UName dom stage Ann UName dom stage
typeType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeRight :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeResult :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeQQ :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UQuasiQuote dom stage Ann UQuasiQuote dom stage
typeParam :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UOperator dom stage Ann UOperator dom stage
typeName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UName dom stage Ann UName dom stage
typeLeft :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UKind dom stage Ann UKind dom stage
typeInner :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeElements :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage AnnListG UType dom stage AnnListG UType dom stage
typeElement :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeCtx :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UContext dom stage Ann UContext dom stage
typeCon :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
typeBounded :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage AnnListG UTyVar dom stage AnnListG UTyVar dom stage
typeArg :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UType dom stage Ann UType dom stage
tsSplice :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann USplice dom stage Ann USplice dom stage
tpPromoted :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UType dom stage Ann UType dom stage Ann UPromoted UType dom stage Ann UPromoted UType dom stage
tyVarName :: RefMonads w r => Reference w r MU MU Ann UTyVar dom stage Ann UTyVar dom stage Ann UName dom stage Ann UName dom stage
tyVarKind :: RefMonads w r => Reference w r MU MU Ann UTyVar dom stage Ann UTyVar dom stage AnnMaybeG UKindConstraint dom stage AnnMaybeG UKindConstraint dom stage
valBindRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UValueBind dom stage Ann UValueBind dom stage Ann URhs dom stage Ann URhs dom stage
valBindPat :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UValueBind dom stage Ann UValueBind dom stage Ann UPattern dom stage Ann UPattern dom stage
valBindLocals :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UValueBind dom stage Ann UValueBind dom stage AnnMaybeG ULocalBinds dom stage AnnMaybeG ULocalBinds dom stage
funBindMatches :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UValueBind dom stage Ann UValueBind dom stage AnnListG UMatch dom stage AnnListG UMatch dom stage
kindConstr :: RefMonads w r => Reference w r MU MU Ann UKindConstraint dom stage Ann UKindConstraint dom stage Ann UKind dom stage Ann UKind dom stage
matchLhsRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMatchLhs dom stage Ann UMatchLhs dom stage Ann UPattern dom stage Ann UPattern dom stage
matchLhsOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMatchLhs dom stage Ann UMatchLhs dom stage Ann UOperator dom stage Ann UOperator dom stage
matchLhsName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMatchLhs dom stage Ann UMatchLhs dom stage Ann UName dom stage Ann UName dom stage
matchLhsLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMatchLhs dom stage Ann UMatchLhs dom stage Ann UPattern dom stage Ann UPattern dom stage
matchLhsArgs :: RefMonads w r => Reference w r MU MU Ann UMatchLhs dom stage Ann UMatchLhs dom stage AnnListG UPattern dom stage AnnListG UPattern dom stage
tsType :: RefMonads w r => Reference w r MU MU Ann UTypeSignature dom stage Ann UTypeSignature dom stage Ann UType dom stage Ann UType dom stage
tsName :: RefMonads w r => Reference w r MU MU Ann UTypeSignature dom stage Ann UTypeSignature dom stage AnnListG UName dom stage AnnListG UName dom stage
precedenceValue :: RefMonads w r => Reference w r MU MU Ann Precedence dom stage Ann Precedence dom stage Int Int
fixityPrecedence :: RefMonads w r => Reference w r MU MU Ann UFixitySignature dom stage Ann UFixitySignature dom stage AnnMaybeG Precedence dom stage AnnMaybeG Precedence dom stage
fixityOperators :: RefMonads w r => Reference w r MU MU Ann UFixitySignature dom stage Ann UFixitySignature dom stage AnnListG UOperator dom stage AnnListG UOperator dom stage
fixityAssoc :: RefMonads w r => Reference w r MU MU Ann UFixitySignature dom stage Ann UFixitySignature dom stage Ann Assoc dom stage Ann Assoc dom stage
localBinds :: RefMonads w r => Reference w r MU MU Ann ULocalBinds dom stage Ann ULocalBinds dom stage AnnListG ULocalBind dom stage AnnListG ULocalBind dom stage
localVal :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULocalBind dom stage Ann ULocalBind dom stage Ann UValueBind dom stage Ann UValueBind dom stage
localSig :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULocalBind dom stage Ann ULocalBind dom stage Ann UTypeSignature dom stage Ann UTypeSignature dom stage
localInline :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULocalBind dom stage Ann ULocalBind dom stage Ann UInlinePragma dom stage Ann UInlinePragma dom stage
localFixity :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann ULocalBind dom stage Ann ULocalBind dom stage Ann UFixitySignature dom stage Ann UFixitySignature dom stage
guardRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URhsGuard dom stage Ann URhsGuard dom stage Ann UExpr dom stage Ann UExpr dom stage
guardPat :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URhsGuard dom stage Ann URhsGuard dom stage Ann UPattern dom stage Ann UPattern dom stage
guardCheck :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URhsGuard dom stage Ann URhsGuard dom stage Ann UExpr dom stage Ann UExpr dom stage
guardBinds :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URhsGuard dom stage Ann URhsGuard dom stage AnnListG ULocalBind dom stage AnnListG ULocalBind dom stage
guardStmts :: RefMonads w r => Reference w r MU MU Ann UGuardedRhs dom stage Ann UGuardedRhs dom stage AnnListG URhsGuard dom stage AnnListG URhsGuard dom stage
guardExpr :: RefMonads w r => Reference w r MU MU Ann UGuardedRhs dom stage Ann UGuardedRhs dom stage Ann UExpr dom stage Ann UExpr dom stage
rhsGuards :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URhs dom stage Ann URhs dom stage AnnListG UGuardedRhs dom stage AnnListG UGuardedRhs dom stage
rhsExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URhs dom stage Ann URhs dom stage Ann UExpr dom stage Ann UExpr dom stage
matchRhs :: RefMonads w r => Reference w r MU MU Ann UMatch dom stage Ann UMatch dom stage Ann URhs dom stage Ann URhs dom stage
matchLhs :: RefMonads w r => Reference w r MU MU Ann UMatch dom stage Ann UMatch dom stage Ann UMatchLhs dom stage Ann UMatchLhs dom stage
matchBinds :: RefMonads w r => Reference w r MU MU Ann UMatch dom stage Ann UMatch dom stage AnnMaybeG ULocalBinds dom stage AnnMaybeG ULocalBinds dom stage
specializeType :: RefMonads w r => Reference w r MU MU Ann USpecializePragma dom stage Ann USpecializePragma dom stage AnnListG UType dom stage AnnListG UType dom stage
specializeDef :: RefMonads w r => Reference w r MU MU Ann USpecializePragma dom stage Ann USpecializePragma dom stage Ann UName dom stage Ann UName dom stage
pragmaPhase :: RefMonads w r => Reference w r MU MU Ann USpecializePragma dom stage Ann USpecializePragma dom stage AnnMaybeG UPhaseControl dom stage AnnMaybeG UPhaseControl dom stage
numberInteger :: RefMonads w r => Reference w r MU MU Ann Number dom stage Ann Number dom stage Integer Integer
srToLine :: RefMonads w r => Reference w r MU MU Ann USourceRange dom stage Ann USourceRange dom stage Ann Number dom stage Ann Number dom stage
srToCol :: RefMonads w r => Reference w r MU MU Ann USourceRange dom stage Ann USourceRange dom stage Ann Number dom stage Ann Number dom stage
srFromLine :: RefMonads w r => Reference w r MU MU Ann USourceRange dom stage Ann USourceRange dom stage Ann Number dom stage Ann Number dom stage
srFromCol :: RefMonads w r => Reference w r MU MU Ann USourceRange dom stage Ann USourceRange dom stage Ann Number dom stage Ann Number dom stage
srFileName :: RefMonads w r => Reference w r MU MU Ann USourceRange dom stage Ann USourceRange dom stage Ann UStringNode dom stage Ann UStringNode dom stage
minimalOrs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage AnnListG UMinimalFormula dom stage AnnListG UMinimalFormula dom stage
minimalName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage Ann UName dom stage Ann UName dom stage
minimalInner :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage
minimalAnds :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage AnnListG UMinimalFormula dom stage AnnListG UMinimalFormula dom stage
annotateName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UAnnotationSubject dom stage Ann UAnnotationSubject dom stage Ann UName dom stage Ann UName dom stage
warnMessage :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage AnnListG UStringNode dom stage AnnListG UStringNode dom stage
specializePragma :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage Ann USpecializePragma dom stage Ann USpecializePragma dom stage
pragmaSignature :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage AnnMaybeG UName dom stage AnnMaybeG UName dom stage
pragmaRule :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage AnnListG URule dom stage AnnListG URule dom stage
pragmaObjects :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage AnnListG UName dom stage AnnListG UName dom stage
pragmaLineNum :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage Ann LineNumber dom stage Ann LineNumber dom stage
pragmaInline :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage Ann UInlinePragma dom stage Ann UInlinePragma dom stage
pragmaFileName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage AnnMaybeG UStringNode dom stage AnnMaybeG UStringNode dom stage
deprMessage :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage AnnListG UStringNode dom stage AnnListG UStringNode dom stage
annotationSubject :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage Ann UAnnotationSubject dom stage Ann UAnnotationSubject dom stage
annotateExpr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage Ann UExpr dom stage Ann UExpr dom stage
phaseNum :: RefMonads w r => Reference w r MU MU Ann PhaseNumber dom stage Ann PhaseNumber dom stage Integer Integer
phaseUntil :: RefMonads w r => Reference w r MU MU Ann UPhaseControl dom stage Ann UPhaseControl dom stage AnnMaybeG PhaseInvert dom stage AnnMaybeG PhaseInvert dom stage
phaseNumber :: RefMonads w r => Reference w r MU MU Ann UPhaseControl dom stage Ann UPhaseControl dom stage AnnMaybeG PhaseNumber dom stage AnnMaybeG PhaseNumber dom stage
ruleVarType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann URuleVar dom stage Ann URuleVar dom stage Ann UType dom stage Ann UType dom stage
ruleVarName :: RefMonads w r => Reference w r MU MU Ann URuleVar dom stage Ann URuleVar dom stage Ann UName dom stage Ann UName dom stage
ruleRhs :: RefMonads w r => Reference w r MU MU Ann URule dom stage Ann URule dom stage Ann UExpr dom stage Ann UExpr dom stage
rulePhase :: RefMonads w r => Reference w r MU MU Ann URule dom stage Ann URule dom stage AnnMaybeG UPhaseControl dom stage AnnMaybeG UPhaseControl dom stage
ruleName :: RefMonads w r => Reference w r MU MU Ann URule dom stage Ann URule dom stage Ann UStringNode dom stage Ann UStringNode dom stage
ruleLhs :: RefMonads w r => Reference w r MU MU Ann URule dom stage Ann URule dom stage Ann UExpr dom stage Ann UExpr dom stage
ruleBounded :: RefMonads w r => Reference w r MU MU Ann URule dom stage Ann URule dom stage AnnListG URuleVar dom stage AnnListG URuleVar dom stage
teRhs :: RefMonads w r => Reference w r MU MU Ann UTypeEqn dom stage Ann UTypeEqn dom stage Ann UType dom stage Ann UType dom stage
teLhs :: RefMonads w r => Reference w r MU MU Ann UTypeEqn dom stage Ann UTypeEqn dom stage Ann UType dom stage Ann UType dom stage
ihType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UType dom stage Ann UType dom stage
ihOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UOperator dom stage Ann UOperator dom stage
ihLeftOp :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UType dom stage Ann UType dom stage
ihHead :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UInstanceHead dom stage
ihFun :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UInstanceHead dom stage
ihConName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstanceHead dom stage Ann UInstanceHead dom stage Ann UName dom stage Ann UName dom stage
irVars :: RefMonads w r => Reference w r MU MU Ann UInstanceRule dom stage Ann UInstanceRule dom stage AnnMaybeG AnnListG UTyVar dom stage AnnMaybeG AnnListG UTyVar dom stage
irHead :: RefMonads w r => Reference w r MU MU Ann UInstanceRule dom stage Ann UInstanceRule dom stage Ann UInstanceHead dom stage Ann UInstanceHead dom stage
irCtx :: RefMonads w r => Reference w r MU MU Ann UInstanceRule dom stage Ann UInstanceRule dom stage AnnMaybeG UContext dom stage AnnMaybeG UContext dom stage
oneDerived :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeriving dom stage Ann UDeriving dom stage Ann UInstanceHead dom stage Ann UInstanceHead dom stage
allDerived :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeriving dom stage Ann UDeriving dom stage AnnListG UInstanceHead dom stage AnnListG UInstanceHead dom stage
deriveStrategy :: RefMonads w r => Reference w r MU MU Ann UDeriving dom stage Ann UDeriving dom stage AnnMaybeG UDeriveStrategy dom stage AnnMaybeG UDeriveStrategy dom stage
fieldType :: RefMonads w r => Reference w r MU MU Ann UFieldDecl dom stage Ann UFieldDecl dom stage Ann UType dom stage Ann UType dom stage
fieldNames :: RefMonads w r => Reference w r MU MU Ann UFieldDecl dom stage Ann UFieldDecl dom stage AnnListG UName dom stage AnnListG UName dom stage
conDeclRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage Ann UType dom stage Ann UType dom stage
conDeclOp :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage Ann UOperator dom stage Ann UOperator dom stage
conDeclName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage Ann UName dom stage Ann UName dom stage
conDeclLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage Ann UType dom stage Ann UType dom stage
conDeclFields :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage AnnListG UFieldDecl dom stage AnnListG UFieldDecl dom stage
conDeclArgs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage AnnListG UType dom stage AnnListG UType dom stage
conTypeCtx :: RefMonads w r => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage AnnMaybeG UContext dom stage AnnMaybeG UContext dom stage
conTypeArgs :: RefMonads w r => Reference w r MU MU Ann UConDecl dom stage Ann UConDecl dom stage AnnListG UTyVar dom stage AnnListG UTyVar dom stage
funDepRhs :: RefMonads w r => Reference w r MU MU Ann UFunDep dom stage Ann UFunDep dom stage AnnListG UName dom stage AnnListG UName dom stage
funDepLhs :: RefMonads w r => Reference w r MU MU Ann UFunDep dom stage Ann UFunDep dom stage AnnListG UName dom stage AnnListG UName dom stage
funDeps :: RefMonads w r => Reference w r MU MU Ann UFunDeps dom stage Ann UFunDeps dom stage AnnListG UFunDep dom stage AnnListG UFunDep dom stage
patSigType :: RefMonads w r => Reference w r MU MU Ann UPatternTypeSignature dom stage Ann UPatternTypeSignature dom stage Ann UType dom stage Ann UType dom stage
patSigName :: RefMonads w r => Reference w r MU MU Ann UPatternTypeSignature dom stage Ann UPatternTypeSignature dom stage AnnListG UName dom stage AnnListG UName dom stage
patOpposite :: RefMonads w r => Reference w r MU MU Ann UPatSynWhere dom stage Ann UPatSynWhere dom stage AnnListG UMatch dom stage AnnListG UMatch dom stage
patSynRhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatSynLhs dom stage Ann UPatSynLhs dom stage Ann UName dom stage Ann UName dom stage
patSynOp :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatSynLhs dom stage Ann UPatSynLhs dom stage Ann UOperator dom stage Ann UOperator dom stage
patSynLhs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatSynLhs dom stage Ann UPatSynLhs dom stage Ann UName dom stage Ann UName dom stage
patName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatSynLhs dom stage Ann UPatSynLhs dom stage Ann UName dom stage Ann UName dom stage
patArgs :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatSynLhs dom stage Ann UPatSynLhs dom stage AnnListG UName dom stage AnnListG UName dom stage
patRhsOpposite :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UPatSynRhs dom stage Ann UPatSynRhs dom stage AnnMaybeG UPatSynWhere dom stage AnnMaybeG UPatSynWhere dom stage
patRhsPat :: RefMonads w r => Reference w r MU MU Ann UPatSynRhs dom stage Ann UPatSynRhs dom stage Ann UPattern dom stage Ann UPattern dom stage
patRhs :: RefMonads w r => Reference w r MU MU Ann UPatternSynonym dom stage Ann UPatternSynonym dom stage Ann UPatSynRhs dom stage Ann UPatSynRhs dom stage
patLhs :: RefMonads w r => Reference w r MU MU Ann UPatternSynonym dom stage Ann UPatternSynonym dom stage Ann UPatSynLhs dom stage Ann UPatSynLhs dom stage
gadtConResultType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UGadtConType dom stage Ann UGadtConType dom stage Ann UType dom stage Ann UType dom stage
gadtConRecordFields :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UGadtConType dom stage Ann UGadtConType dom stage AnnListG UFieldDecl dom stage AnnListG UFieldDecl dom stage
gadtConNormalType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UGadtConType dom stage Ann UGadtConType dom stage Ann UType dom stage Ann UType dom stage
gadtConTypeCtx :: RefMonads w r => Reference w r MU MU Ann UGadtConDecl dom stage Ann UGadtConDecl dom stage AnnMaybeG UContext dom stage AnnMaybeG UContext dom stage
gadtConTypeArgs :: RefMonads w r => Reference w r MU MU Ann UGadtConDecl dom stage Ann UGadtConDecl dom stage AnnListG UTyVar dom stage AnnListG UTyVar dom stage
gadtConType :: RefMonads w r => Reference w r MU MU Ann UGadtConDecl dom stage Ann UGadtConDecl dom stage Ann UGadtConType dom stage Ann UGadtConType dom stage
gadtConNames :: RefMonads w r => Reference w r MU MU Ann UGadtConDecl dom stage Ann UGadtConDecl dom stage AnnListG UName dom stage AnnListG UName dom stage
injAnnRes :: RefMonads w r => Reference w r MU MU Ann UInjectivityAnn dom stage Ann UInjectivityAnn dom stage Ann UTyVar dom stage Ann UTyVar dom stage
injAnnDeps :: RefMonads w r => Reference w r MU MU Ann UInjectivityAnn dom stage Ann UInjectivityAnn dom stage AnnListG UName dom stage AnnListG UName dom stage
tfTypeVar :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTypeFamilySpec dom stage Ann UTypeFamilySpec dom stage Ann UTyVar dom stage Ann UTyVar dom stage
tfSpecKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTypeFamilySpec dom stage Ann UTypeFamilySpec dom stage Ann UKindConstraint dom stage Ann UKindConstraint dom stage
tfInjectivity :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTypeFamilySpec dom stage Ann UTypeFamilySpec dom stage Ann UInjectivityAnn dom stage Ann UInjectivityAnn dom stage
tfSpec :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTypeFamily dom stage Ann UTypeFamily dom stage AnnMaybeG UTypeFamilySpec dom stage AnnMaybeG UTypeFamilySpec dom stage
tfKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UTypeFamily dom stage Ann UTypeFamily dom stage AnnMaybeG UKindConstraint dom stage AnnMaybeG UKindConstraint dom stage
tfHead :: RefMonads w r => Reference w r MU MU Ann UTypeFamily dom stage Ann UTypeFamily dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage
specializeInstanceType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UType dom stage Ann UType dom stage
specializeInstance :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann USpecializePragma dom stage Ann USpecializePragma dom stage
instanceInline :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UInlinePragma dom stage Ann UInlinePragma dom stage
instBodyTypeSig :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UTypeSignature dom stage Ann UTypeSignature dom stage
instBodyTypeEqn :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UTypeEqn dom stage Ann UTypeEqn dom stage
instBodyLhsType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UInstanceRule dom stage Ann UInstanceRule dom stage
instBodyGadtCons :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage AnnListG UGadtConDecl dom stage AnnListG UGadtConDecl dom stage
instBodyDerivings :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage AnnListG UDeriving dom stage AnnListG UDeriving dom stage
instBodyDeclFunbind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UValueBind dom stage Ann UValueBind dom stage
instBodyDataNew :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage Ann UDataOrNewtypeKeyword dom stage Ann UDataOrNewtypeKeyword dom stage
instBodyDataKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage AnnMaybeG UKindConstraint dom stage AnnMaybeG UKindConstraint dom stage
instBodyDataCons :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UInstBodyDecl dom stage Ann UInstBodyDecl dom stage AnnListG UConDecl dom stage AnnListG UConDecl dom stage
instBodyDecls :: RefMonads w r => Reference w r MU MU Ann UInstBody dom stage Ann UInstBody dom stage AnnListG UInstBodyDecl dom stage AnnListG UInstBodyDecl dom stage
dhRight :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UTyVar dom stage Ann UTyVar dom stage
dhOperator :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UOperator dom stage Ann UOperator dom stage
dhName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UName dom stage Ann UName dom stage
dhLeft :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UTyVar dom stage Ann UTyVar dom stage
dhBody :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage
dhAppOperand :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UTyVar dom stage Ann UTyVar dom stage
dhAppFun :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage
pragmaFormula :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UMinimalFormula dom stage Ann UMinimalFormula dom stage
clsInline :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UInlinePragma dom stage Ann UInlinePragma dom stage
clsFixity :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UFixitySignature dom stage Ann UFixitySignature dom stage
ceTypeSig :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UTypeSignature dom stage Ann UTypeSignature dom stage
ceTypeFam :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UTypeFamily dom stage Ann UTypeFamily dom stage
ceType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UType dom stage Ann UType dom stage
ceName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UName dom stage Ann UName dom stage
ceKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UType dom stage Ann UType dom stage
ceHead :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage
ceBind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UClassElement dom stage Ann UClassElement dom stage Ann UValueBind dom stage Ann UValueBind dom stage
cbElements :: RefMonads w r => Reference w r MU MU Ann UClassBody dom stage Ann UClassBody dom stage AnnListG UClassElement dom stage AnnListG UClassElement dom stage
declValBind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UValueBind dom stage Ann UValueBind dom stage
declTypes :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnListG UType dom stage AnnListG UType dom stage
declTypeSig :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UTypeSignature dom stage Ann UTypeSignature dom stage
declTypeFamily :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UTypeFamily dom stage Ann UTypeFamily dom stage
declType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UType dom stage Ann UType dom stage
declSplice :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann USplice dom stage Ann USplice dom stage
declSpec :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UTypeFamilySpec dom stage AnnMaybeG UTypeFamilySpec dom stage
declSafety :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG USafety dom stage AnnMaybeG USafety dom stage
declRoles :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnListG URole dom stage AnnListG URole dom stage
declRoleType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UQualifiedName dom stage Ann UQualifiedName dom stage
declPragma :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UTopLevelPragma dom stage Ann UTopLevelPragma dom stage
declPatTypeSig :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UPatternTypeSignature dom stage Ann UPatternTypeSignature dom stage
declPatSyn :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UPatternSynonym dom stage Ann UPatternSynonym dom stage
declOverlap :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UOverlapPragma dom stage AnnMaybeG UOverlapPragma dom stage
declNewtype :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UDataOrNewtypeKeyword dom stage Ann UDataOrNewtypeKeyword dom stage
declName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UName dom stage Ann UName dom stage
declKind :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UKindConstraint dom stage AnnMaybeG UKindConstraint dom stage
declInstance :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UInstanceRule dom stage Ann UInstanceRule dom stage
declInstRule :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UInstanceRule dom stage Ann UInstanceRule dom stage
declInstDecl :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UInstBody dom stage AnnMaybeG UInstBody dom stage
declHead :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UDeclHead dom stage Ann UDeclHead dom stage
declGadt :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnListG UGadtConDecl dom stage AnnListG UGadtConDecl dom stage
declFunDeps :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UFunDeps dom stage AnnMaybeG UFunDeps dom stage
declForeignType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UType dom stage Ann UType dom stage
declFixity :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UFixitySignature dom stage Ann UFixitySignature dom stage
declDeriving :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnListG UDeriving dom stage AnnListG UDeriving dom stage
declDerivStrat :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UDeriveStrategy dom stage AnnMaybeG UDeriveStrategy dom stage
declDecl :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnListG UTypeEqn dom stage AnnListG UTypeEqn dom stage
declCtx :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UContext dom stage AnnMaybeG UContext dom stage
declCons :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnListG UConDecl dom stage AnnListG UConDecl dom stage
declCallConv :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UCallConv dom stage Ann UCallConv dom stage
declBody :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage AnnMaybeG UClassBody dom stage AnnMaybeG UClassBody dom stage
declAssignedType :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UDecl dom stage Ann UDecl dom stage Ann UType dom stage Ann UType dom stage
langExt :: RefMonads w r => Reference w r MU MU Ann ULanguageExtension dom stage Ann ULanguageExtension dom stage String String
moduleNameString :: RefMonads w r => Reference w r MU MU Ann UModuleName dom stage Ann UModuleName dom stage String String
importRename :: RefMonads w r => Reference w r MU MU Ann UImportRenaming dom stage Ann UImportRenaming dom stage Ann UModuleName dom stage Ann UModuleName dom stage
importSpecList :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UImportSpec dom stage Ann UImportSpec dom stage AnnListG UIESpec dom stage AnnListG UIESpec dom stage
importSpecHiding :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UImportSpec dom stage Ann UImportSpec dom stage AnnListG UIESpec dom stage AnnListG UIESpec dom stage
importSpec :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage AnnMaybeG UImportSpec dom stage AnnMaybeG UImportSpec dom stage
importSource :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage AnnMaybeG UImportSource dom stage AnnMaybeG UImportSource dom stage
importSafe :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage AnnMaybeG UImportSafe dom stage AnnMaybeG UImportSafe dom stage
importQualified :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage AnnMaybeG UImportQualified dom stage AnnMaybeG UImportQualified dom stage
importPkg :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage AnnMaybeG UStringNode dom stage AnnMaybeG UStringNode dom stage
importModule :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage Ann UModuleName dom stage Ann UModuleName dom stage
importAs :: RefMonads w r => Reference w r MU MU Ann UImportDecl dom stage Ann UImportDecl dom stage AnnMaybeG UImportRenaming dom stage AnnMaybeG UImportRenaming dom stage
opStr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UFilePragma dom stage Ann UFilePragma dom stage Ann UStringNode dom stage Ann UStringNode dom stage
lpPragmas :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UFilePragma dom stage Ann UFilePragma dom stage AnnListG ULanguageExtension dom stage AnnListG ULanguageExtension dom stage
modWarningStr :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UModulePragma dom stage Ann UModulePragma dom stage AnnListG UStringNode dom stage AnnListG UStringNode dom stage
modDeprecatedPragma :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UModulePragma dom stage Ann UModulePragma dom stage AnnListG UStringNode dom stage AnnListG UStringNode dom stage
essList :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann USubSpec dom stage Ann USubSpec dom stage AnnListG UName dom stage AnnListG UName dom stage
ieSubspec :: RefMonads w r => Reference w r MU MU Ann UIESpec dom stage Ann UIESpec dom stage AnnMaybeG USubSpec dom stage AnnMaybeG USubSpec dom stage
ieName :: RefMonads w r => Reference w r MU MU Ann UIESpec dom stage Ann UIESpec dom stage Ann UName dom stage Ann UName dom stage
ieModifier :: RefMonads w r => Reference w r MU MU Ann UIESpec dom stage Ann UIESpec dom stage AnnMaybeG UImportModifier dom stage AnnMaybeG UImportModifier dom stage
exportModuleName :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExportSpec dom stage Ann UExportSpec dom stage Ann UModuleName dom stage Ann UModuleName dom stage
exportDecl :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU Ann UExportSpec dom stage Ann UExportSpec dom stage Ann UIESpec dom stage Ann UIESpec dom stage
espExports :: RefMonads w r => Reference w r MU MU Ann UExportSpecs dom stage Ann UExportSpecs dom stage AnnListG UExportSpec dom stage AnnListG UExportSpec dom stage
mhPragma :: RefMonads w r => Reference w r MU MU Ann UModuleHead dom stage Ann UModuleHead dom stage AnnMaybeG UModulePragma dom stage AnnMaybeG UModulePragma dom stage
mhName :: RefMonads w r => Reference w r MU MU Ann UModuleHead dom stage Ann UModuleHead dom stage Ann UModuleName dom stage Ann UModuleName dom stage
mhExports :: RefMonads w r => Reference w r MU MU Ann UModuleHead dom stage Ann UModuleHead dom stage AnnMaybeG UExportSpecs dom stage AnnMaybeG UExportSpecs dom stage
modImports :: RefMonads w r => Reference w r MU MU Ann UModule dom stage Ann UModule dom stage AnnListG UImportDecl dom stage AnnListG UImportDecl dom stage
modHead :: RefMonads w r => Reference w r MU MU Ann UModule dom stage Ann UModule dom stage AnnMaybeG UModuleHead dom stage AnnMaybeG UModuleHead dom stage
modDecl :: RefMonads w r => Reference w r MU MU Ann UModule dom stage Ann UModule dom stage AnnListG UDecl dom stage AnnListG UDecl dom stage
filePragmas :: RefMonads w r => Reference w r MU MU Ann UModule dom stage Ann UModule dom stage AnnListG UFilePragma dom stage AnnListG UFilePragma dom stage
semanticsLitType :: () => Ann ULiteral IdDom st -> Type

-- | Domains that have semantic information for names
type HasNameInfo dom = (Domain dom, HasNameInfo' SemanticInfo dom UQualifiedName)

-- | Infos that may have a name that can be extracted
class HasNameInfo' si
semanticsName :: HasNameInfo' si => si -> Maybe Name

-- | Domains that have semantic information for literals
type HasLiteralInfo dom = (Domain dom, HasLiteralInfo' SemanticInfo dom ULiteral)

-- | Info of types
class HasLiteralInfo' si
semanticsLiteralType :: HasLiteralInfo' si => si -> Type
type HasIdInfo dom = (Domain dom, HasIdInfo' SemanticInfo dom UQualifiedName)

-- | Infos that may have a typed name that can be extracted
class HasNameInfo' si => HasIdInfo' si
semanticsId :: HasIdInfo' si => si -> Id
type HasFixityInfo dom = (Domain dom, HasFixityInfo' SemanticInfo dom UQualifiedName)

-- | Infos that may have a fixity information
class HasFixityInfo' si
semanticsFixity :: HasFixityInfo' si => si -> Maybe Fixity
type HasScopeInfo dom = (Domain dom, HasScopeInfo' SemanticInfo dom UQualifiedName, HasScopeInfo' SemanticInfo dom UExpr)

-- | Infos that contain the names that are available in theirs scope
class HasScopeInfo' si
semanticsScope :: HasScopeInfo' si => si -> Scope
type HasDefiningInfo dom = (Domain dom, HasDefiningInfo' SemanticInfo dom UQualifiedName)

-- | Infos that store if they were used to define a name
class HasDefiningInfo' si
semanticsDefining :: HasDefiningInfo' si => si -> Bool
class HasSourceInfoInSema' si
semanticsSourceInfo :: HasSourceInfoInSema' si => si -> Maybe SrcSpan
type HasModuleInfo dom = (Domain dom, HasModuleInfo' SemanticInfo dom UModule)
class HasModuleInfo' si
semanticsModule :: HasModuleInfo' si => si -> Module
semanticsDynFlags :: HasModuleInfo' si => si -> DynFlags
isBootModule :: HasModuleInfo' si => si -> Bool
semanticsImplicitImports :: HasModuleInfo' si => si -> [Name]
semanticsPrelTransMods :: HasModuleInfo' si => si -> [Module]
type HasImportInfo dom = (Domain dom, HasImportInfo' SemanticInfo dom UImportDecl)
class HasImportInfo' si
semanticsImportedModule :: HasImportInfo' si => si -> Module
semanticsAvailable :: HasImportInfo' si => si -> [Name]
semanticsImported :: HasImportInfo' si => si -> [Name]
semanticsTransMods :: HasImportInfo' si => si -> [Module]
type HasImplicitFieldsInfo dom = (Domain dom, HasImplicitFieldsInfo' SemanticInfo dom UFieldWildcard)
class HasImplicitFieldsInfo' si
semanticsImplicitFlds :: HasImplicitFieldsInfo' si => si -> [(Name, Name)]
type HasNoSemanticInfo dom (si :: * -> * -> *) = SemanticInfo dom si ~ NoSemanticInfo

-- | Gets the class and family instances from a module.
getInstances :: GhcMonad m => [Module] -> m ([ClsInst], [FamInst])
data UsageSpec
UsageSpec :: Bool -> String -> String -> UsageSpec
[usageQualified] :: UsageSpec -> Bool
[usageQualifier] :: UsageSpec -> String
[usageAs] :: UsageSpec -> String

-- | Put the given string before the element if it is not empty
after :: AfterBefore i => String -> i -> i

-- | The given string should follow the element if it is not empty
followedBy :: AfterBefore i => String -> i -> i

-- | The element should be indented relatively to its parent
relativeIndented :: RelativeIndent i => Int -> i -> i

-- | The elements should be indented at least to the given number of spaces
minimumIndented :: MinimumIndent i => Int -> i -> i
fixMainRange :: () => StringBuffer -> Ann UModule dom RangeStage -> Ann UModule dom RangeStage
prepareASTCpp :: () => StringBuffer -> Ann UModule dom RangeStage -> Ann UModule dom SrcTemplateStage

-- | Prepares the AST for pretty printing
prepareAST :: () => StringBuffer -> Ann UModule dom RangeStage -> Ann UModule dom SrcTemplateStage

-- | The elements of the list should be indented on the same column
indented :: ListInfo SrcTemplateStage -> ListInfo SrcTemplateStage

-- | The elements of the list should be separated by the given string by
--   default (might be overridden)
separatedBy :: String -> ListInfo SrcTemplateStage -> ListInfo SrcTemplateStage
list :: ListInfo SrcTemplateStage
opt :: OptionalInfo SrcTemplateStage
child :: SpanInfo SrcTemplateStage

-- | Marks template elements in the AST that should always be present in
--   the source code, regardless of their containing elements being
--   deleted. Currently it recognizes CPP pragmas (lines starting with #)
--   This function should only be applied to an AST if CPP is enabled.
extractStayingElems :: SourceInfoTraversal node => Ann node dom SrcTemplateStage -> Ann node dom SrcTemplateStage

-- | Partitions the source file in the order where the parts are used in
--   the AST
mapLocIndices :: Ord k => StringBuffer -> Set (RealSrcLoc, k) -> Map k String

-- | Assigns an index (in the order they are used) for each range
getLocIndices :: SourceInfoTraversal e => Ann e dom RngTemplateStage -> Set (RealSrcLoc, Int)
rangeToSource :: SourceInfoTraversal node => StringBuffer -> Ann node dom RngTemplateStage -> Ann node dom SrcTemplateStage
lineEndings :: Partial SourceTemplateTextElem SourceTemplateTextElem String String
sourceTemplateText :: Lens SourceTemplateTextElem SourceTemplateTextElem String String
sourceTemplateTextRange :: Partial SourceTemplateElem SourceTemplateElem SrcSpan SrcSpan
sourceTemplateTextElem :: Partial SourceTemplateElem SourceTemplateElem [SourceTemplateTextElem] [SourceTemplateTextElem]
isStayingText :: SourceTemplateTextElem -> Bool
srcTmpOptMinimalIndent :: Simple Lens OptionalInfo SrcTemplateStage Int
srcTmpOptAfter :: Simple Lens OptionalInfo SrcTemplateStage String
srcTmpOptBefore :: Simple Lens OptionalInfo SrcTemplateStage String
sourceTemplateOptRange :: Simple Lens OptionalInfo SrcTemplateStage SrcSpan
srcTmpListMinimalIndent :: Simple Lens ListInfo SrcTemplateStage Int
srcTmpSeparators :: Simple Lens ListInfo SrcTemplateStage [([SourceTemplateTextElem], SrcSpan)]
srcTmpIndented :: Simple Lens ListInfo SrcTemplateStage Maybe [Bool]
srcTmpDefaultSeparator :: Simple Lens ListInfo SrcTemplateStage String
srcTmpListAfter :: Simple Lens ListInfo SrcTemplateStage String
srcTmpListBefore :: Simple Lens ListInfo SrcTemplateStage String
sourceTemplateListRange :: Simple Lens ListInfo SrcTemplateStage SrcSpan
sourceTemplateMinimalIndent :: Simple Lens SpanInfo SrcTemplateStage Int
sourceTemplateNodeElems :: Simple Lens SpanInfo SrcTemplateStage [SourceTemplateElem]
sourceTemplateNodeRange :: Simple Lens SpanInfo SrcTemplateStage SrcSpan

-- | An element of a source template for a singleton AST node.
data SourceTemplateElem

-- | Source text belonging to the current node
TextElem :: [SourceTemplateTextElem] -> SrcSpan -> SourceTemplateElem
[_sourceTemplateTextElem] :: SourceTemplateElem -> [SourceTemplateTextElem]
[_sourceTemplateTextRange] :: SourceTemplateElem -> SrcSpan

-- | Placeholder for the next children of the node
ChildElem :: SourceTemplateElem
data SourceTemplateTextElem
NormalText :: String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
StayingText :: String -> String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
[_lineEndings] :: SourceTemplateTextElem -> String

-- | Modifies ranges to contain their children
fixRanges :: SourceInfoTraversal node => Ann node dom RangeStage -> Ann node dom NormRangeStage

-- | Creates a source template from the ranges and the input file. All
--   source ranges must be good ranges.
cutUpRanges :: SourceInfoTraversal node => Ann node dom NormRangeStage -> Ann node dom RngTemplateStage
data BreakUpProblem
BreakUpProblem :: RealSrcSpan -> SrcSpan -> [SrcSpan] -> BreakUpProblem
[bupOuter] :: BreakUpProblem -> RealSrcSpan
[bupInner] :: BreakUpProblem -> SrcSpan
[bupSiblings] :: BreakUpProblem -> [SrcSpan]
data TransformationProblem
TransformationProblem :: String -> TransformationProblem

-- | Puts comments in the nodes they should be attached to. Watches for
--   lexical tokens that may divide the comment and the supposed element.
--   Leaves the AST in a state where parent nodes does not contain all of
--   their children.
placeComments :: RangeInfo stage => Map ApiAnnKey [SrcSpan] -> Map SrcSpan [Located AnnotationComment] -> Ann UModule dom stage -> Ann UModule dom stage
getPragmaComments :: Map SrcSpan [Located AnnotationComment] -> Map String [Located String]
getNormalComments :: Map SrcSpan [Located AnnotationComment] -> Map SrcSpan [Located AnnotationComment]

-- | Forall types (<tt> forall x y . type </tt>)

-- | Type with a context (<tt> C a =&gt; type </tt>)

-- | Function types (<tt> a -&gt; b </tt>)

-- | Tuple types (<tt> (a,b) </tt>)

-- | Unboxed tuple types (<tt> (#a,b#) </tt>)

-- | List type with special syntax (<tt> [a] </tt>)

-- | Parallel array type (<tt> [:a:] </tt>)

-- | Type application (<tt> F a </tt>)

-- | Infix type constructor (<tt> (a &lt;: b) </tt>)

-- | Type surrounded by parentheses (<tt> (T a) </tt>)

-- | Type variable or constructor (<tt> a </tt>)

-- | Type with explicit kind signature (<tt> a :: * </tt>)

-- | Strict type marked with <tt>!</tt>.

-- | Lazy type marked with <tt>~</tt>. (Should only be used if
--   <tt>Strict</tt> or <tt>StrictData</tt> language extension is used)

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)

-- | Strict type marked with NOUNPACK pragma. (Usually contains the bang
--   mark.)

-- | A wildcard type (<tt> _ </tt>) with <tt>-XPartialTypeSignatures</tt>

-- | A named wildcard type (<tt> _t </tt>) with
--   <tt>-XPartialTypeSignatures</tt>

-- | A Template Haskell splice type (<tt> $(genType) </tt>).

-- | A Template Haskell splice type (<tt> $(genType) </tt>).

-- | Numeric value promoted to the type level.

-- | String value promoted to the type level.

-- | A data constructor value promoted to the type level.

-- | A list of elements as a type.

-- | A tuple of elements as a type.

-- | Kind of the unit value <tt>()</tt>.

-- | An unboxed sum type.

-- | Type variable declaration

-- | Kinded type variable declaration (<tt> v :: * </tt>)

-- | A context of assertions (<tt> C a =&gt; ... </tt>)

-- | Class assertion (<tt>Cls x</tt>)

-- | Infix class assertion, also contains type equations (<tt> a ~ X y
--   </tt>)

-- | Assertion for implicit parameter binding (<tt> ?cmp :: a -&gt; a -&gt;
--   Bool </tt>)

-- | A list of assertions (<tt> (Eq a, Show a) </tt>)

-- | A simple name splice: <tt>$generateX</tt>

-- | A splice with parentheses: <tt>$(generate input)</tt>

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>

-- | Expression bracket (<tt> [| x + y |] </tt>)

-- | Pattern bracket (<tt> [p| Point x y |] </tt>)

-- | Type bracket (<tt> [t| (Int,Int) |] </tt>)

-- | Declaration bracket (<tt> [d| f :: Int -&gt; Int; f x = x*x |] </tt>)

-- | An expression for a variable or a data constructor (<tt> a </tt>)

-- | A literal expression (<tt> 42 </tt>)

-- | An infix operator application (<tt> a + b </tt>)

-- | Prefix operator application (<tt> -x </tt>)

-- | Function application (<tt> f 4 </tt>)

-- | Lambda expression (<tt> \a b -&gt; a + b </tt>)

-- | Local binding (<tt> let x = 2; y = 3 in e x y </tt>)

-- | If expression (<tt> if a then b else c </tt>)

-- | Multi way if expressions with <tt>MultiWayIf</tt> extension (<tt> if |
--   guard1 -&gt; expr1; guard2 -&gt; expr2 </tt>)

-- | Pattern matching expression (<tt> case expr of pat1 -&gt; expr1; pat2
--   -&gt; expr2 </tt>)

-- | Do-notation expressions (<tt> do x &lt;- act1; act2 </tt>)

-- | MDo-notation expressions (<tt> mdo x &lt;- act1; act2 </tt>)

-- | Tuple expression (<tt> (e1, e2, e3) </tt>)

-- | Unboxed tuple expression (<tt> (# e1, e2, e3 #) </tt>)

-- | Tuple section, enabled with <tt>TupleSections</tt> (<tt> (a,,b)
--   </tt>). One of the elements must be missing.

-- | Unboxed tuple section enabled with <tt>TupleSections</tt> (<tt> ()
--   </tt>). One of the elements must be missing.

-- | List expression: <tt>[1,2,3]</tt>

-- | Parallel array expression: <tt>[: 1,2,3 :]</tt>

-- | Parenthesized expression: <tt>( a + b )</tt>

-- | Left operator section: <tt>(1+)</tt>

-- | Right operator section: <tt>(+1)</tt>

-- | Record value construction: <tt>Point { x = 3, y = -2 }</tt>

-- | Record value update: <tt>p1 { x = 3, y = -2 }</tt>

-- | Enumeration expression (<tt> [1,3..10] </tt>)

-- | Parallel array enumeration (<tt> [: 1,3 .. 10 :] </tt>)

-- | List comprehension (<tt> [ (x, y) | x &lt;- xs | y &lt;- ys ] </tt>)

-- | Parallel array comprehensions <tt> [: (x, y) | x &lt;- xs , y &lt;- ys
--   :] </tt> enabled by <tt>ParallelArrays</tt>

-- | Explicit type signature (<tt> x :: Int </tt>)

-- | Explicit type application (<tt> show @Integer (read "5") </tt>)

-- | <tt>'x</tt> for template haskell reifying of expressions

-- | <tt>''T</tt> for template haskell reifying of types

-- | Template haskell bracket expression

-- | Template haskell splice expression, for example: <tt>$(gen a)</tt> or
--   <tt>$x</tt>

-- | Template haskell quasi-quotation: <tt>[$quoter|str]</tt>

-- | Template haskell quasi-quotation: <tt>[$quoter|str]</tt>

-- | Arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>

-- | Arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>

-- | Lambda case ( <tt>case 0 -&gt; 1; 1 -&gt; 2</tt> )

-- | Static pointer expression (<tt> static e </tt>). The inner expression
--   must be closed (cannot have variables bound outside)

-- | Update of a field (<tt> x = 1 </tt>)

-- | Update the field to the value of the same name (<tt> x </tt>)

-- | Update the fields of the bounded names to their values (<tt> ..
--   </tt>). Must be the last initializer. Cannot be used in a record
--   update expression.

-- | An existing element in a tuple section

-- | A missing element in a tuple section

-- | Clause of case expression (<tt> Just x -&gt; x + 1 </tt>)

-- | Unguarded right-hand side a pattern match (<tt> -&gt; 3 </tt>)

-- | Guarded right-hand sides of a pattern match (<tt> | x == 1 -&gt; 3; |
--   otherwise -&gt; 4 </tt>)

-- | A guarded right-hand side of pattern matches binding (<tt> | x &gt; 3
--   -&gt; 2 </tt>)

-- | A <tt>CORE</tt> pragma for adding notes to expressions.

-- | An <tt>SCC</tt> pragma for defining cost centers for profiling

-- | A pragma that describes if an expression was generated from a code
--   fragment by an external tool (<tt> {--} </tt>)

-- | In-AST source ranges (for generated pragmas)

-- | An arrow application command (<tt> f -&lt; x + 1 </tt>)

-- | A form command (<tt> (|untilA (increment -&lt; x+y) (within 0.5 -&lt;
--   x)|) </tt>)

-- | A function application command

-- | An infix command application

-- | An infix command application

-- | A parenthesized command

-- | A pattern match command

-- | An if command (<tt> if f x y then g -&lt; x+1 else h -&lt; y+2 </tt>)

-- | A local binding command (<tt> let z = x+y </tt>)

-- | A local binding command (<tt> let z = x+y </tt>)

-- | Left arrow application: <tt>-&lt;</tt>

-- | Right arrow application: <tt>&gt;-</tt>

-- | Left arrow high application: <tt>-&lt;&lt;</tt>

-- | Right arrow high application: <tt>&gt;&gt;-</tt>

-- | A hole expression <tt>_</tt>

-- | Binding statement (<tt> x &lt;- action </tt>)

-- | Non-binding statement (<tt> action </tt>)

-- | Let statement (<tt> let x = 3; y = 4 </tt>)

-- | A recursive binding statement with (<tt> rec b &lt;- f a c; c &lt;- f
--   b a </tt>)

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)

-- | Normal monadic statement of a list comprehension

-- | Then statements by <tt>TransformListComp</tt> (<tt> then sortWith by
--   (x + y) </tt>)

-- | Grouping statements by <tt>TransformListComp</tt> (<tt> then group by
--   (x + y) using groupWith </tt>)

-- | Binding statement command (<tt> x &lt;- action </tt>)

-- | Non-binding statement command (<tt> action </tt>)

-- | Let statement command (<tt> let x = 3; y = 4 </tt>)

-- | A recursive binding statement command with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)

-- | Pattern name binding

-- | Literal pattern

-- | Infix constructor application pattern (<tt> a :+: b </tt>)

-- | Constructor application pattern (<tt> Point x y </tt>)

-- | Tuple pattern (<tt> (x,y) </tt>)

-- | Unboxed tuple pattern (<tt> (# x, y #) </tt>)

-- | List pattern (<tt> [1,2,a,x] </tt>)

-- | Parallel array pattern (<tt> [:1,2,a,x:] </tt>)

-- | Parenthesised patterns

-- | Record pattern (<tt> Point { x = 3, y } </tt>)

-- | As-pattern (explicit name binding) (<tt> ls@(hd:_) </tt>)

-- | Wildcard pattern: (<tt> _ </tt>)

-- | Irrefutable pattern (<tt> ~(x:_) </tt>)

-- | Bang pattern (<tt> !x </tt>)

-- | Pattern with explicit type signature (<tt> x :: Int </tt>)

-- | View pattern (<tt> f -&gt; Just 1 </tt>)

-- | Splice patterns: <tt>$(generateX inp)</tt>

-- | Quasi-quoted patterns: <tt>[| 1 + 2 |]</tt>

-- | Named field pattern (<tt> p = Point 3 2 </tt>)

-- | Named field pun (<tt> p </tt>)

-- | Wildcard field pattern (<tt> .. </tt>)

-- | A normal operator used as an operator.

-- | A normal name used as an operator with backticks: <tt> a `mod` b </tt>

-- | A normal, non-operator name.

-- | Parenthesized name: <tt> foldl (+) 0 </tt>

-- | Creates an implicit name: <tt> ?var </tt>

-- | Program elements formatted as string literals (import packages, pragma
--   texts)

-- | Possibly qualified name.

-- | Parts of a qualified name.

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.

-- | Module declaration with name and (optional) exports

-- | A list of export specifications surrounded by parentheses

-- | Export a name and related names

-- | The export of an imported module (<tt> module A </tt>)

-- | Marks a name to be imported or exported with related names
--   (subspecifier)

-- | <tt>(..)</tt>: a class exported with all of its methods, or a datatype
--   exported with all of its constructors.

-- | <tt>(a,b,c)</tt>: a class exported with some of its methods, or a
--   datatype exported with some of its constructors.

-- | <tt>LANGUAGE</tt> pragma, listing the enabled language extensions in
--   that file

-- | <tt>OPTIONS</tt> pragma, possibly qualified with a tool, e.g.
--   OPTIONS_GHC

-- | The name of the enabled language extension, for example (<tt>
--   LambdaCase </tt>)

-- | A warning pragma attached to the module

-- | A deprecated pragma attached to the module

-- | Character literal: <tt><tt>c</tt></tt>

-- | String literal: <tt>"abc"</tt>

-- | Integer literal: <tt>12</tt>

-- | Fractional literal: <tt>3.14</tt>

-- | Primitive integer literal (of type <tt>Int#</tt>): <tt>32#</tt>

-- | Primitive word literal (of type <tt>Word#</tt>): <tt>32##</tt>

-- | Primitive float literal (of type <tt>Float#</tt>): <tt>3.14#</tt>

-- | Primitive double literal (of type <tt>Double#</tt>): <tt>3.14##</tt>

-- | Primitive character literal (of type <tt>Char#</tt>):
--   <tt><tt>c</tt>#</tt>

-- | Primitive string literal (of type <tt>Addr#</tt>): <tt>"xxx"#</tt>

-- | Kind constraint (<tt> :: * -&gt; * </tt>)

-- | <tt>*</tt>, the kind of types

-- | <tt>#</tt>, the kind of unboxed types

-- | <tt>-&gt;</tt>, the kind of type constructor

-- | A parenthesised kind

-- | Kind variable (using <tt>PolyKinds</tt> extension)

-- | Kind application (<tt> k1 k2 </tt>)

-- | A list kind (<tt> [k] </tt>)

-- | Numeric value promoted to the kind level.

-- | String value promoted to the kind level.

-- | A data constructor value promoted to the kind level.

-- | A list of elements as a kind.

-- | A tuple of elements as a kind.

-- | Kind of the unit value <tt>()</tt>.

-- | A type synonym ( <tt>type String = [Char]</tt> )

-- | Standalone deriving declaration (<tt> deriving instance X T </tt>)

-- | Fixity declaration (<tt> infixl 5 +, - </tt>)

-- | Default types (<tt> default (T1, T2) </tt>)

-- | Type signature declaration (<tt> f :: Int -&gt; Int </tt>)

-- | Function or value binding (<tt> f x = 12 </tt>)

-- | A Template Haskell splice declaration (<tt> $(generateDecls) </tt>)

-- | A data or newtype declaration. Empty data type declarations without
--   where keyword are always belong to DataDecl.

-- | A GADT-style data or newtype declaration.

-- | GADT constructor declaration (<tt> D1 :: Int -&gt; T String </tt>)

-- | GADT constructor declaration with record syntax (<tt> D1 :: { val ::
--   Int } -&gt; T String </tt>)

-- | Ordinary data constructor (<tt> C t1 t2 </tt>)

-- | Creates a record data constructor (<tt> Point { x :: Double, y ::
--   Double } </tt>)

-- | Infix data constructor (<tt> t1 :+: t2 </tt>)

-- | Field declaration (<tt> fld :: Int </tt>)

-- | A deriving clause without parentheses (<tt> deriving Show </tt>.

-- | A deriving clause without parentheses, with/witohut strategy (<tt>
--   deriving stock Show </tt>.

-- | A deriving clause with parentheses <tt> deriving (Show, Eq) </tt>)

-- | A deriving clause with parentheses, with/witohut strategy (<tt>
--   deriving stock (Show, Eq) </tt>.

-- | A list of functional dependencies: <tt> | a -&gt; b, c -&gt; d </tt>
--   separated by commas

-- | A functional dependency, given on the form <tt>l1 ... ln -&gt; r1 ...
--   rn</tt>

-- | Type class declaration (<tt> class X a [where f = ...] </tt>)

-- | The list of declarations that can appear in a typeclass

-- | Type signature: <tt> f :: A -&gt; B </tt> as a class member

-- | Default binding: <tt> f x = "aaa" </tt> as a class member

-- | Declaration of an associated type synonym: <tt> type T x :: * </tt> in
--   a class

-- | Declaration of an associated data synonym: <tt> data T x :: * </tt> in
--   a class

-- | Default choice for type synonym: <tt> type T x = TE </tt> or <tt> type
--   instance T x = TE </tt> in a class

-- | Default signature (by using <tt>DefaultSignatures</tt>): <tt> default
--   enum :: (Generic a, GEnum (Rep a)) =&gt; [a] </tt>

-- | Minimal pragma: <tt> {-# MINIMAL (==) | (/=) #-} </tt> in a class

-- | One of the minimal formulas are needed (<tt> min1 | min2 </tt>)

-- | Both of the minimal formulas are needed (<tt> min1 , min2 </tt>)

-- | Type or class name as a declaration head

-- | Parenthesized type as a declaration head

-- | Type application as a declaration head

-- | Infix type application as a declaration head

-- | Instance declaration (<tt> instance X T [where f = ...] </tt>)

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)

-- | A normal value binding (<tt> f x = 12 </tt>) inside a class instance

-- | Type signature in instance definition with <tt>InstanceSigs</tt>

-- | An associated type definition (<tt> type A X = B </tt>) in a class
--   instance

-- | An associated data definition (<tt> data A X = B Int | C </tt>) in a
--   class instance

-- | An associated data definition as a GADT (<tt> data A X where B :: Int
--   -&gt; A X </tt>) in a class instance

-- | Specialize instance pragma in a class instance (no phase selection is
--   allowed)

-- | Instance head as an instance rule (<tt> X a =&gt; Y a </tt>)

-- | Type or class name as an instance head

-- | Infix application of the type/class name to the left operand as an
--   instance head

-- | Parenthesized instance head

-- | Type application as an instance head

-- | <tt>OVERLAP</tt> pragma

-- | <tt>NO_OVERLAP</tt> pragma

-- | <tt>OVERLAPPABLE</tt> pragma

-- | <tt>OVERLAPPING</tt> pragma

-- | <tt>OVERLAPS</tt> pragma

-- | <tt>INCOHERENT</tt> pragma

-- | Role annotations (<tt> type role Ptr representational </tt>)

-- | Foreign import (<tt> foreign import foo :: Int -&gt; IO Int </tt>)

-- | Foreign export (<tt> foreign export ccall foo :: Int -&gt; IO Int
--   </tt>)

-- | Specifies <tt>stdcall</tt> calling convention for foreign
--   import/export.

-- | Specifies <tt>ccall</tt> calling convention for foreign import/export.

-- | Specifies <tt>capi</tt> calling convention for foreign import/export.

-- | Specifies that the given foreign import is <tt>unsafe</tt>.

-- | Pattern synonyms (<tt> pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
--   </tt>)

-- | A left hand side with a constructor name and arguments (<tt> Arrow t1
--   t2 </tt>)

-- | An infix pattern synonym left-hand side (<tt> t1 :+: t2 </tt>)

-- | A record-style pattern synonym left-hand side (<tt> Arrow { arrowFrom,
--   arrowTo } </tt>)

-- | An automatically two-way pattern synonym (<tt> = App "Int" [] </tt>)

-- | A pattern synonym that can be only used for pattenr matching but not
--   for combining (<tt> &lt;- App "Int" [] </tt>)

-- | A pattern synonym with the other direction explicitly specified (<tt>
--   &lt;- App "Int" [] where Int = App "Int" [] </tt>)

-- | Pattern type signature declaration (<tt> pattern Succ :: Int -&gt; Int
--   </tt>)

-- | Type family declaration (<tt> type family A a :: * -&gt; * </tt>)

-- | Data family declaration (<tt> data family A a :: * -&gt; * </tt>)

-- | Type family instance declaration (<tt> type instance Fam T = AssignedT
--   </tt>)

-- | Data instance declaration (<tt> data instance Fam T = Con1 | Con2
--   </tt>)

-- | GADT-style data instance declaration (<tt> data instance Fam T where
--   ... </tt>)

-- | A closed type family declaration

-- | Specifies the kind of a type family (<tt> :: * -&gt; * </tt>)

-- | Specifies the injectivity of a type family (<tt> = r | r -&gt; a
--   </tt>)

-- | Type equations as found in closed type families (<tt> T A = S </tt>)

-- | Top-level pragmas

-- | A pragma that introduces source rewrite rules (<tt> {-# RULES
--   "map/map" [2] forall f g xs. map f (map g xs) = map (f.g) xs #-}
--   </tt>)

-- | A pragma that marks definitions as deprecated (<tt> {-# DEPRECATED f
--   "f will be replaced by g" #-} </tt>)

-- | A pragma that marks definitions as deprecated (<tt> {-# WARNING
--   unsafePerformIO "you should know what you are doing" #-} </tt>)

-- | A pragma that annotates a definition with an arbitrary value (<tt> {-#
--   ANN f 42 #-} </tt>)

-- | A pragma that marks a function for inlining to the compiler (<tt> {-#
--   INLINE thenUs #-} </tt>)

-- | A pragma that forbids a function from being inlined by the compiler
--   (<tt> {-# NOINLINE f #-} </tt>)

-- | A pragma that marks a function that it may be inlined by the compiler
--   (<tt> {-# INLINABLE thenUs #-} </tt>)

-- | A pragma for maintaining line numbers in generated sources (<tt> {-#
--   LINE 123 "somefile" #-} </tt>)

-- | A pragma that tells the compiler that a polymorph function should be
--   optimized for a given type (<tt> {-# SPECIALISE f :: Int -&gt; b -&gt;
--   b #-} </tt>)

-- | Marks that the pragma should be applied from a given compile phase
--   (<tt> [2] </tt>)

-- | Marks that the pragma should be applied until a given compile phase
--   (<tt> [~2] </tt>)

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)

-- | The definition with the given name is annotated

-- | A type with the given name is annotated

-- | The whole module is annotated

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.

-- | Non-function binding (<tt> v = "12" </tt>)

-- | Function binding (<tt> f 0 = 1; f x = x </tt>). All matches must have
--   the same name.

-- | Clause of function binding

-- | A match lhs with the function name and parameter names (<tt> f a b
--   </tt>)

-- | An infix match lhs for an operator (<tt> a + b </tt>)

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)

-- | A local binding for a value

-- | A local type signature

-- | A local fixity declaration

-- | A type signature (<tt> f :: Int -&gt; Int </tt>)

-- | A left-associative fixity declaration (<tt> infixl 5 +, - </tt>).

-- | A right-associative fixity declaration (<tt> infixr 5 +, - </tt>).

-- | A non-associative fixity declaration (<tt> infix 5 +, - </tt>).

-- | An unguarded right-hand-side (<tt> = 3 </tt>)

-- | An unguarded right-hand-side (<tt> | x == 1 = 3; | otherwise = 4
--   </tt>)

-- | A guarded right-hand side of a value binding (<tt> | x &gt; 3 = 2
--   </tt>)

-- | A bind statement in a pattern guard (<tt> Just v &lt;- x </tt>)

-- | A let statement in a pattern guard (<tt> let x = 3 </tt>)

-- | An expression to check for a pattern guard

-- | Creates an expression to check for a pattern guard
mkGuardCheck :: Expr -> RhsGuard

-- | Creates a let statement in a pattern guard (<tt> let x = 3 </tt>)
mkGuardLet :: [LocalBind] -> RhsGuard

-- | Creates a bind statement in a pattern guard (<tt> Just v &lt;- x
--   </tt>)
mkGuardBind :: Pattern -> Expr -> RhsGuard

-- | Creates a guarded right-hand side of a value binding (<tt> | x &gt; 3
--   = 2 </tt>)
mkGuardedRhs :: [RhsGuard] -> Expr -> GuardedRhs

-- | Creates an unguarded right-hand-side (<tt> | x == 1 = 3; | otherwise =
--   4 </tt>)
mkGuardedRhss :: [GuardedRhs] -> Rhs

-- | Creates an unguarded right-hand-side (<tt> = 3 </tt>)
mkUnguardedRhs :: Expr -> Rhs

-- | Creates a non-associative fixity declaration (<tt> infix 5 +, -
--   </tt>).
mkInfix :: Int -> Operator -> FixitySignature

-- | Creates a right-associative fixity declaration (<tt> infixr 5 +, -
--   </tt>).
mkInfixR :: Int -> Operator -> FixitySignature

-- | Creates a left-associative fixity declaration (<tt> infixl 5 +, -
--   </tt>).
mkInfixL :: Int -> Operator -> FixitySignature

-- | Creates a type signature (<tt> f :: Int -&gt; Int </tt>)
mkTypeSignature :: Name -> Type -> TypeSignature

-- | Creates a local fixity declaration
mkLocalFixity :: FixitySignature -> LocalBind

-- | Creates a local type signature
mkLocalTypeSig :: TypeSignature -> LocalBind

-- | Creates a local binding for a value
mkLocalValBind :: ValueBind -> LocalBind
mkLocalBinds' :: [LocalBind] -> LocalBinds

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
mkLocalBinds :: [LocalBind] -> MaybeLocalBinds

-- | Creates an infix match lhs for an operator (<tt> a + b </tt>)
mkInfixLhs :: Pattern -> Operator -> Pattern -> [Pattern] -> MatchLhs

-- | Creates a match lhs with the function name and parameter names (<tt> f
--   a b </tt>)
mkMatchLhs :: Name -> [Pattern] -> MatchLhs

-- | Creates a clause of function binding
mkMatch :: MatchLhs -> Rhs -> Maybe LocalBinds -> Match

-- | A simplified function for creating function bindings without local
--   definitions or guards.
mkFunctionBind' :: Name -> [([Pattern], Expr)] -> ValueBind

-- | Creates a function binding (<tt> f 0 = 1; f x = x </tt>). All matches
--   must have the same name.
mkFunctionBind :: [Match] -> ValueBind

-- | Creates a value binding (<tt> v = "12" </tt>).
mkSimpleBind :: Pattern -> Rhs -> Maybe LocalBinds -> ValueBind

-- | A simplified function to generate simple value bindings without local
--   definitions, guards or complex lhs.
mkSimpleBind' :: Name -> Expr -> ValueBind

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
mkConlikeAnnotation :: ConlikeAnnot

-- | The whole module is annotated
mkModuleAnnotation :: AnnotationSubject

-- | A type with the given name is annotated
mkTypeAnnotation :: Name -> AnnotationSubject

-- | The definition with the given name is annotated
mkNameAnnotation :: Name -> AnnotationSubject
mkRuleVar :: Name -> RuleVar

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
mkRewriteRule :: String -> Maybe PhaseControl -> [RuleVar] -> Expr -> Expr -> Rule

-- | Marks that the pragma should be applied until a given compile phase
--   (<tt> [~2] </tt>)
mkPhaseControlUntil :: Integer -> PhaseControl

-- | Marks that the pragma should be applied from a given compile phase
--   (<tt> [2] </tt>)
mkPhaseControlFrom :: Integer -> PhaseControl

-- | A pragma that tells the compiler that a polymorph function should be
--   optimized for a given type (<tt> {-# SPECIALISE f :: Int -&gt; b -&gt;
--   b #-} </tt>)
mkSpecializePragma :: Maybe PhaseControl -> Name -> [Type] -> TopLevelPragma

-- | A pragma for maintaining line numbers in generated sources (<tt> {-#
--   LINE 123 "somefile" #-} </tt>)
mkLinePragma :: Int -> Maybe StringNode -> TopLevelPragma

-- | A pragma that marks a function that it may be inlined by the compiler
--   (<tt> {-# INLINABLE thenUs #-} </tt>)
mkInlinablePragma :: Maybe PhaseControl -> Name -> TopLevelPragma

-- | A pragma that forbids a function from being inlined by the compiler
--   (<tt> {-# NOINLINE f #-} </tt>)
mkNoInlinePragma :: Name -> TopLevelPragma

-- | A pragma that marks a function for inlining to the compiler (<tt> {-#
--   INLINE thenUs #-} </tt>)
mkInlinePragma :: Maybe ConlikeAnnot -> Maybe PhaseControl -> Name -> TopLevelPragma

-- | A pragma that annotates a definition with an arbitrary value (<tt> {-#
--   ANN f 42 #-} </tt>)
mkAnnPragma :: AnnotationSubject -> Expr -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# WARNING
--   unsafePerformIO "you should know what you are doing" #-} </tt>)
mkWarningPragma :: [Name] -> String -> TopLevelPragma

-- | A pragma that marks definitions as deprecated (<tt> {-# DEPRECATED f
--   "f will be replaced by g" #-} </tt>)
mkDeprPragma :: [Name] -> String -> TopLevelPragma

-- | A pragma that introduces source rewrite rules (<tt> {-# RULES
--   "map/map" [2] forall f g xs. map f (map g xs) = map (f.g) xs #-}
--   </tt>)
mkRulePragma :: [Rule] -> TopLevelPragma

-- | Creates a top-level pragmas
mkPragmaDecl :: TopLevelPragma -> Decl
mkPatternSignature :: [Name] -> Type -> PatternSignature

-- | Creates a pattern type signature declaration (<tt> pattern Succ :: Int
--   -&gt; Int </tt>)
mkPatternSignatureDecl :: PatternSignature -> Decl

-- | Creates a pattern synonym with the other direction explicitly
--   specified (<tt> &lt;- App "Int" [] where Int = App "Int" [] </tt>)
mkTwoWayPatSyn :: Pattern -> [Match] -> PatSynRhs

-- | Creates a pattern synonym that can be only used for pattenr matching
--   but not for combining (<tt> &lt;- App "Int" [] </tt>)
mkOneWayPatSyn :: Pattern -> PatSynRhs

-- | Creates an automatically two-way pattern synonym (<tt> = App "Int" []
--   </tt>)
mkSymmetricPatSyn :: Pattern -> PatSynRhs

-- | Creates a record-style pattern synonym left-hand side (<tt> Arrow {
--   arrowFrom, arrowTo } </tt>)
mkRecordPatSyn :: Name -> [Name] -> PatSynLhs

-- | Creates an infix pattern synonym left-hand side (<tt> t1 :+: t2 </tt>)
mkInfixPatSyn :: Name -> Operator -> Name -> PatSynLhs

-- | Creates a left hand side of a pattern synonym with a constructor name
--   and arguments (<tt> Arrow t1 t2 </tt>)
mkConPatSyn :: Name -> [Name] -> PatSynLhs

-- | Creates a pattern synonym (<tt> pattern Arrow t1 t2 = App "-&gt;" [t1,
--   t2] </tt>)
mkPatternSynonym :: PatSynLhs -> PatSynRhs -> Decl

-- | Creates a GADT-style data instance declaration (<tt> data instance Fam
--   T where ... </tt>)
mkGadtDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> Maybe KindConstraint -> [GadtConDecl] -> Decl

-- | Creates a data instance declaration (<tt> data instance Fam T = Con1 |
--   Con2 </tt>)
mkDataInstance :: DataOrNewtypeKeyword -> InstanceRule -> [ConDecl] -> [Deriving] -> Decl

-- | Creates a type family instance declaration (<tt> type instance Fam T =
--   AssignedT </tt>)
mkTypeInstance :: InstanceRule -> Type -> Decl

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
mkTypeEqn :: Type -> Type -> TypeEqn

-- | Specifies the injectivity of a type family (<tt> = r | r -&gt; a
--   </tt>)
mkTypeFamilyInjectivitySpec :: TyVar -> [Name] -> TypeFamilySpec

-- | Specifies the kind of a type family (<tt> :: * -&gt; * </tt>)
mkTypeFamilyKindSpec :: KindConstraint -> TypeFamilySpec

-- | Creates a data family declaration (<tt> data family A a :: * -&gt; *
--   </tt>)
mkDataFamily :: DeclHead -> Maybe KindConstraint -> Decl

-- | Creates a closed type family declaration ( <tt>type family F x where F
--   Int = (); F a = Int</tt> )
mkClosedTypeFamily :: DeclHead -> Maybe TypeFamilySpec -> [TypeEqn] -> Decl

-- | Creates a type family declaration ( <tt>type family F x</tt> )
mkTypeFamily :: DeclHead -> Maybe TypeFamilySpec -> Decl

-- | Specifies that the given foreign import is <tt>unsafe</tt>.
mkUnsafe :: Safety

-- | Specifies <tt>capi</tt> calling convention for foreign import/export.
mkCApi :: CallConv

-- | Specifies <tt>ccall</tt> calling convention for foreign import/export.
mkCCall :: CallConv

-- | Specifies <tt>stdcall</tt> calling convention for foreign
--   import/export.
mkStdCall :: CallConv

-- | Creates a foreign export (<tt> foreign export ccall foo :: Int -&gt;
--   IO Int </tt>)
mkForeignExport :: CallConv -> Name -> Type -> Decl

-- | Creates a foreign import (<tt> foreign import foo :: Int -&gt; IO Int
--   </tt>)
mkForeignImport :: CallConv -> Maybe Safety -> Name -> Type -> Decl

-- | Marks a given type parameter as <tt>phantom</tt>.
mkPhantomRole :: Role

-- | Marks a given type parameter as <tt>representational</tt>.
mkRepresentationalRole :: Role

-- | Marks a given type parameter as <tt>nominal</tt>.
mkNominalRole :: Role

-- | Creates a role annotations (<tt> type role Ptr representational </tt>)
mkRoleDecl :: QualifiedName -> [Role] -> Decl

-- | <tt>INCOHERENT</tt> pragma for type instance definitions
mkIncoherentOverlap :: OverlapPragma

-- | <tt>OVERLAPS</tt> pragma for type instance definitions
mkOverlaps :: OverlapPragma

-- | <tt>OVERLAPPING</tt> pragma for type instance definitions
mkOverlapping :: OverlapPragma

-- | <tt>OVERLAPPABLE</tt> pragma for type instance definitions
mkOverlappable :: OverlapPragma

-- | <tt>NO_OVERLAP</tt> pragma for type instance definitions
mkDisableOverlap :: OverlapPragma

-- | <tt>OVERLAP</tt> pragma for type instance definitions
mkEnableOverlap :: OverlapPragma

-- | Specialize instance pragma (no phase selection is allowed) in a type
--   class instance
mkInstanceSpecializePragma :: Type -> InstBodyDecl

-- | An associated data type implemented using GADT style int a type class
--   instance
mkInstanceDataFamilyGADTDef :: DataOrNewtypeKeyword -> InstanceRule -> Maybe KindConstraint -> [GadtConDecl] -> [Deriving] -> InstBodyDecl

-- | An associated data type implementation (<tt> data A X = C1 | C2 </tt>)
--   int a type class instance
mkInstanceDataFamilyDef :: DataOrNewtypeKeyword -> InstanceRule -> [ConDecl] -> [Deriving] -> InstBodyDecl

-- | An associated type definition (<tt> type A X = B </tt>) in a type
--   class instance
mkInstanceTypeFamilyDef :: TypeEqn -> InstBodyDecl

-- | Type signature in instance definition with <tt>InstanceSigs</tt>
mkInstanceTypeSig :: TypeSignature -> InstBodyDecl

-- | A normal declaration (<tt> f x = 12 </tt>) in a type class instance
mkInstanceBind :: ValueBind -> InstBodyDecl

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
mkInstanceBody :: [InstBodyDecl] -> InstBody

-- | Application to one more type as a part of the instance declaration
mkAppInstanceHead :: InstanceHead -> Type -> InstanceHead

-- | Parenthesized instance head as a part of the instance declaration
mkParenInstanceHead :: InstanceHead -> InstanceHead

-- | Infix application of the type/class name to the left operand as a part
--   of the instance declaration
mkInfixInstanceHead :: Type -> Operator -> InstanceHead

-- | Type or class name as a part of the instance declaration
mkInstanceHead :: Name -> InstanceHead

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the where keyword.
mkInstanceRule :: Maybe Context -> InstanceHead -> InstanceRule

-- | Creates a type class instance declaration (<tt> instance X T [where f
--   = ...] </tt>)
mkInstanceDecl :: Maybe OverlapPragma -> InstanceRule -> Maybe InstBody -> Decl

-- | Infix application of the type/class name to the left operand in a
--   declaration head
mkInfixDeclHead :: TyVar -> Operator -> TyVar -> DeclHead

-- | Application in a declaration head
mkDeclHeadApp :: DeclHead -> TyVar -> DeclHead

-- | Parenthesized type as a declaration head
mkParenDeclHead :: DeclHead -> DeclHead

-- | Type or class name as a declaration head
mkNameDeclHead :: Name -> DeclHead

-- | Both of the minimal formulas are needed (<tt> min1 , min2 </tt>)
mkMinimalAnd :: [MinimalFormula] -> MinimalFormula

-- | One of the minimal formulas are needed (<tt> min1 | min2 </tt>)
mkMinimalOr :: [MinimalFormula] -> MinimalFormula
mkMinimalParen :: MinimalFormula -> MinimalFormula
mkMinimalName :: Name -> MinimalFormula

-- | Minimal pragma: <tt> {-# MINIMAL (==) | (/=) #-} </tt> in a class
mkClsMinimal :: MinimalFormula -> ClassElement

-- | Creates a functional dependency, given on the form <tt>l1 ... ln -&gt;
--   r1 ... rn</tt>
mkFunDep :: [Name] -> [Name] -> FunDep

-- | Creates a default signature (by using <tt>DefaultSignatures</tt>) in
--   class: <tt> default enum :: (Generic a, GEnum (Rep a)) =&gt; [a] </tt>
mkClsDefaultSig :: Name -> Type -> ClassElement

-- | Creates a default choice for type synonym in class: <tt> type T x = TE
--   </tt> or <tt> type instance T x = TE </tt>
mkClsDefaultType :: DeclHead -> Type -> ClassElement

-- | Creates an associated data synonym in class: <tt> data T y :: * </tt>
mkClassElemDataFam :: DeclHead -> Maybe KindConstraint -> ClassElement

-- | Creates an associated type synonym in class: <tt> type T y :: * </tt>
mkClassElemTypeFam :: DeclHead -> Maybe TypeFamilySpec -> ClassElement

-- | Creates a default binding as class element: <tt> f x = "aaa" </tt>
mkClassElemDef :: ValueBind -> ClassElement

-- | Creates a type signature as class element: <tt> f :: A -&gt; B </tt>
mkClassElemSig :: TypeSignature -> ClassElement

-- | Creates the list of declarations that can appear in a typeclass
mkClassBody :: [ClassElement] -> ClassBody

-- | Creates a type class declaration (<tt> class X a where f = ... </tt>)
mkClassDecl :: Maybe Context -> DeclHead -> [FunDep] -> Maybe ClassBody -> Decl

-- | The <tt>newtype</tt> keyword in a type definition
mkNewtypeKeyword :: DataOrNewtypeKeyword

-- | The <tt>data</tt> keyword in a type definition
mkDataKeyword :: DataOrNewtypeKeyword

-- | Creates a deriving clause following a data type declaration. (<tt>
--   deriving Show </tt> or <tt> deriving (Show, Eq) </tt>)
mkDeriving :: [InstanceHead] -> Deriving

-- | Creates a field declaration (<tt> fld :: Int </tt>) for a constructor
mkFieldDecl :: [Name] -> Type -> FieldDecl

-- | Creates an infix data constructor (<tt> t1 :+: t2 </tt>)
mkInfixConDecl :: Type -> Operator -> Type -> ConDecl

-- | Creates a record data constructor (<tt> Point { x :: Double, y ::
--   Double } </tt>)
mkRecordConDecl :: Name -> [FieldDecl] -> ConDecl

-- | Creates an ordinary data constructor (<tt> C t1 t2 </tt>)
mkConDecl :: Name -> [Type] -> ConDecl

-- | Creates a GADT constructor declaration with record syntax (<tt> D1 ::
--   { val :: Int } -&gt; T String </tt>)
mkGadtRecordConDecl :: [Name] -> [FieldDecl] -> Type -> GadtConDecl

-- | Creates a GADT constructor declaration (<tt> D1 :: Int -&gt; T String
--   </tt>)
mkGadtConDecl :: [Name] -> Type -> GadtConDecl

-- | Creates a GADT-style data or newtype declaration.
mkGADTDataDecl :: DataOrNewtypeKeyword -> Maybe Context -> DeclHead -> Maybe KindConstraint -> [GadtConDecl] -> [Deriving] -> Decl

-- | Creates a data or newtype declaration.
mkDataDecl :: DataOrNewtypeKeyword -> Maybe Context -> DeclHead -> [ConDecl] -> [Deriving] -> Decl

-- | Creates a Template Haskell splice declaration (<tt> $(generateDecls)
--   </tt>)
mkSpliceDecl :: Splice -> Decl

-- | Creates a function or value binding (<tt> f x = 12 </tt>)
mkValueBinding :: ValueBind -> Decl

-- | Creates type signature declaration (<tt> f :: Int -&gt; Int </tt>)
mkTypeSigDecl :: TypeSignature -> Decl

-- | Creates default types (<tt> default (T1, T2) </tt>)
mkDefaultDecl :: [Type] -> Decl

-- | Creates a fixity declaration (<tt> infixl 5 +, - </tt>)
mkFixityDecl :: FixitySignature -> Decl

-- | Creates a standalone deriving declaration (<tt> deriving instance X T
--   </tt>)
mkStandaloneDeriving :: Maybe DeriveStrategy -> Maybe OverlapPragma -> InstanceRule -> Decl

-- | Creates a type synonym ( <tt>type String = [Char]</tt> )
mkTypeDecl :: DeclHead -> Type -> Decl

-- | A hole expression <tt>_</tt>
mkHole :: Expr

-- | Right arrow high application: <tt>&gt;&gt;-</tt>
mkRightHighAppl :: ArrowApp

-- | Left arrow high application: <tt>-&lt;&lt;</tt>
mkLeftHighAppl :: ArrowApp

-- | Right arrow application: <tt>&gt;-</tt>
mkRightAppl :: ArrowApp

-- | Left arrow application: <tt>-&lt;</tt>
mkLeftAppl :: ArrowApp

-- | A do-notation in a command
mkDoCmd :: [CmdStmt] -> Cmd

-- | A local binding command (<tt> let z = x+y </tt>)
mkLetCmd :: [LocalBind] -> Cmd -> Cmd

-- | An if command (<tt> if f x y then g -&lt; x+1 else h -&lt; y+2 </tt>)
mkIfCmd :: Expr -> Cmd -> Cmd -> Cmd

-- | A pattern match command
mkCaseCmd :: Expr -> [CmdAlt] -> Cmd

-- | A parenthesized command
mkParenCmd :: Cmd -> Cmd

-- | A lambda command
mkLambdaCmd :: [Pattern] -> Cmd -> Cmd

-- | An infix command application
mkInfixCmd :: Cmd -> Name -> Cmd -> Cmd

-- | A function application command
mkAppCmd :: Cmd -> Expr -> Cmd

-- | A form command (<tt> (|untilA (increment -&lt; x+y) (within 0.5 -&lt;
--   x)|) </tt>)
mkArrowFromCmd :: Expr -> [Cmd] -> Cmd

-- | An arrow application command (<tt> f -&lt; x + 1 </tt>)
mkArrowAppCmd :: Expr -> ArrowApp -> Expr -> Cmd

-- | Create a in-AST source ranges (for generated pragmas)
mkSourceRange :: String -> Integer -> Integer -> Integer -> Integer -> SourceRange

-- | Creates a pragma that describes if an expression was generated from a
--   code fragment by an external tool (<tt> {-# GENERATED "Happy.y"
--   1:15-1:25 #-} </tt>)
mkGeneratedPragma :: SourceRange -> ExprPragma

-- | Creates an <tt>SCC</tt> pragma for defining cost centers for profiling
mkSccPragma :: String -> ExprPragma

-- | Creates a <tt>CORE</tt> pragma for adding notes to expressions.
mkCorePragma :: String -> ExprPragma

-- | Creates a guarded right-hand side of pattern matches binding (<tt> | x
--   &gt; 3 -&gt; 2 </tt>)
mkGuardedCaseRhs :: [RhsGuard] -> Expr -> GuardedCaseRhs

-- | Create a guarded right-hand sides of a pattern match (<tt> | x == 1
--   -&gt; 3; | otherwise -&gt; 4 </tt>)
mkGuardedCaseRhss :: [GuardedCaseRhs] -> CaseRhs

-- | Create a unguarded right-hand side a pattern match (<tt> -&gt; 3
--   </tt>)
mkCaseRhs :: Expr -> CaseRhs

-- | Create a clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
mkAlt :: Pattern -> CaseRhs -> Maybe LocalBinds -> Alt

-- | Create a update the fields of the bounded names to their values (<tt>
--   .. </tt>). Must be the last initializer. Cannot be used in a record
--   update expression.
mkFieldWildcard :: FieldUpdate

-- | Create a update the field to the value of the same name (<tt> x </tt>)
mkFieldPun :: Name -> FieldUpdate

-- | Create a update of a field (<tt> x = 1 </tt>)
mkFieldUpdate :: Name -> Expr -> FieldUpdate

-- | Create a static pointer expression (<tt> static e </tt>). The inner
--   expression must be closed (cannot have variables bound outside)
mkStaticPointer :: Expr -> Expr

-- | Create a lambda case ( <tt>case 0 -&gt; 1; 1 -&gt; 2</tt> )
mkLambdaCase :: [Alt] -> Expr

-- | Create a arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
mkArrowApp :: Expr -> ArrowApp -> Expr -> Expr

-- | Create a arrow definition: <tt>proc a -&gt; f -&lt; a+1</tt>
mkProcExpr :: Pattern -> Cmd -> Expr

-- | Creates a pragma that marks an expression.
mkExprPragma :: ExprPragma -> Expr -> Expr

-- | Create a template haskell quasi quote expression, for example:
--   <tt>[quoter| a + b ]</tt>
mkQuasiQuoteExpr :: QuasiQuote -> Expr

-- | Create a template haskell splice expression, for example: <tt>$(gen
--   a)</tt> or <tt>$x</tt>
mkSpliceExpr :: Splice -> Expr

-- | Create a template haskell bracket expression
mkBracketExpr :: Bracket -> Expr

-- | <tt>''T</tt> for template haskell reifying of types
mkTypeQuote :: Name -> Expr

-- | <tt>'x</tt> for template haskell reifying of expressions
mkVarQuote :: Name -> Expr

-- | Create a explicit type application (<tt> show @Integer (read "5")
--   </tt>)
mkExplicitTypeApp :: Expr -> Type -> Expr

-- | Create a explicit type signature (<tt> x :: Int </tt>)
mkExprTypeSig :: Expr -> Type -> Expr

-- | Create a parallel array comprehensions <tt> [: (x, y) | x &lt;- xs , y
--   &lt;- ys :] </tt> enabled by <tt>ParallelArrays</tt>
mkParArrayComp :: Expr -> [ListCompBody] -> Expr

-- | Create a list comprehension (<tt> [ (x, y) | x &lt;- xs | y &lt;- ys ]
--   </tt>)
mkListComp :: Expr -> [ListCompBody] -> Expr

-- | Create a parallel array enumeration (<tt> [: 1,3 .. 10 :] </tt>)
mkParArrayEnum :: Expr -> Maybe Expr -> Expr -> Expr

-- | Create a enumeration expression (<tt> [1,3..10] </tt>)
mkEnum :: Expr -> Maybe Expr -> Maybe Expr -> Expr

-- | Create a record value update: <tt>p1 { x = 3, y = -2 }</tt>
mkRecUpdate :: Expr -> [FieldUpdate] -> Expr

-- | Create a record value construction: <tt>Point { x = 3, y = -2 }</tt>
mkRecCon :: Name -> [FieldUpdate] -> Expr

-- | Create a right operator section: <tt>(+1)</tt>
mkRightSection :: Operator -> Expr -> Expr

-- | Create a left operator section: <tt>(1+)</tt>
mkLeftSection :: Expr -> Operator -> Expr

-- | Create a parenthesized expression: <tt>( a + b )</tt>
mkParen :: Expr -> Expr

-- | Create a parallel array expression: <tt>[: 1,2,3 :]</tt>
mkParArray :: [Expr] -> Expr

-- | Create a list expression: <tt>[1,2,3]</tt>
mkList :: [Expr] -> Expr

-- | Create a unboxed tuple section, enabled with <tt>TupleSections</tt>
--   (<tt> (#a,,b#) </tt>). One of the elements must be missing.
mkTupleUnboxedSection :: [Maybe Expr] -> Expr

-- | Create a tuple section, enabled with <tt>TupleSections</tt> (<tt>
--   (a,,b) </tt>). One of the elements must be missing.
mkTupleSection :: [Maybe Expr] -> Expr

-- | Create a unboxed tuple expression (<tt> (# e1, e2, e3 #) </tt>)
mkUnboxedTuple :: [Expr] -> Expr

-- | Create a tuple expression (<tt> (e1, e2, e3) </tt>)
mkTuple :: [Expr] -> Expr

-- | Create a mdo-notation expressions (<tt> mdo x &lt;- act1; act2 </tt>)
mkMDoBlock :: [Stmt] -> Expr

-- | Create a do-notation expressions (<tt> do x &lt;- act1; act2 </tt>)
mkDoBlock :: [Stmt] -> Expr

-- | Create a pattern matching expression (<tt> case expr of pat1 -&gt;
--   expr1; pat2 -&gt; expr2 </tt>)
mkCase :: Expr -> [Alt] -> Expr

-- | Create a multi way if expressions with <tt>MultiWayIf</tt> extension
--   (<tt> if | guard1 -&gt; expr1; guard2 -&gt; expr2 </tt>)
mkMultiIf :: [GuardedCaseRhs] -> Expr

-- | Create a if expression (<tt> if a then b else c </tt>)
mkIf :: Expr -> Expr -> Expr -> Expr

-- | Create a local binding (<tt> let x = 2; y = 3 in e x y </tt>)
mkLet :: [LocalBind] -> Expr -> Expr

-- | Create a lambda expression (<tt> \a b -&gt; a + b </tt>)
mkLambda :: [Pattern] -> Expr -> Expr

-- | Create a function application expression (<tt> f 4 </tt>)
mkApp :: Expr -> Expr -> Expr

-- | Create a prefix operator application expression (<tt> -x </tt>)
mkPrefixApp :: Operator -> Expr -> Expr

-- | Create a infix operator application expression (<tt> a + b </tt>)
mkInfixApp :: Expr -> Operator -> Expr -> Expr

-- | Create a literal expression (<tt> 42 </tt>)
mkLit :: Literal -> Expr

-- | Create a expression for a variable or a data constructor (<tt> a
--   </tt>)
mkVar :: Name -> Expr

-- | Creates a list of assertions (<tt> (Eq a, Show a) </tt>)
mkTupleAssertion :: [Assertion] -> Assertion

-- | Creates an assertion for implicit parameter binding (<tt> ?cmp :: a
--   -&gt; a -&gt; Bool </tt>)
mkImplicitAssert :: Name -> Type -> Assertion

-- | Infix class assertion, also contains type equations (<tt> a ~ X y
--   </tt>)
mkInfixAssert :: Type -> Operator -> Type -> Assertion

-- | Class assertion (<tt>Cls x</tt>)
mkClassAssert :: Name -> [Type] -> Assertion

-- | Creates a context of assertions (<tt> C a =&gt; ... </tt>)
mkContext :: Assertion -> Context

-- | Kind of the unit value <tt>()</tt>.
mkPromotedUnitType :: Type

-- | A tuple of elements as a kind.
mkPromotedTupleType :: [Type] -> Type

-- | A list of elements as a kind.
mkPromotedListType :: [Type] -> Type

-- | A data constructor value promoted to the kind level.
mkPromotedConType :: Name -> Type

-- | String value promoted to the kind level.
mkPromotedStringType :: String -> Type

-- | Numeric value promoted to the kind level.
mkPromotedIntType :: Integer -> Type

-- | A Template Haskell quasi-quote type (<tt> [quoter| ... ] </tt>).
mkQuasiQuoteType :: QuasiQuote -> Type

-- | A Template Haskell splice type (<tt> $(genType) </tt>).
mkSpliceType :: Splice -> Type

-- | A named wildcard type (<tt> _t </tt>) with
--   <tt>-XPartialTypeSignatures</tt>
mkNamedWildcardType :: Name -> Type

-- | A wildcard type (<tt> _ </tt>) with <tt>-XPartialTypeSignatures</tt>
mkWildcardType :: Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
mkNoUnpackType :: Type -> Type

-- | Strict type marked with UNPACK pragma. (Usually contains the bang
--   mark.)
mkUnpackType :: Type -> Type

-- | Lazy type marked with <tt>~</tt>. (Should only be used if
--   <tt>Strict</tt> or <tt>StrictData</tt> language extension is used)
mkLazyType :: Type -> Type

-- | Strict type marked with <tt>!</tt>.
mkBangType :: Type -> Type

-- | Type with explicit kind signature (<tt> a :: * </tt>)
mkKindedType :: Type -> Kind -> Type

-- | Type variable or constructor (<tt> a </tt>)
mkVarType :: Name -> Type

-- | Creates a type variable with kind specification (<tt> t :: * </tt>)
mkKindedTypeVar :: Name -> Kind -> TyVar

-- | Creates a simple type variable
mkTypeVar :: Name -> TyVar

-- | Type surrounded by parentheses (<tt> (T a) </tt>)
mkParenType :: Type -> Type

-- | Infix type constructor (<tt> (a &lt;: b) </tt>)
mkInfixTypeApp :: Type -> Operator -> Type -> Type

-- | Type application (<tt> F a </tt>)
mkTypeApp :: Type -> Type -> Type

-- | Parallel array type (<tt> [:a:] </tt>)
mkParArrayType :: Type -> Type

-- | List type with special syntax (<tt> [a] </tt>)
mkListType :: Type -> Type

-- | Unboxed tuple types (<tt> (#a,b#) </tt>)
mkUnboxedTupleType :: [Type] -> Type

-- | Tuple types (<tt> (a,b) </tt>)
mkTupleType :: [Type] -> Type

-- | Function types (<tt> a -&gt; b </tt>)
mkFunctionType :: Type -> Type -> Type

-- | Type with a context (<tt> forall x y . type </tt>)
mkCtxType :: Context -> Type -> Type

-- | Simplified creation of type variables
mkTypeVar' :: Name -> TyVar

-- | Forall types (<tt> forall x y . type </tt>)
mkForallType :: [TyVar] -> Type -> Type

-- | Kind of the unit value <tt>()</tt>.
mkUnitKind :: Kind

-- | A tuple of elements as a kind.
mkTupleKind :: [Kind] -> Kind

-- | A list of elements as a kind.
mkListKind :: [Kind] -> Kind

-- | A data constructor value promoted to the kind level.
mkConKind :: Name -> Kind

-- | String value promoted to the kind level.
mkStringKind :: String -> Kind

-- | Numeric value promoted to the kind level.
mkIntKind :: Integer -> Kind

-- | A list kind (<tt> [k] </tt>)
mkKindList :: Kind -> Kind

-- | Kind application (<tt> k1 k2 </tt>)
mkKindApp :: Kind -> Kind -> Kind

-- | Kind variable (using <tt>PolyKinds</tt> extension)
mkKindVar :: Name -> Kind

-- | A parenthesised kind
mkKindParen :: Kind -> Kind

-- | <tt>-&gt;</tt>, the kind of type constructor
mkKindFun :: Kind -> Kind -> Kind

-- | <tt>#</tt>, the kind of unboxed types
mkKindUnbox :: Kind

-- | <tt>*</tt>, the kind of types
mkKindStar :: Kind

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
mkKindConstraint :: Kind -> KindConstraint

-- | Primitive string literal (of type <tt>Addr#</tt>): <tt>"xxx"#</tt>
mkPrimStringLit :: String -> Literal

-- | Primitive character literal (of type <tt>Char#</tt>):
--   <tt><tt>c</tt>#</tt>
mkPrimCharLit :: Char -> Literal

-- | Primitive double literal (of type <tt>Double#</tt>): <tt>3.14##</tt>
mkPrimDoubleLit :: Rational -> Literal

-- | Primitive float literal (of type <tt>Float#</tt>): <tt>3.14#</tt>
mkPrimFloatLit :: Rational -> Literal

-- | Primitive word literal (of type <tt>Word#</tt>): <tt>32##</tt>
mkPrimWordLit :: Integer -> Literal

-- | Primitive integer literal (of type <tt>Int#</tt>): <tt>32#</tt>
mkPrimIntLit :: Integer -> Literal

-- | Fractional literal: <tt>3.14</tt>
mkFracLit :: Rational -> Literal

-- | Integer literal: <tt>12</tt>
mkIntLit :: Integer -> Literal

-- | String literal: <tt>"abc"</tt>
mkStringLit :: String -> Literal

-- | Character literal: <tt><tt>c</tt></tt>
mkCharLit :: Char -> Literal

-- | A deprecated pragma attached to the module
mkModuleDeprecatedPragma :: [String] -> ModulePragma

-- | A warning pragma attached to the module
mkModuleWarningPragma :: [String] -> ModulePragma

-- | <tt>OPTIONS</tt> pragma, possibly qualified with a tool, e.g.
--   OPTIONS_GHC
mkOptionsGHC :: String -> FilePragma

-- | <tt>LANGUAGE</tt> pragma, listing the enabled language extensions in
--   that file
mkLanguagePragma :: [String] -> FilePragma
mkFilePragmas :: [FilePragma] -> FilePragmaList

-- | The name of a module
mkModuleName :: String -> ModuleName

-- | Restrict the import definition to DONT import the listed names
mkImportHidingList :: [IESpec] -> ImportSpec

-- | Restrict the import definition to ONLY import the listed names
mkImportSpecList :: [IESpec] -> ImportSpec

-- | An import declaration: <tt>import Module.Name</tt>
mkImportDecl :: Bool -> Bool -> Bool -> Maybe String -> ModuleName -> Maybe ModuleName -> Maybe ImportSpec -> ImportDecl

-- | <tt>(..)</tt>: a class exported with all of its methods, or a datatype
--   exported with all of its constructors.
mkSubAll :: SubSpec

-- | <tt>(a,b,c)</tt>: a class exported with some of its methods, or a
--   datatype exported with some of its constructors.
mkSubList :: [Name] -> SubSpec

-- | Marks a pattern synonym to be imported or exported
mkPatternIESpec :: Name -> IESpec

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
mkIESpec :: Name -> Maybe SubSpec -> IESpec

-- | The export of an imported module (<tt> module A </tt>)
mkModuleExport :: ModuleName -> ExportSpec

-- | Export a name and related names
mkExportSpec :: IESpec -> ExportSpec

-- | A list of export specifications surrounded by parentheses
mkExportSpecs :: [ExportSpec] -> ExportSpecs

-- | Module declaration with name and (optional) exports
mkModuleHead :: ModuleName -> Maybe ModulePragma -> Maybe ExportSpecs -> ModuleHead

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
mkModule :: [FilePragma] -> Maybe ModuleHead -> [ImportDecl] -> [Decl] -> Module

-- | Creates a quoted text
mkStringNode :: String -> StringNode

-- | Creates a simple (unqualified) name
mkSimpleName :: String -> QualifiedName

-- | Creates a simple (unqualified) name
mkSimpleName' :: Name -> QualifiedName

-- | Creates a part of a qualified name.
mkNamePart :: String -> NamePart
mkQualifiedName :: [String] -> String -> QualifiedName

-- | Creates an annotated qualified simple name
mkQualifiedName' :: [String] -> Name -> QualifiedName

-- | Creates an implicit name: <tt> ?var </tt>
mkImplicitName :: QualifiedName -> Name

-- | Creates a parenthesized name: <tt> foldl (+) 0 </tt>
mkParenName :: QualifiedName -> Name
mkNormalName :: QualifiedName -> Name

-- | Creates an annotated unqualified (non-operator) binding name:
--   <tt>f</tt> or <tt>(+)</tt>
mkUnqualName' :: Name -> Name

-- | Creates an annotated qualified (non-operator) binding name:
--   <tt>A.B.f</tt> or <tt>(A.B.+)</tt>
mkQualName' :: [String] -> Name -> Name
mkUnqualOp :: String -> Operator

-- | Creates an annotated unqualified operator: <tt>+</tt> or
--   <tt>`mod`</tt>.
mkUnqualOp' :: Name -> Operator

-- | Creates an annotated qualified operator: <tt>A.B.+</tt> or
--   <tt>`A.B.mod`</tt>.
mkQualOp' :: [String] -> Name -> Operator
mkBacktickOp :: [String] -> String -> Operator
mkQualOp :: [String] -> String -> Operator

-- | Creates a simple, unqualified name
mkName :: String -> Name

-- | Wildcard field pattern (<tt> .. </tt>)
mkFieldWildcardPattern :: PatternField

-- | Named field pun (<tt> p </tt>)
mkFieldPunPattern :: Name -> PatternField

-- | Named field pattern (<tt> p = Point 3 2 </tt>)
mkPatternField :: Name -> Pattern -> PatternField

-- | Quasi-quoted patterns: <tt>[| 1 + 2 |]</tt>
mkQuasiQuotePat :: QuasiQuote -> Pattern

-- | Splice patterns: <tt>$(generateX inp)</tt>
mkSplicePat :: Splice -> Pattern

-- | View pattern (<tt> f -&gt; Just 1 </tt>)
mkViewPat :: Expr -> Pattern -> Pattern

-- | Pattern with explicit type signature (<tt> x :: Int </tt>)
mkTypeSigPat :: Pattern -> Type -> Pattern

-- | Bang pattern (<tt> !x </tt>)
mkBangPat :: Pattern -> Pattern

-- | Irrefutable pattern (<tt> ~(x:_) </tt>)
mkIrrefutablePat :: Pattern -> Pattern

-- | Wildcard pattern: (<tt> _ </tt>)
mkWildPat :: Pattern

-- | As-pattern (explicit name binding) (<tt> ls@(hd:_) </tt>)
mkAsPat :: Name -> Pattern -> Pattern

-- | Record pattern (<tt> Point { x = 3, y } </tt>)
mkRecPat :: Name -> [PatternField] -> Pattern

-- | Parenthesised patterns
mkParenPat :: Pattern -> Pattern

-- | Parallel array pattern (<tt> [:1,2,a,x:] </tt>)
mkParArrayPat :: [Pattern] -> Pattern

-- | List pattern (<tt> [1,2,a,x] </tt>)
mkListPat :: [Pattern] -> Pattern

-- | Unboxed tuple pattern (<tt> (# x, y #) </tt>)
mkUnboxTuplePat :: [Pattern] -> Pattern

-- | Tuple pattern (<tt> (x,y) </tt>)
mkTuplePat :: [Pattern] -> Pattern

-- | Constructor application pattern (<tt> Point x y </tt>)
mkAppPat :: Name -> [Pattern] -> Pattern

-- | Infix constructor application pattern (<tt> a :+: b </tt>)
mkInfixAppPat :: Pattern -> Operator -> Pattern -> Pattern

-- | Literal pattern
mkLitPat :: Literal -> Pattern

-- | Pattern name binding
mkVarPat :: Name -> Pattern

-- | Creates a recursive binding command with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
mkRecCmd :: [CmdStmt] -> CmdStmt

-- | Creates a let command (<tt> let x = 3; y = 4 </tt>)
mkLetStmtCmd :: [LocalBind] -> CmdStmt

-- | Creates a non-binding command (<tt> action </tt>)
mkExprCmd :: Cmd -> CmdStmt

-- | Creates a binding command (<tt> x &lt;- action </tt>)
mkBindCmd :: Pattern -> Cmd -> CmdStmt

-- | Grouping statements by <tt>TransformListComp</tt> (<tt> then group by
--   (x + y) using groupWith </tt>)
mkGroupStmt :: Maybe Expr -> Maybe Expr -> CompStmt

-- | Then statements by <tt>TransformListComp</tt> (<tt> then sortWith by
--   (x + y) </tt>)
mkThenStmt :: Expr -> Maybe Expr -> CompStmt

-- | Normal monadic statement of a list comprehension
mkCompStmt :: Stmt -> CompStmt

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
mkListCompBody :: [CompStmt] -> ListCompBody

-- | Creates a recursive binding statement with (<tt> rec b &lt;- f a c; c
--   &lt;- f b a </tt>)
mkRecStmt :: [Stmt] -> Stmt

-- | Creates a let statement (<tt> let x = 3; y = 4 </tt>)
mkLetStmt :: [LocalBind] -> Stmt

-- | Creates a non-binding statement (<tt> action </tt>)
mkExprStmt :: Expr -> Stmt

-- | Creates a binding statement (<tt> x &lt;- action </tt>)
mkBindStmt :: Pattern -> Expr -> Stmt

-- | Declaration bracket (<tt> [d| f :: Int -&gt; Int; f x = x*x |] </tt>)
mkDeclsBracket :: [Decl] -> Bracket

-- | Type bracket (<tt> [t| (Int,Int) |] </tt>)
mkTypeBracket :: Type -> Bracket

-- | Pattern bracket (<tt> [p| Point x y |] </tt>)
mkPatternBracket :: Pattern -> Bracket

-- | Expression bracket (<tt> [| x + y |] </tt>)
mkExprBracket :: Expr -> Bracket

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
mkQuasiQuote :: Name -> String -> QuasiQuote

-- | A splice with parentheses: <tt>$(generate input)</tt>
mkParenSplice :: Expr -> Splice

-- | A simple name splice: <tt>$generateX</tt>
mkIdSplice :: Name -> Splice
type AnnList (node :: * -> * -> *) = AnnListG node IdDom SrcTemplateStage
type AnnMaybe (node :: * -> * -> *) = AnnMaybeG node IdDom SrcTemplateStage

-- | The representation of a haskell module, that is a separate compilation
--   unit. It may or may not have a header.
type Module = Ann UModule IdDom SrcTemplateStage

-- | Module declaration with name and (optional) exports
type ModuleHead = Ann UModuleHead IdDom SrcTemplateStage

-- | A list of export specifications surrounded by parentheses
type ExportSpecs = Ann UExportSpecs IdDom SrcTemplateStage

-- | Export specifier
type ExportSpec = Ann UExportSpec IdDom SrcTemplateStage

-- | Marks a name to be imported or exported with related names
--   (subspecifier)
type IESpec = Ann UIESpec IdDom SrcTemplateStage

-- | Specifies the imported element
type ImportModifier = Ann UImportModifier IdDom SrcTemplateStage

-- | Marks how related names will be imported or exported with a given name
type SubSpec = Ann USubSpec IdDom SrcTemplateStage

-- | Pragmas that must be used after the module head
type ModulePragma = Ann UModulePragma IdDom SrcTemplateStage

-- | Pragmas that must be used before defining the module
type FilePragma = Ann UFilePragma IdDom SrcTemplateStage

-- | An import declaration: <tt>import Module.Name</tt>
type ImportDecl = Ann UImportDecl IdDom SrcTemplateStage

-- | Restriction on the imported names
type ImportSpec = Ann UImportSpec IdDom SrcTemplateStage

-- | Marks the import as qualified: <tt>qualified</tt>
type ImportQualified = Ann UImportQualified IdDom SrcTemplateStage

-- | Marks the import as source: <tt>{-# SOURCE #-}</tt>
type ImportSource = Ann UImportSource IdDom SrcTemplateStage

-- | Marks the import as safe: <tt>safe</tt>
type ImportSafe = Ann UImportSafe IdDom SrcTemplateStage

-- | Marks an imported name to belong to the type namespace: <tt>type</tt>
type TypeNamespace = Ann UTypeNamespace IdDom SrcTemplateStage

-- | Renaming imports (<tt> as A </tt>)
type ImportRenaming = Ann UImportRenaming IdDom SrcTemplateStage

-- | The name of a module
type ModuleName = Ann UModuleName IdDom SrcTemplateStage

-- | The name of the enabled language extension, for example (<tt>
--   LambdaCase </tt>)
type LanguageExtension = Ann ULanguageExtension IdDom SrcTemplateStage

-- | Haskell declaration
type Decl = Ann UDecl IdDom SrcTemplateStage

-- | The list of declarations that can appear in a typeclass
type ClassBody = Ann UClassBody IdDom SrcTemplateStage

-- | Members of a class declaration
type ClassElement = Ann UClassElement IdDom SrcTemplateStage
type DeclHead = Ann UDeclHead IdDom SrcTemplateStage

-- | Instance body is the implementation of the class functions (<tt> where
--   a x = 1; b x = 2 </tt>)
type InstBody = Ann UInstBody IdDom SrcTemplateStage

-- | Declarations inside an instance declaration.
type InstBodyDecl = Ann UInstBodyDecl IdDom SrcTemplateStage

-- | GADT constructor declaration (<tt> D1 :: { val :: Int } -&gt; T String
--   </tt>)
type GadtConDecl = Ann UGadtConDecl IdDom SrcTemplateStage

-- | Type of GADT constructors (can be record types: <tt>{ val :: Int
--   }</tt>)
type GadtConType = Ann UGadtConType IdDom SrcTemplateStage

-- | Marker for a field wildcard. Only needed to attach semantic
--   information in a type-safe way.
type FieldWildcard = Ann UFieldWildcard IdDom SrcTemplateStage

-- | A list of functional dependencies: <tt> | a -&gt; b, c -&gt; d </tt>
--   separated by commas
type FunDeps = Ann UFunDeps IdDom SrcTemplateStage

-- | A functional dependency, given on the form <tt>l1 ... ln -&gt; r1 ...
--   rn</tt>
type FunDep = Ann UFunDep IdDom SrcTemplateStage

-- | A constructor declaration for a datatype
type ConDecl = Ann UConDecl IdDom SrcTemplateStage

-- | The <tt>data</tt> or the <tt>newtype</tt> keyword to define ADTs.
type DataOrNewtypeKeyword = Ann UDataOrNewtypeKeyword IdDom SrcTemplateStage

-- | Field declaration (<tt> fld :: Int </tt>)
type FieldDecl = Ann UFieldDecl IdDom SrcTemplateStage

-- | A deriving clause following a data type declaration. (<tt> deriving
--   Show </tt> or <tt> deriving (Show, Eq) </tt>)
type Deriving = Ann UDeriving IdDom SrcTemplateStage

-- | A deriving strategy (<tt>stock</tt>, <tt>newtype</tt> or
--   <tt>anyclass</tt>)
type DeriveStrategy = Ann UDeriveStrategy IdDom SrcTemplateStage

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the where keyword.
type InstanceRule = Ann UInstanceRule IdDom SrcTemplateStage

-- | The specification of the class instance declaration
type InstanceHead = Ann UInstanceHead IdDom SrcTemplateStage

-- | Specialize pragma (<tt> {--} </tt>)
type SpecializePragma = Ann USpecializePragma IdDom SrcTemplateStage

-- | Overlap pragmas. Can be applied to class declarations and class
--   instance declarations.
type OverlapPragma = Ann UOverlapPragma IdDom SrcTemplateStage

-- | Type equations as found in closed type families (<tt> T A = S </tt>)
type TypeEqn = Ann UTypeEqn IdDom SrcTemplateStage

-- | Top level pragmas
type TopLevelPragma = Ann UTopLevelPragma IdDom SrcTemplateStage

-- | A rewrite rule (<tt> "map/map" forall f g xs. map f (map g xs) = map
--   (f.g) xs </tt>)
type Rule = Ann URule IdDom SrcTemplateStage

-- | A variable for a rewrite rule. With or without type signature.
type RuleVar = Ann URuleVar IdDom SrcTemplateStage

-- | Annotation allows you to connect an expression to any declaration.
type AnnotationSubject = Ann UAnnotationSubject IdDom SrcTemplateStage

-- | Formulas of minimal annotations declaring which functions should be
--   defined.
type MinimalFormula = Ann UMinimalFormula IdDom SrcTemplateStage

-- | In-AST source ranges (for generated pragmas)
type SourceRange = Ann USourceRange IdDom SrcTemplateStage

-- | Open type and data families
type TypeFamily = Ann UTypeFamily IdDom SrcTemplateStage

-- | Type family specification with kinds specification and injectivity.
type TypeFamilySpec = Ann UTypeFamilySpec IdDom SrcTemplateStage

-- | Injectivity annotation for type families (<tt> = r | r -&gt; a </tt>)
type InjectivityAnn = Ann UInjectivityAnn IdDom SrcTemplateStage

-- | Pattern synonyms: <tt> pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
--   </tt>
type PatternSynonym = Ann UPatternSynonym IdDom SrcTemplateStage

-- | Right-hand side of pattern synonym
type PatSynRhs = Ann UPatSynRhs IdDom SrcTemplateStage

-- | Left hand side of a pattern synonym
type PatSynLhs = Ann UPatSynLhs IdDom SrcTemplateStage

-- | Where clause of pattern synonym (explicit expression direction)
type PatSynWhere = Ann UPatSynWhere IdDom SrcTemplateStage

-- | Pattern type signature declaration (<tt> pattern Succ :: Int -&gt; Int
--   </tt>)
type PatternSignature = Ann UPatternTypeSignature IdDom SrcTemplateStage

-- | Role annotations for types
type Role = Ann URole IdDom SrcTemplateStage

-- | Call conventions of foreign functions
type CallConv = Ann UCallConv IdDom SrcTemplateStage

-- | Safety annotations for foreign calls
type Safety = Ann USafety IdDom SrcTemplateStage

-- | A <tt>CONLIKE</tt> modifier for an <tt>INLINE</tt> pragma.
type ConlikeAnnot = Ann UConlikeAnnot IdDom SrcTemplateStage

-- | Controls the activation of a rewrite rule (<tt> [1] </tt>)
type PhaseControl = Ann UPhaseControl IdDom SrcTemplateStage

-- | Value binding for top-level and local bindings
type ValueBind = Ann UValueBind IdDom SrcTemplateStage

-- | Clause of function binding
type Match = Ann UMatch IdDom SrcTemplateStage

-- | Something on the left side of the match
type MatchLhs = Ann UMatchLhs IdDom SrcTemplateStage

-- | Right hand side of a value binding (possible with guards): (<tt> = 3
--   </tt> or <tt> | x == 1 = 3; | otherwise = 4 </tt>)
type Rhs = Ann URhs IdDom SrcTemplateStage

-- | A guarded right-hand side of a value binding (<tt> | x &gt; 3 = 2
--   </tt>)
type GuardedRhs = Ann UGuardedRhs IdDom SrcTemplateStage

-- | Guards for value bindings and pattern matches (<tt> Just v <a>x, v</a>
--   1 </tt>)
type RhsGuard = Ann URhsGuard IdDom SrcTemplateStage

-- | Bindings that are enabled in local blocks (where or let).
type LocalBind = Ann ULocalBind IdDom SrcTemplateStage

-- | Local bindings attached to a declaration (<tt> where x = 42 </tt>)
type LocalBinds = Ann ULocalBinds IdDom SrcTemplateStage

-- | A fixity signature (<tt> infixl 5 +, - </tt>).
type FixitySignature = Ann UFixitySignature IdDom SrcTemplateStage

-- | A type signature (<tt> f :: Int -&gt; Int </tt>)
type TypeSignature = Ann UTypeSignature IdDom SrcTemplateStage

-- | Haskell types
type Type = Ann UType IdDom SrcTemplateStage

-- | Type variable declarations (with possible kind annotation)
type TyVar = Ann UTyVar IdDom SrcTemplateStage
type Context = Ann UContext IdDom SrcTemplateStage

-- | A single assertion in the context
type Assertion = Ann UAssertion IdDom SrcTemplateStage

-- | Kind constraint (<tt> :: * -&gt; * </tt>)
type KindConstraint = Ann UKindConstraint IdDom SrcTemplateStage

-- | Haskell kinds
type Kind = Ann UKind IdDom SrcTemplateStage

-- | Values promoted to the kind level
type PromotedKind = Ann UPromoted UKind IdDom SrcTemplateStage

-- | Haskell expressions
type Expr = Ann UExpr IdDom SrcTemplateStage

-- | Clause of case expression (<tt> Just x -&gt; x + 1 </tt>)
type Alt = Ann UAlt IdDom SrcTemplateStage

-- | Right hand side of a match (possible with guards): (<tt> -&gt; 3 </tt>
--   or <tt> | x == 1 -&gt; 3; | otherwise -&gt; 4 </tt>)
type CaseRhs = Ann UCaseRhs IdDom SrcTemplateStage

-- | A guarded right-hand side of pattern matches binding (<tt> | x &gt; 3
--   -&gt; 2 </tt>)
type GuardedCaseRhs = Ann UGuardedCaseRhs IdDom SrcTemplateStage

-- | Field update expressions
type FieldUpdate = Ann UFieldUpdate IdDom SrcTemplateStage

-- | An element of a tuple section that can be an expression or missing
--   (indicating a value from a parameter)
type TupSecElem = Ann UTupSecElem IdDom SrcTemplateStage

-- | Pragmas that can be applied to expressions
type ExprPragma = Ann UExprPragma IdDom SrcTemplateStage

-- | Special expressions for arrows
type Cmd = Ann UCmd IdDom SrcTemplateStage

-- | Clause of case expression for commands
type CmdAlt = Ann UCmdAlt IdDom SrcTemplateStage

-- | Arrow directions
type ArrowApp = Ann UArrowAppl IdDom SrcTemplateStage

-- | A statement in a do-notation
type Stmt = Ann UStmt IdDom SrcTemplateStage

-- | Keywords <tt>do</tt> or <tt>mdo</tt> to start a do-block
type DoKind = Ann UDoKind IdDom SrcTemplateStage

-- | List comprehension statement
type CompStmt = Ann UCompStmt IdDom SrcTemplateStage

-- | Body of a list comprehension: (<tt> | x &lt;- [1..10] </tt>)
type ListCompBody = Ann UListCompBody IdDom SrcTemplateStage

-- | A do-notation for arrows
type CmdStmt = Ann UCmdStmt IdDom SrcTemplateStage

-- | Representation of patterns for pattern bindings
type Pattern = Ann UPattern IdDom SrcTemplateStage
type PatternField = Ann UPatternField IdDom SrcTemplateStage

-- | A template haskell splice
type Splice = Ann USplice IdDom SrcTemplateStage

-- | Template Haskell bracket expressions
type Bracket = Ann UBracket IdDom SrcTemplateStage

-- | Template haskell quasi-quotation: <tt>[quoter|str]</tt>
type QuasiQuote = Ann UQuasiQuote IdDom SrcTemplateStage

-- | Haskell literals
type Literal = Ann ULiteral IdDom SrcTemplateStage

-- | A definition that functions as an operator
type Operator = Ann UOperator IdDom SrcTemplateStage

-- | A definition that functions as a name
type Name = Ann UName IdDom SrcTemplateStage

-- | Possible qualified names. Contains also implicit names. Linear
--   implicit parameter: <tt>%x</tt>. Non-linear implicit parameter:
--   <tt>?x</tt>.
type QualifiedName = Ann UQualifiedName IdDom SrcTemplateStage

-- | Parts of a qualified name.
type NamePart = Ann UNamePart IdDom SrcTemplateStage

-- | Program elements formatted as string literals (import packages, pragma
--   texts)
type StringNode = Ann UStringNode IdDom SrcTemplateStage
type MaybeContext = AnnMaybe UContext
type MaybeDeriving = AnnMaybe UDeriving
type MaybeDeriveStrategy = AnnMaybe UDeriveStrategy
type MaybeLocalBinds = AnnMaybe ULocalBinds
type MaybeTypeFamilySpec = AnnMaybe UTypeFamilySpec
type MaybeKindConstraint = AnnMaybe UKindConstraint
type MaybeClassBody = AnnMaybe UClassBody
type MaybeInstBody = AnnMaybe UInstBody
type MaybeExpr = AnnMaybe UExpr
type MaybeExportSpecs = AnnMaybe UExportSpecs
type MaybeImportQualified = AnnMaybe UImportQualified
type MaybeImportSource = AnnMaybe UImportSource
type MaybeImportSafe = AnnMaybe UImportSafe
type MaybeImportSpec = AnnMaybe UImportSpec
type MaybeModuleHead = AnnMaybe UModuleHead
type MaybeImportModifier = AnnMaybe UImportModifier
type MaybeModulePragma = AnnMaybe UModulePragma
type MaybeSubSpec = AnnMaybe USubSpec
type MaybeStringNode = AnnMaybe UStringNode
type MaybeImportRenaming = AnnMaybe UImportRenaming
type MaybeSafety = AnnMaybe USafety
type MaybePhaseControl = AnnMaybe UPhaseControl
type MaybeConlikeAnnot = AnnMaybe UConlikeAnnot
type MaybeFunDeps = AnnMaybe UFunDeps
type MatchList = AnnList UMatch
type DeclList = AnnList UDecl
type PatternList = AnnList UPattern
type OperatorList = AnnList UOperator
type NameList = AnnList UName
type LocalBindList = AnnList ULocalBind
type IESpecList = AnnList UIESpec
type RhsGuardList = AnnList URhsGuard
type GuardedRhsList = AnnList UGuardedRhs
type GuardedCaseRhsList = AnnList UGuardedCaseRhs
type ConDeclList = AnnList UConDecl
type TypeEqnList = AnnList UTypeEqn
type TypeList = AnnList UType
type FieldDeclList = AnnList UFieldDecl
type ExprList = AnnList UExpr
type FieldUpdateList = AnnList UFieldUpdate
type GadtConDeclList = AnnList UGadtConDecl
type ClassElementList = AnnList UClassElement
type InstBodyDeclList = AnnList UInstBodyDecl
type InstanceHeadList = AnnList UInstanceHead
type AltList = AnnList UAlt
type StmtList = AnnList UStmt
type KindList = AnnList UKind
type TyVarList = AnnList UTyVar
type ListCompBodyList = AnnList UListCompBody
type ExportSpecList = AnnList UExportSpec
type FilePragmaList = AnnList UFilePragma
type ImportDeclList = AnnList UImportDecl
type PatternFieldList = AnnList UPatternField
type AssertionList = AnnList UAssertion
type CompStmtList = AnnList UCompStmt
type RuleList = AnnList URule
type RuleVarList = AnnList URuleVar
type RoleList = AnnList URole
type MinimalFormulaList = AnnList UMinimalFormula
type FunDepList = AnnList UFunDep
type TupSecElemList = AnnList UTupSecElem
type CmdList = AnnList UCmd
type CmdAltList = AnnList UCmdAlt
type CmdStmtList = AnnList UCmdStmt
type LanguageExtensionList = AnnList ULanguageExtension
type StringNodeList = AnnList UStringNode
type NamePartList = AnnList UNamePart
type DerivingList = AnnList UDeriving

-- | Exceptions that can occur while loading modules or during internal
--   operations (not during performing the refactor).
data RefactorException
IllegalExtensions :: [String] -> RefactorException
SourceCodeProblem :: ErrorMessages -> RefactorException
UnknownException :: String -> RefactorException

-- | Change in the project, modification or removal of a module.
data RefactorChange
ContentChanged :: ModuleDom -> RefactorChange
[fromContentChanged] :: RefactorChange -> ModuleDom
ModuleRemoved :: String -> RefactorChange
[removedModuleName] :: RefactorChange -> String
ModuleCreated :: String -> UnnamedModule -> SourceFileKey -> RefactorChange
[createdModuleName] :: RefactorChange -> String
[createdModuleContent] :: RefactorChange -> UnnamedModule
[sameLocation] :: RefactorChange -> SourceFileKey

-- | Module name and marker to separate .hs-boot module definitions.
--   Specifies a source file in a working directory.
data SourceFileKey
SourceFileKey :: FilePath -> String -> SourceFileKey
[_sfkFileName] :: SourceFileKey -> FilePath
[_sfkModuleName] :: SourceFileKey -> String

-- | The name of the module and the AST
type ModuleDom = (SourceFileKey, UnnamedModule)

-- | A type for the input and result of refactoring a module
type UnnamedModule = Ann UModule IdDom SrcTemplateStage

-- | Transforms module name to a .hs file name relative to the source root
--   directory.
moduleSourceFile :: String -> FilePath

-- | Transforms a source root relative file name into module name.
sourceFileModule :: FilePath -> String
sfkFileName :: Lens SourceFileKey SourceFileKey FilePath FilePath
sfkModuleName :: Lens SourceFileKey SourceFileKey String String

-- | The information a refactoring can use
data RefactorCtx
RefactorCtx :: Module -> Ann UModule IdDom SrcTemplateStage -> [Ann UImportDecl IdDom SrcTemplateStage] -> RefactorCtx

-- | The name of the module being refactored. Used for accessing implicit
--   imports.
[refModuleName] :: RefactorCtx -> Module
[refCtxRoot] :: RefactorCtx -> Ann UModule IdDom SrcTemplateStage
[refCtxImports] :: RefactorCtx -> [Ann UImportDecl IdDom SrcTemplateStage]

-- | Input and output information for the refactoring TODO: use multiple
--   states instead of Either
newtype LocalRefactorT m a
LocalRefactorT :: WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a -> LocalRefactorT m a
[fromRefactorT] :: LocalRefactorT m a -> WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a

-- | The refactoring monad for the whole project
type Refactor = ExceptT String Ghc

-- | The refactoring monad for a given module
type LocalRefactor = LocalRefactorT Refactor

-- | The type of a refactoring that affects the whole project.
type ProjectRefactoring = [ModuleDom] -> Refactor [RefactorChange]

-- | The type of a refactoring
type Refactoring = ModuleDom -> [ModuleDom] -> Refactor [RefactorChange]

-- | A refactoring that only affects one module
type LocalRefactoring = UnnamedModule -> LocalRefactor UnnamedModule

-- | A monad that can be used to refactor
class Monad m => RefactorMonad m
refactError :: RefactorMonad m => String -> m a
liftGhc :: RefactorMonad m => Ghc a -> m a

-- | A type class for handling definitions that can appear as both
--   top-level and local definitions
class NamedElement d => BindingElem d

-- | Accesses a type signature definition in a local or top-level
--   definition
sigBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) TypeSignature

-- | Accesses a value or function definition in a local or top-level
--   definition
valBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) ValueBind

-- | Accesses a type signature definition in a local or top-level
--   definition
fixitySig :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) FixitySignature

-- | Creates a new definition from a type signature
createTypeSig :: BindingElem d => TypeSignature -> Ann d IdDom SrcTemplateStage

-- | Creates a new definition from a value or function definition
createBinding :: BindingElem d => ValueBind -> Ann d IdDom SrcTemplateStage

-- | Creates a new fixity signature
createFixitySig :: BindingElem d => FixitySignature -> Ann d IdDom SrcTemplateStage

-- | Checks if a given definition is a type signature
isTypeSig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a function or value binding
isBinding :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a fixity signature
isFixitySig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool
getValBindInList :: BindingElem d => RealSrcSpan -> AnnList d -> Maybe ValueBind
valBindsInList :: BindingElem d => Simple Traversal (AnnList d) ValueBind
debugM :: (Monad m, Show a) => m a -> m a
debug :: Show a => a -> a

-- | Displays True iff the wrapped value is a Just
debugMaybeT :: Monad m => MaybeT m a -> MaybeT m a
showOutputable :: Outputable a => a -> String
showName :: Name -> String
showOp :: Operator -> String

-- | Set the minimal indentation recursively for a part of the AST
setMinimalIndent :: SourceInfoTraversal elem => Int -> elem dom SrcTemplateStage -> elem dom SrcTemplateStage

-- | Filters the elements of the list. By default it removes the separator
--   before the element. Of course, if the first element is removed, the
--   following separator is removed as well.
filterList :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e
filterListIndexed :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e

-- | A version of filterList that cares about keeping non-removable code
--   elements (like preprocessor pragmas)
filterListSt :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | A version of filterListIndexed that cares about keeping non-removable
--   code elements (like preprocessor pragmas)
filterListIndexedSt :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | Selects the given indices from a list
sublist :: [Int] -> [a] -> [a]

-- | Selects all but the given indices from a list
notSublist :: [Int] -> [a] -> [a]

-- | Inserts the element in the places where the two positioning functions
--   (one checks the element before, one the element after) allows the
--   placement.
insertWhere :: Bool -> Ann e IdDom SrcTemplateStage -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> AnnList e -> AnnList e

-- | Checks where the element will be inserted given the two positioning
--   functions.
insertIndex :: (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> [Ann e IdDom SrcTemplateStage] -> Maybe Int

-- | Gets the elements and separators from a list. The first separator is
--   zipped to the second element. To the first element, the "" string is
--   zipped.
zipWithSeparators :: AnnList e -> [(([SourceTemplateTextElem], SrcSpan), Ann e IdDom SrcTemplateStage)]
replaceWithJust :: Ann e IdDom SrcTemplateStage -> AnnMaybe e -> AnnMaybe e
replaceWithNothing :: AnnMaybe e -> AnnMaybe e

-- | Remove the container (where or let) when the last binding is removed.
removeEmptyBnds :: Simple Traversal Module ValueBind -> Simple Traversal Module Expr -> Module -> Module

-- | Puts the elements in the orginal order and remove duplicates (elements
--   with the same source range)
normalizeElements :: [Ann e dom SrcTemplateStage] -> [Ann e dom SrcTemplateStage]

-- | Groups elements together into equivalence groups.
groupElemsBy :: Ord k => (a -> k) -> [a] -> [[a]]

-- | Chooses a representative element for each equivalence group, and pairs
--   them with their corresponding group.
reprElems :: [[a]] -> [(a, [a])]

-- | Sorts the elements of a list into equivalence groups based on a
--   function, then chooses a representative element for each group, and
--   pairs them with their corresponding group.
equivalenceGroupsBy :: Ord k => (a -> k) -> [a] -> [(a, [a])]
isJustT :: Monad m => MaybeT m a -> m Bool
isNothingT :: Monad m => MaybeT m a -> m Bool
liftMaybe :: Monad m => Maybe a -> MaybeT m a
fromMaybeT :: Monad m => a -> MaybeT m a -> m a
fromMaybeTM :: Monad m => m a -> MaybeT m a -> m a
maybeT :: Monad m => b -> (a -> b) -> MaybeT m a -> m b
maybeTM :: Monad m => m b -> (a -> m b) -> MaybeT m a -> m b

-- | Performs the given refactoring, transforming it into a Ghc action
runRefactor :: ModuleDom -> [ModuleDom] -> Refactoring -> Ghc (Either String [RefactorChange])

-- | Wraps a refactoring that only affects one module. Performs the
--   per-module finishing touches.
localRefactoring :: LocalRefactoring -> Refactoring

-- | Transform the result of the local refactoring
localRefactoringRes :: ((UnnamedModule -> UnnamedModule) -> a -> a) -> UnnamedModule -> LocalRefactor a -> Refactor a

-- | Re-inserts the elements removed from the AST that should be kept (for
--   example preprocessor directives)
insertText :: SourceInfoTraversal p => [(SrcSpan, String, String)] -> p dom SrcTemplateStage -> p dom SrcTemplateStage

-- | Adds the imports that bring names into scope that are needed by the
--   refactoring
addGeneratedImports :: [Name] -> Module -> Module
registeredNamesFromPrelude :: [Name]
otherNamesFromPrelude :: [String]
qualifiedName :: Name -> String
referenceName :: Name -> LocalRefactor (Ann UName IdDom SrcTemplateStage)
referenceOperator :: Name -> LocalRefactor (Ann UOperator IdDom SrcTemplateStage)

-- | Create a name that references the definition. Generates an import if
--   the definition is not yet imported.
referenceName' :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> LocalRefactor (Ann nt IdDom SrcTemplateStage)

-- | Reference the name by the shortest suitable import
referenceBy :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> [Ann UImportDecl IdDom SrcTemplateStage] -> Ann nt IdDom SrcTemplateStage
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension

-- | The final version of our AST, with type infromation added
type TypedModule = Ann UModule IdDom SrcTemplateStage

-- | A quick function to try the refactorings
tryRefactor :: (RealSrcSpan -> Refactoring) -> String -> ModuleName -> IO ()

-- | Adjust the source range to be applied to the refactored module
correctRefactorSpan :: UnnamedModule -> RealSrcSpan -> RealSrcSpan

-- | Set the given flags for the GHC session. Also gives back a change
--   function that you can use to apply the settings to any flags. Prints
--   out errors and warnings
useFlags :: [String] -> Ghc ([String], DynFlags -> DynFlags)
pprWarning :: Warn -> SDoc
pprErr :: Err -> SDoc

-- | Reloads the package database based on the session flags
reloadPkgDb :: Ghc ()

-- | Initialize GHC flags to default values that support refactoring
initGhcFlags :: Ghc ()
initGhcFlagsForTest :: Ghc ()

-- | Sets up basic flags and settings for GHC
initGhcFlags' :: Bool -> Bool -> Ghc ()

-- | Use the given source directories when searching for imported modules
useDirs :: [FilePath] -> Ghc ()

-- | Don't use the given source directories when searching for imported
--   modules
deregisterDirs :: [FilePath] -> Ghc ()

-- | Translates module name and working directory into the name of the file
--   where the given module should be defined
toFileName :: FilePath -> ModuleName -> FilePath

-- | Translates module name and working directory into the name of the file
--   where the boot module should be defined
toBootFileName :: FilePath -> ModuleName -> FilePath

-- | Get the source directory where the module is located.
getSourceDir :: ModSummary -> IO FilePath

-- | Gets the path to the source file of the module.
getModSumOrig :: ModSummary -> FilePath
keyFromMS :: ModSummary -> SourceFileKey

-- | Gets the module name
getModSumName :: ModSummary -> String

-- | Load the AST of a module given by the working directory and module
--   name.
loadModuleAST :: FilePath -> ModuleName -> Ghc TypedModule

-- | Load the summary of a module given by the working directory and module
--   name.
loadModule :: FilePath -> ModuleName -> Ghc ModSummary

-- | Get the typed representation of a Haskell module.
parseTyped :: ModSummary -> Ghc TypedModule
trfProblem :: String -> a

-- | Modifies the dynamic flags for performing a ghc task
withAlteredDynFlags :: GhcMonad m => (DynFlags -> m DynFlags) -> m a -> m a

-- | Forces the code generation for a given module
forceCodeGen :: ModSummary -> ModSummary
codeGenDfs :: DynFlags -> DynFlags

-- | Forces ASM code generation for a given module
forceAsmGen :: ModSummary -> ModSummary

-- | Normalizes the flags for a module summary
modSumNormalizeFlags :: ModSummary -> ModSummary

-- | Removes all flags that are unintelligable for refactoring
normalizeFlags :: DynFlags -> DynFlags

-- | Read a source range from our textual format:
--   <tt>line:col-line:col</tt> or <tt>line:col</tt>
readSrcSpan :: String -> RealSrcSpan

-- | Read a source location from our format: <tt>line:col</tt>
readSrcLoc :: String -> RealSrcLoc

-- | The signature and behavior of one refactoring that can be executed.
data RefactoringChoice
NamingRefactoring :: String -> RealSrcSpan -> String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoring] :: RefactoringChoice -> RealSrcSpan -> String -> Refactoring
NamingRefactoringIndent :: String -> RealSrcSpan -> String -> Maybe String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoringIndent] :: RefactoringChoice -> RealSrcSpan -> String -> Maybe String -> Refactoring
SelectionRefactoring :: String -> RealSrcSpan -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[selectionRefactoring] :: RefactoringChoice -> RealSrcSpan -> Refactoring
ModuleRefactoring :: String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[moduleRefactoring] :: RefactoringChoice -> Refactoring
ProjectRefactoring :: String -> ProjectRefactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[projectRefactoring] :: RefactoringChoice -> ProjectRefactoring

-- | Executes a given command (choosen from the set of available
--   refactorings) on the selected module and given other modules.
performCommand :: [RefactoringChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String [RefactorChange])

-- | Gets the name of possible refactorings.
refactorCommands :: [RefactoringChoice] -> [String]
data Severity
Error :: Severity
Warning :: Severity
Info :: Severity
data Marker
Marker :: SrcSpan -> Severity -> String -> Marker
[location] :: Marker -> SrcSpan
[severity] :: Marker -> Severity
[message] :: Marker -> String
data QueryChoice
LocationQuery :: String -> RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue -> QueryChoice
[queryName] :: QueryChoice -> String
[locationQuery] :: QueryChoice -> RealSrcSpan -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
GlobalQuery :: String -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue -> QueryChoice
[queryName] :: QueryChoice -> String
[globalQuery] :: QueryChoice -> ModuleDom -> [ModuleDom] -> QueryMonad QueryValue
data QueryValue
GeneralQuery :: Value -> QueryValue
MarkerQuery :: [Marker] -> QueryValue
type QueryMonad = ExceptT String Ghc
type QueryType = String
decompQuery :: QueryValue -> (QueryType, Value)
queryCommands :: [QueryChoice] -> [String]
queryError :: String -> QueryMonad a
performQuery :: [QueryChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String (QueryType, Value))

-- | Different classes of definitions that have different kind of names.
data NameClass

-- | Normal value definitions: functions, variables
Variable :: NameClass

-- | Data constructors
Ctor :: NameClass

-- | Functions with operator-like names
ValueOperator :: NameClass

-- | Constructors with operator-like names
DataCtorOperator :: NameClass

-- | UType definitions with operator-like names
SynonymOperator :: NameClass

-- | Get which category does a given name belong to
classifyName :: RefactorMonad m => Name -> m NameClass

-- | Checks if a given name is a valid module name
validModuleName :: String -> Maybe String

-- | Check if a given name is valid for a given kind of definition
nameValid :: NameClass -> String -> Maybe String
isIdChar :: Char -> Bool
isOperatorChar :: Char -> Bool
opSemName :: Operator -> Maybe Name
declHeadQName :: DeclHead -> QualifiedName
declHeadSemName :: DeclHead -> Maybe Name
instHeadSemName :: InstanceHead -> Maybe Name

-- | Collects the qualified names of the class heads in an assertion.
assertionQNames :: Assertion -> [QualifiedName]

-- | Collects the semantic names of the class heads in an assertion.
assertionSemNames :: Assertion -> [Name]

-- | Extracts the name of a type. In case of a type application, it finds
--   the type being applied. It works only for unambiguous types, so it
--   won't work for tuples.
nameFromType :: Type -> Maybe Name
typeExpr :: Expr -> Ghc Type
literalType :: Literal -> Ghc Type
appTypeMatches :: [ClsInst] -> Type -> [Type] -> Maybe (TCvSubst, Type)
type ClosedTyFam = CoAxiom Branched
hasConstraintKind :: Type -> Bool

-- | Looks up the Type of an entity with an Id of any locality. If the
--   entity being scrutinised is a type variable, it fails.
lookupTypeFromId :: (HasIdInfo' id, GhcMonad m) => id -> MaybeT m Type

-- | Looks up the Type or the Kind of an entity that has an Id. Note: In
--   some cases we only get the Kind of the Id (e.g. for type constructors)
typeOrKindFromId :: HasIdInfo' id => id -> Type

-- | Extracts a Type from a TyThing when possible.
typeFromTyThing :: TyThing -> Maybe Type

-- | Looks up a GHC Type from a Haskell Tools Name (given the name is
--   global) For an identifier, it returns its type. For a data
--   constructor, it returns its type. For a pattern synonym, it returns
--   its builder's type. For a type synonym constructor, it returns its
--   right-hand side. For a coaxiom, it fails.
lookupTypeFromGlobalName :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Name corresponding to a type synonym
lookupTypeSynRhs :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Type
lookupSynDef :: TyThing -> Maybe TyCon
tyconFromTyThing :: TyThing -> Maybe TyCon
tyconFromGHCType :: Type -> Maybe TyCon
isNewtype :: GhcMonad m => Type -> m Bool
lookupType :: GhcMonad m => Type -> MaybeT m TyThing

-- | Looks up a GHC.Class from something that has a type class constructor
--   in it Fails if the argument does not contain a class type constructor
lookupClassWith :: GhcMonad m => (a -> MaybeT m Name) -> a -> MaybeT m Class
lookupClass :: (GhcMonad m, HasNameInfo' n) => n -> MaybeT m Class
lookupClassFromInstance :: GhcMonad m => InstanceHead -> MaybeT m Class
lookupClassFromDeclHead :: GhcMonad m => DeclHead -> MaybeT m Class

-- | Looks up the right-hand side (GHC representation) of a Haskell Tools
--   Type corresponding to a type synonym
semanticsTypeSynRhs :: GhcMonad m => Type -> MaybeT m Type

-- | Converts a global Haskell Tools type to a GHC type
semanticsType :: GhcMonad m => Type -> MaybeT m Type
isNewtypeTyCon :: TyThing -> Bool

-- | Looks up the given name, extracts something out of it. If the
--   extraction is not succesful, it returns False, if it is successful,
--   then checks the result against the predicate. The reasoning behind
--   this, is that the predicate can only be satisfied by a proper name.
satisfies :: (HasNameInfo' n, GhcMonad m) => (TyThing -> Maybe a) -> (a -> Bool) -> n -> MaybeT m Bool

-- | Decides whether a given name is a type family constructor. Fails if
--   the lookup is not successful.
isClassTyConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Decides whether a given name is a standard Haskell98 data constructor.
--   Fails if the lookup is not successful.
isVanillaDataConNameM :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m Bool

-- | Looks up a closed type family from a name.
lookupClosedTyFam :: (HasNameInfo' n, GhcMonad m) => n -> MaybeT m ClosedTyFam

-- | Extract the CoAxioms from a TyThing representing a closed type family.
coAxiomFromTyThing :: TyThing -> Maybe (CoAxiom Branched)

-- | Determines whether a Type itself has a type variable head.
hasTyVarHead :: Type -> Bool

-- | An element of the AST keeping extra information.
data Ann (elem :: * -> * -> *) dom stage
class HasSourceInfo e where {
    type family SourceInfoType e :: *;
}
srcInfo :: HasSourceInfo e => Simple Lens e SourceInfoType e

-- | Extracts or modifies the concrete range corresponding to a given
--   source info. In case of lists and optional elements, it may not
--   contain the elements inside.
class HasRange a
getRange :: HasRange a => a -> SrcSpan
setRange :: HasRange a => SrcSpan -> a -> a
annListElems :: RefMonads w r => Reference w r MU MU AnnListG elem dom stage AnnListG elem dom stage [Ann elem dom stage] [Ann elem dom stage]
annListAnnot :: RefMonads w r => Reference w r MU MU AnnListG elem dom stage AnnListG elem dom stage NodeInfo SemanticInfo dom AnnListG elem ListInfo stage NodeInfo SemanticInfo dom AnnListG elem ListInfo stage
annList :: (RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU AnnListG e d s AnnListG e d s Ann e d s Ann e d s
annJust :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU AnnMaybeG e d s AnnMaybeG e d s Ann e d s Ann e d s
annMaybe :: RefMonads w r => Reference w r MU MU AnnMaybeG elem dom stage AnnMaybeG elem dom stage Maybe Ann elem dom stage Maybe Ann elem dom stage
isAnnNothing :: () => AnnMaybeG e d s -> Bool

-- | A semantic domain for the AST. The semantic domain maps semantic
--   information for the different types of nodes in the AST. The kind of
--   semantic domain for an AST depends on which stages of the compilation
--   it passed. However after transforming the GHC representation to our
--   AST, the domain stays the same. The domain is not applied to the AST
--   elements that are generated while refactoring.
type Domain d = (Typeable d, Data d, SemanticInfo' d SemaInfoDefaultCls ~ NoSemanticInfo, Data SemanticInfo' d SemaInfoNameCls, Data SemanticInfo' d SemaInfoLitCls, Data SemanticInfo' d SemaInfoExprCls, Data SemanticInfo' d SemaInfoImportCls, Data SemanticInfo' d SemaInfoModuleCls, Data SemanticInfo' d SemaInfoWildcardCls)

-- | With this domain, semantic information can be parameterized. In
--   practice it is only used if the compilation cannot proceed past the
--   type checking phase.
data Dom name
data IdDom

-- | A short form of showing a range, without file name, for debugging
--   purposes.
shortShowSpan :: SrcSpan -> String
shortShowSpanWithFile :: SrcSpan -> String

-- | A stage where the annotation controls how the original source code can
--   be retrieved from the AST. A source template is assigned to each node.
--   It has holes where the content of an other node should be printed and
--   ranges for the source code of the node.
data SrcTemplateStage

-- | A class for traversing source information in an AST
class SourceInfoTraversal (a :: * -> * -> *)
sourceInfoTraverseUp :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> f () -> f () -> a dom st1 -> f a dom st2
sourceInfoTraverseDown :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> f () -> f () -> a dom st1 -> f a dom st2
sourceInfoTraverse :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> a dom st1 -> f a dom st2
sourceTemplateNodeRange :: Simple Lens SpanInfo SrcTemplateStage SrcSpan
sourceTemplateNodeElems :: Simple Lens SpanInfo SrcTemplateStage [SourceTemplateElem]
sourceTemplateListRange :: Simple Lens ListInfo SrcTemplateStage SrcSpan
srcTmpListBefore :: Simple Lens ListInfo SrcTemplateStage String
srcTmpListAfter :: Simple Lens ListInfo SrcTemplateStage String
srcTmpDefaultSeparator :: Simple Lens ListInfo SrcTemplateStage String
srcTmpIndented :: Simple Lens ListInfo SrcTemplateStage Maybe [Bool]
srcTmpSeparators :: Simple Lens ListInfo SrcTemplateStage [([SourceTemplateTextElem], SrcSpan)]
sourceTemplateOptRange :: Simple Lens OptionalInfo SrcTemplateStage SrcSpan
srcTmpOptBefore :: Simple Lens OptionalInfo SrcTemplateStage String
srcTmpOptAfter :: Simple Lens OptionalInfo SrcTemplateStage String
data SourceTemplateTextElem
NormalText :: String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
StayingText :: String -> String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
[_lineEndings] :: SourceTemplateTextElem -> String
sourceTemplateText :: Lens SourceTemplateTextElem SourceTemplateTextElem String String
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension
data SpliceInsertionProblem
SpliceInsertionProblem :: SrcSpan -> String -> SpliceInsertionProblem
data ConvertionProblem
ConvertionProblem :: SrcSpan -> String -> ConvertionProblem
UnrootedConvertionProblem :: String -> ConvertionProblem
data TransformationProblem
TransformationProblem :: String -> TransformationProblem
data BreakUpProblem
BreakUpProblem :: RealSrcSpan -> SrcSpan -> [SrcSpan] -> BreakUpProblem
[bupOuter] :: BreakUpProblem -> RealSrcSpan
[bupInner] :: BreakUpProblem -> SrcSpan
[bupSiblings] :: BreakUpProblem -> [SrcSpan]
data PrettyPrintProblem
PrettyPrintProblem :: String -> PrettyPrintProblem
