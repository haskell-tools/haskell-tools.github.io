-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Refactoring Tool for Haskell
--   
--   Contains a set of refactorings based on the Haskell-Tools framework to
--   easily transform a Haskell program. For the descriptions of the
--   implemented refactorings, see the homepage.
@package haskell-tools-refactor
@version 1.0.0.0


-- | Representation of modules, their collections, refactoring changes and
--   exceptions.
module Language.Haskell.Tools.Refactor.Representation

-- | A type for the input and result of refactoring a module
type UnnamedModule = Ann UModule IdDom SrcTemplateStage

-- | The name of the module and the AST
type ModuleDom = (SourceFileKey, UnnamedModule)

-- | Module name and marker to separate .hs-boot module definitions.
--   Specifies a source file in a working directory.
data SourceFileKey
SourceFileKey :: FilePath -> String -> SourceFileKey
[_sfkFileName] :: SourceFileKey -> FilePath
[_sfkModuleName] :: SourceFileKey -> String

-- | Change in the project, modification or removal of a module.
data RefactorChange
ContentChanged :: ModuleDom -> RefactorChange
[fromContentChanged] :: RefactorChange -> ModuleDom
ModuleRemoved :: String -> RefactorChange
[removedModuleName] :: RefactorChange -> String
ModuleCreated :: String -> UnnamedModule -> SourceFileKey -> RefactorChange
[createdModuleName] :: RefactorChange -> String
[createdModuleContent] :: RefactorChange -> UnnamedModule
[sameLocation] :: RefactorChange -> SourceFileKey

-- | Exceptions that can occur while loading modules or during internal
--   operations (not during performing the refactor).
data RefactorException
IllegalExtensions :: [String] -> RefactorException
SourceCodeProblem :: ErrorMessages -> RefactorException
UnknownException :: String -> RefactorException

-- | Transforms module name to a .hs file name relative to the source root
--   directory.
moduleSourceFile :: String -> FilePath

-- | Transforms a source root relative file name into module name.
sourceFileModule :: FilePath -> String
sfkModuleName :: Lens SourceFileKey SourceFileKey String String
sfkFileName :: Lens SourceFileKey SourceFileKey FilePath FilePath
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.RefactorException
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Classes.Ord Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Classes.Eq Language.Haskell.Tools.Refactor.Representation.SourceFileKey
instance GHC.Exception.Exception Language.Haskell.Tools.Refactor.Representation.RefactorException
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Representation.RefactorChange
instance GHC.Show.Show ErrUtils.ErrorMessages


-- | Types and instances for monadic refactorings. The refactoring monad
--   provides automatic importing, keeping important source fragments (such
--   as preprocessor pragmas), and providing contextual information for
--   refactorings.
module Language.Haskell.Tools.Refactor.Monad

-- | A monad that can be used to refactor
class Monad m => RefactorMonad m
refactError :: RefactorMonad m => String -> m a
liftGhc :: RefactorMonad m => Ghc a -> m a

-- | A refactoring that only affects one module
type LocalRefactoring = UnnamedModule -> LocalRefactor UnnamedModule

-- | The type of a refactoring
type Refactoring = ModuleDom -> [ModuleDom] -> Refactor [RefactorChange]

-- | The type of a refactoring that affects the whole project.
type ProjectRefactoring = [ModuleDom] -> Refactor [RefactorChange]

-- | The refactoring monad for a given module
type LocalRefactor = LocalRefactorT Refactor

-- | The refactoring monad for the whole project
type Refactor = ExceptT String Ghc

-- | Input and output information for the refactoring TODO: use multiple
--   states instead of Either
newtype LocalRefactorT m a
LocalRefactorT :: WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a -> LocalRefactorT m a
[fromRefactorT] :: LocalRefactorT m a -> WriterT [Either Name (SrcSpan, String, String)] (ReaderT RefactorCtx m) a

-- | The information a refactoring can use
data RefactorCtx
RefactorCtx :: Module -> Ann UModule IdDom SrcTemplateStage -> [Ann UImportDecl IdDom SrcTemplateStage] -> RefactorCtx

-- | The name of the module being refactored. Used for accessing implicit
--   imports.
[refModuleName] :: RefactorCtx -> Module
[refCtxRoot] :: RefactorCtx -> Ann UModule IdDom SrcTemplateStage
[refCtxImports] :: RefactorCtx -> [Ann UImportDecl IdDom SrcTemplateStage]
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance (DynFlags.HasDynFlags m, GHC.Base.Monad m) => DynFlags.HasDynFlags (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => Control.Monad.Writer.Class.MonadWriter [Data.Either.Either Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)] (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Language.Haskell.Tools.Refactor.Monad.RefactorCtx (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.Haskell.Tools.Refactor.Monad.LocalRefactorT m)
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad Language.Haskell.Tools.Refactor.Monad.LocalRefactor
instance Control.Monad.Trans.Class.MonadTrans Language.Haskell.Tools.Refactor.Monad.LocalRefactorT
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad Language.Haskell.Tools.Refactor.Monad.Refactor
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad m => Language.Haskell.Tools.Refactor.Monad.RefactorMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Language.Haskell.Tools.Refactor.Monad.RefactorMonad m => Language.Haskell.Tools.Refactor.Monad.RefactorMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GhcMonad.GhcMonad m, GHC.Base.Monoid s) => GhcMonad.GhcMonad (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (Exception.ExceptionMonad m, GHC.Base.Monoid s) => Exception.ExceptionMonad (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.State.Strict.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.State.Lazy.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.Reader.ReaderT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Reader.ReaderT s m)
instance GhcMonad.GhcMonad m => GhcMonad.GhcMonad (Control.Monad.Trans.Except.ExceptT s m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (Control.Monad.Trans.Except.ExceptT s m)


-- | Operations for changing the AST
module Language.Haskell.Tools.Refactor.Utils.AST

-- | Remove an element from the AST while keeping the textual parts of it
--   that should not be removed (like preprocessor pragmas).
removeChild :: (SourceInfoTraversal e) => e dom SrcTemplateStage -> LocalRefactor ()

-- | Remove a separator from the AST while keeping the textual parts of it
--   that should not be removed (like preprocessor pragmas).
removeSeparator :: ([SourceTemplateTextElem], SrcSpan) -> LocalRefactor ()


-- | Utilities for transformations that work on both top-level and local
--   definitions
module Language.Haskell.Tools.Refactor.Utils.BindingElem

-- | A type class for handling definitions that can appear as both
--   top-level and local definitions
class NamedElement d => BindingElem d

-- | Accesses a type signature definition in a local or top-level
--   definition
sigBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) TypeSignature

-- | Accesses a value or function definition in a local or top-level
--   definition
valBind :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) ValueBind

-- | Accesses a type signature definition in a local or top-level
--   definition
fixitySig :: BindingElem d => Simple Partial (Ann d IdDom SrcTemplateStage) FixitySignature

-- | Creates a new definition from a type signature
createTypeSig :: BindingElem d => TypeSignature -> Ann d IdDom SrcTemplateStage

-- | Creates a new definition from a value or function definition
createBinding :: BindingElem d => ValueBind -> Ann d IdDom SrcTemplateStage

-- | Creates a new fixity signature
createFixitySig :: BindingElem d => FixitySignature -> Ann d IdDom SrcTemplateStage

-- | Checks if a given definition is a type signature
isTypeSig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a function or value binding
isBinding :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool

-- | Checks if a given definition is a fixity signature
isFixitySig :: BindingElem d => Ann d IdDom SrcTemplateStage -> Bool
getValBindInList :: BindingElem d => RealSrcSpan -> AnnList d -> Maybe ValueBind
valBindsInList :: BindingElem d => Simple Traversal (AnnList d) ValueBind
instance Language.Haskell.Tools.Refactor.Utils.BindingElem.BindingElem Language.Haskell.Tools.AST.Representation.Decls.UDecl
instance Language.Haskell.Tools.Refactor.Utils.BindingElem.BindingElem Language.Haskell.Tools.AST.Representation.Binds.ULocalBind

module Language.Haskell.Tools.Refactor.Utils.Extensions
expandExtension :: Extension -> [Extension]
turnOn :: Bool
turnOff :: Bool
impliedXFlags :: [(Extension, Bool, Extension)]

-- | Map the cabal extensions to the ones that GHC recognizes
translateExtension :: KnownExtension -> Maybe Extension


-- | Utilities to modify the indentation of AST fragments
module Language.Haskell.Tools.Refactor.Utils.Indentation

-- | Set the minimal indentation recursively for a part of the AST
setMinimalIndent :: SourceInfoTraversal elem => Int -> elem dom SrcTemplateStage -> elem dom SrcTemplateStage


-- | Defines operation on AST lists. AST lists carry source information so
--   simple list modification is not enough.
module Language.Haskell.Tools.Refactor.Utils.Lists

-- | Filters the elements of the list. By default it removes the separator
--   before the element. Of course, if the first element is removed, the
--   following separator is removed as well.
filterList :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e
filterListIndexed :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> AnnList e

-- | A version of filterList that cares about keeping non-removable code
--   elements (like preprocessor pragmas)
filterListSt :: SourceInfoTraversal e => (Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | A version of filterListIndexed that cares about keeping non-removable
--   code elements (like preprocessor pragmas)
filterListIndexedSt :: SourceInfoTraversal e => (Int -> Ann e IdDom SrcTemplateStage -> Bool) -> AnnList e -> LocalRefactor (AnnList e)

-- | Selects the given indices from a list
sublist :: [Int] -> [a] -> [a]

-- | Selects all but the given indices from a list
notSublist :: [Int] -> [a] -> [a]

-- | Inserts the element in the places where the two positioning functions
--   (one checks the element before, one the element after) allows the
--   placement.
insertWhere :: Bool -> Ann e IdDom SrcTemplateStage -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> AnnList e -> AnnList e

-- | Checks where the element will be inserted given the two positioning
--   functions.
insertIndex :: (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> (Maybe (Ann e IdDom SrcTemplateStage) -> Bool) -> [Ann e IdDom SrcTemplateStage] -> Maybe Int

-- | Gets the elements and separators from a list. The first separator is
--   zipped to the second element. To the first element, the "" string is
--   zipped.
zipWithSeparators :: AnnList e -> [(([SourceTemplateTextElem], SrcSpan), Ann e IdDom SrcTemplateStage)]


-- | Helper functions for defining refactorings.
module Language.Haskell.Tools.Refactor.Utils.Helpers
replaceWithJust :: Ann e IdDom SrcTemplateStage -> AnnMaybe e -> AnnMaybe e
replaceWithNothing :: AnnMaybe e -> AnnMaybe e

-- | Remove the container (where or let) when the last binding is removed.
removeEmptyBnds :: Simple Traversal Module ValueBind -> Simple Traversal Module Expr -> Module -> Module

-- | Puts the elements in the orginal order and remove duplicates (elements
--   with the same source range)
normalizeElements :: [Ann e dom SrcTemplateStage] -> [Ann e dom SrcTemplateStage]


-- | Basic utilities and types for defining refactorings.
module Language.Haskell.Tools.Refactor.Utils.Monadic

-- | Performs the given refactoring, transforming it into a Ghc action
runRefactor :: ModuleDom -> [ModuleDom] -> Refactoring -> Ghc (Either String [RefactorChange])

-- | Wraps a refactoring that only affects one module. Performs the
--   per-module finishing touches.
localRefactoring :: LocalRefactoring -> Refactoring

-- | Transform the result of the local refactoring
localRefactoringRes :: ((UnnamedModule -> UnnamedModule) -> a -> a) -> UnnamedModule -> LocalRefactor a -> Refactor a

-- | Re-inserts the elements removed from the AST that should be kept (for
--   example preprocessor directives)
insertText :: SourceInfoTraversal p => [(SrcSpan, String, String)] -> p dom SrcTemplateStage -> p dom SrcTemplateStage

-- | Adds the imports that bring names into scope that are needed by the
--   refactoring
addGeneratedImports :: [Name] -> Module -> Module
registeredNamesFromPrelude :: [Name]
otherNamesFromPrelude :: [String]
qualifiedName :: Name -> String
referenceName :: Name -> LocalRefactor (Ann UName IdDom SrcTemplateStage)
referenceOperator :: Name -> LocalRefactor (Ann UOperator IdDom SrcTemplateStage)

-- | Create a name that references the definition. Generates an import if
--   the definition is not yet imported.
referenceName' :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> LocalRefactor (Ann nt IdDom SrcTemplateStage)

-- | Reference the name by the shortest suitable import
referenceBy :: ([String] -> Name -> Ann nt IdDom SrcTemplateStage) -> Name -> [Ann UImportDecl IdDom SrcTemplateStage] -> Ann nt IdDom SrcTemplateStage


-- | Defines utility methods that prepare Haskell modules for refactoring
module Language.Haskell.Tools.Refactor.Prepare

-- | Type synonym for module names.
type ModuleName = String

-- | A quick function to try the refactorings
tryRefactor :: (RealSrcSpan -> Refactoring) -> String -> ModuleName -> IO ()

-- | Adjust the source range to be applied to the refactored module
correctRefactorSpan :: UnnamedModule -> RealSrcSpan -> RealSrcSpan

-- | Set the given flags for the GHC session. Also gives back a change
--   function that you can use to apply the settings to any flags. Prints
--   out errors and warnings
useFlags :: [String] -> Ghc ([String], DynFlags -> DynFlags)

-- | Reloads the package database based on the session flags
reloadPkgDb :: Ghc ()

-- | Initialize GHC flags to default values that support refactoring
initGhcFlags :: Ghc ()
initGhcFlagsForTest :: Ghc ()

-- | Sets up basic flags and settings for GHC
initGhcFlags' :: Bool -> Bool -> Ghc ()

-- | Use the given source directories when searching for imported modules
useDirs :: [FilePath] -> Ghc ()

-- | Don't use the given source directories when searching for imported
--   modules
deregisterDirs :: [FilePath] -> Ghc ()

-- | Translates module name and working directory into the name of the file
--   where the given module should be defined
toFileName :: FilePath -> ModuleName -> FilePath

-- | Translates module name and working directory into the name of the file
--   where the boot module should be defined
toBootFileName :: FilePath -> ModuleName -> FilePath

-- | Get the source directory where the module is located.
getSourceDir :: ModSummary -> IO FilePath

-- | Gets the path to the source file of the module.
getModSumOrig :: ModSummary -> FilePath
keyFromMS :: ModSummary -> SourceFileKey

-- | Gets the module name
getModSumName :: ModSummary -> String

-- | Load the AST of a module given by the working directory and module
--   name.
loadModuleAST :: FilePath -> ModuleName -> Ghc TypedModule

-- | Load the summary of a module given by the working directory and module
--   name.
loadModule :: FilePath -> ModuleName -> Ghc ModSummary

-- | The final version of our AST, with type infromation added
type TypedModule = Ann UModule IdDom SrcTemplateStage

-- | Get the typed representation of a Haskell module.
parseTyped :: ModSummary -> Ghc TypedModule
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension
trfProblem :: String -> a

-- | Modifies the dynamic flags for performing a ghc task
withAlteredDynFlags :: GhcMonad m => (DynFlags -> m DynFlags) -> m a -> m a

-- | Forces the code generation for a given module
forceCodeGen :: ModSummary -> ModSummary
codeGenDfs :: DynFlags -> DynFlags

-- | Forces ASM code generation for a given module
forceAsmGen :: ModSummary -> ModSummary

-- | Normalizes the flags for a module summary
modSumNormalizeFlags :: ModSummary -> ModSummary

-- | Removes all flags that are unintelligable for refactoring
normalizeFlags :: DynFlags -> DynFlags

-- | Read a source range from our textual format:
--   <tt>line:col-line:col</tt> or <tt>line:col</tt>
readSrcSpan :: String -> RealSrcSpan

-- | Read a source location from our format: <tt>line:col</tt>
readSrcLoc :: String -> RealSrcLoc
instance GHC.Show.Show Language.Haskell.Tools.Refactor.Prepare.UnsupportedExtension
instance GHC.Exception.Exception Language.Haskell.Tools.Refactor.Prepare.UnsupportedExtension


-- | Defines a representation to represent refactorings that can be
--   executed on the codebase. Refactorings are differentiated on their
--   signatures (inputs needed to execute).
module Language.Haskell.Tools.Refactor.Refactoring

-- | The signature and behavior of one refactoring that can be executed.
data RefactoringChoice
NamingRefactoring :: String -> (RealSrcSpan -> String -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[namingRefactoring] :: RefactoringChoice -> RealSrcSpan -> String -> Refactoring
SelectionRefactoring :: String -> (RealSrcSpan -> Refactoring) -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[selectionRefactoring] :: RefactoringChoice -> RealSrcSpan -> Refactoring
ModuleRefactoring :: String -> Refactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[moduleRefactoring] :: RefactoringChoice -> Refactoring
ProjectRefactoring :: String -> ProjectRefactoring -> RefactoringChoice
[refactoringName] :: RefactoringChoice -> String
[projectRefactoring] :: RefactoringChoice -> ProjectRefactoring

-- | Executes a given command (choosen from the set of available
--   refactorings) on the selected module and given other modules.
performCommand :: [RefactoringChoice] -> [String] -> Either FilePath ModuleDom -> [ModuleDom] -> Ghc (Either String [RefactorChange])

-- | Gets the name of possible refactorings.
refactorCommands :: [RefactoringChoice] -> [String]


-- | Defines utility operations on Haskell names such as checking if a
--   given identifier is a correct name for a certain kind of Haskell
--   construct.
module Language.Haskell.Tools.Refactor.Utils.Name

-- | Different classes of definitions that have different kind of names.
data NameClass

-- | Normal value definitions: functions, variables
Variable :: NameClass

-- | Data constructors
Ctor :: NameClass

-- | Functions with operator-like names
ValueOperator :: NameClass

-- | Constructors with operator-like names
DataCtorOperator :: NameClass

-- | UType definitions with operator-like names
SynonymOperator :: NameClass

-- | Get which category does a given name belong to
classifyName :: RefactorMonad m => Name -> m NameClass

-- | Checks if a given name is a valid module name
validModuleName :: String -> Maybe String

-- | Check if a given name is valid for a given kind of definition
nameValid :: NameClass -> String -> Maybe String
isIdChar :: Char -> Bool
isOperatorChar :: Char -> Bool

module Language.Haskell.Tools.Refactor.Utils.Type
typeExpr :: Expr -> Ghc Type
appTypeMatches :: [ClsInst] -> Type -> [Type] -> Maybe (TCvSubst, Type)
literalType :: Literal -> Ghc Type


-- | Defines the API for refactorings
module Language.Haskell.Tools.Refactor

-- | An element of the AST keeping extra information.
data Ann (elem :: * -> * -> *) dom stage :: (* -> * -> *) -> * -> * -> *
class HasSourceInfo e where {
    type family SourceInfoType e :: *;
}
srcInfo :: HasSourceInfo e => Simple Lens e SourceInfoType e

-- | Extracts or modifies the concrete range corresponding to a given
--   source info. In case of lists and optional elements, it may not
--   contain the elements inside.
class HasRange a
getRange :: HasRange a => a -> SrcSpan
setRange :: HasRange a => SrcSpan -> a -> a
annListElems :: RefMonads w r => Reference w r MU MU AnnListG elem dom stage AnnListG elem dom stage [Ann elem dom stage] [Ann elem dom stage]
annListAnnot :: RefMonads w r => Reference w r MU MU AnnListG elem dom stage AnnListG elem dom stage NodeInfo SemanticInfo dom AnnListG elem ListInfo stage NodeInfo SemanticInfo dom AnnListG elem ListInfo stage
annList :: (RefMonads w r, MonadPlus r, Morph Maybe r, Morph [] r) => Reference w r MU MU AnnListG e d s AnnListG e d s Ann e d s Ann e d s
annJust :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, Morph Maybe r) => Reference w r MU MU AnnMaybeG e d s AnnMaybeG e d s Ann e d s Ann e d s
annMaybe :: RefMonads w r => Reference w r MU MU AnnMaybeG elem dom stage AnnMaybeG elem dom stage Maybe Ann elem dom stage Maybe Ann elem dom stage
isAnnNothing :: () => AnnMaybeG e d s -> Bool

-- | A semantic domain for the AST. The semantic domain maps semantic
--   information for the different types of nodes in the AST. The kind of
--   semantic domain for an AST depends on which stages of the compilation
--   did it pass. However after transforming the GHC representation to our
--   AST, the domain keeps the same. The domain is not applied to the AST
--   elements that are generated while refactoring.
type Domain d = (Typeable * d, Data d, (~) * SemanticInfo' d SemaInfoDefaultCls NoSemanticInfo, Data SemanticInfo' d SemaInfoNameCls, Data SemanticInfo' d SemaInfoLitCls, Data SemanticInfo' d SemaInfoExprCls, Data SemanticInfo' d SemaInfoImportCls, Data SemanticInfo' d SemaInfoModuleCls, Data SemanticInfo' d SemaInfoWildcardCls)

-- | With this domain, semantic information can be parameterized. In
--   practice it is only used if the compilation cannot proceed past the
--   type checking phase.
data Dom name :: * -> *
data IdDom :: *

-- | A short form of showing a range, without file name, for debugging
--   purposes.
shortShowSpan :: SrcSpan -> String
shortShowSpanWithFile :: SrcSpan -> String

-- | A stage where the annotation controls how the original source code can
--   be retrieved from the AST. A source template is assigned to each node.
--   It has holes where the content of an other node should be printed and
--   ranges for the source code of the node.
data SrcTemplateStage :: *

-- | A class for traversing source information in an AST
class SourceInfoTraversal (a :: * -> * -> *)
sourceInfoTraverseUp :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> f () -> f () -> a dom st1 -> f a dom st2
sourceInfoTraverseDown :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> f () -> f () -> a dom st1 -> f a dom st2
sourceInfoTraverse :: (SourceInfoTraversal a, Monad f) => SourceInfoTrf f st1 st2 -> a dom st1 -> f a dom st2
sourceTemplateNodeRange :: Simple Lens SpanInfo SrcTemplateStage SrcSpan
sourceTemplateNodeElems :: Simple Lens SpanInfo SrcTemplateStage [SourceTemplateElem]
sourceTemplateListRange :: Simple Lens ListInfo SrcTemplateStage SrcSpan
srcTmpListBefore :: Simple Lens ListInfo SrcTemplateStage String
srcTmpListAfter :: Simple Lens ListInfo SrcTemplateStage String
srcTmpDefaultSeparator :: Simple Lens ListInfo SrcTemplateStage String
srcTmpIndented :: Simple Lens ListInfo SrcTemplateStage Maybe [Bool]
srcTmpSeparators :: Simple Lens ListInfo SrcTemplateStage [([SourceTemplateTextElem], SrcSpan)]
sourceTemplateOptRange :: Simple Lens OptionalInfo SrcTemplateStage SrcSpan
srcTmpOptBefore :: Simple Lens OptionalInfo SrcTemplateStage String
srcTmpOptAfter :: Simple Lens OptionalInfo SrcTemplateStage String
data SourceTemplateTextElem :: *
NormalText :: String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
StayingText :: String -> String -> SourceTemplateTextElem
[_sourceTemplateText] :: SourceTemplateTextElem -> String
[_lineEndings] :: SourceTemplateTextElem -> String
sourceTemplateText :: Lens SourceTemplateTextElem SourceTemplateTextElem String String
data UnsupportedExtension
UnsupportedExtension :: String -> UnsupportedExtension
data SpliceInsertionProblem :: *
SpliceInsertionProblem :: SrcSpan -> String -> SpliceInsertionProblem
data ConvertionProblem :: *
ConvertionProblem :: SrcSpan -> String -> ConvertionProblem
UnrootedConvertionProblem :: String -> ConvertionProblem
data TransformationProblem :: *
TransformationProblem :: String -> TransformationProblem
data BreakUpProblem :: *
BreakUpProblem :: RealSrcSpan -> SrcSpan -> [SrcSpan] -> BreakUpProblem
[bupOuter] :: BreakUpProblem -> RealSrcSpan
[bupInner] :: BreakUpProblem -> SrcSpan
[bupSiblings] :: BreakUpProblem -> [SrcSpan]
data PrettyPrintProblem :: *
PrettyPrintProblem :: String -> PrettyPrintProblem
