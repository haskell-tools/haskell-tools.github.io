<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>haskell-tools-refactor-1.0.1.2: Refactoring Tool for Haskell (Index - M)</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">haskell-tools-refactor-1.0.1.2: Refactoring Tool for Haskell</p></div><div id="content"><div id="alphabet"><ul><li><a href="doc-index-A.html">A</a></li><li><a href="doc-index-B.html">B</a></li><li><a href="doc-index-C.html">C</a></li><li><a href="doc-index-D.html">D</a></li><li><a href="doc-index-E.html">E</a></li><li><a href="doc-index-F.html">F</a></li><li><a href="doc-index-G.html">G</a></li><li><a href="doc-index-H.html">H</a></li><li><a href="doc-index-I.html">I</a></li><li><a href="doc-index-J.html">J</a></li><li><a href="doc-index-K.html">K</a></li><li><a href="doc-index-L.html">L</a></li><li><a href="doc-index-M.html">M</a></li><li><a href="doc-index-N.html">N</a></li><li><a href="doc-index-O.html">O</a></li><li><a href="doc-index-P.html">P</a></li><li><a href="doc-index-Q.html">Q</a></li><li><a href="doc-index-R.html">R</a></li><li><a href="doc-index-S.html">S</a></li><li><a href="doc-index-T.html">T</a></li><li><a href="doc-index-U.html">U</a></li><li><a href="doc-index-V.html">V</a></li><li><a href="doc-index-W.html">W</a></li><li><a href="doc-index-Z.html">Z</a></li><li><a href="doc-index-95.html">_</a></li><li><a href="doc-index-All.html">All</a></li></ul></div><div id="index"><p class="caption">Index - M</p><table><tr><td class="src">MagicHash</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MagicHash">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">mapMaybe</td><td class="module">Language.Haskell.Tools.Refactor.Utils.Maybe</td></tr><tr><td class="src">Match</td><td>&nbsp;</td></tr><tr><td class="alt">1 (Data Constructor)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="alt">2 (Type/Class)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchBinds</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MatchLhs</td><td>&nbsp;</td></tr><tr><td class="alt">1 (Data Constructor)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="alt">2 (Type/Class)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchLhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchLhsArgs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchLhsLhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchLhsName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchLhsOperator</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchLhsRhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MatchList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">matchRhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">Maybe</td><td class="module">Language.Haskell.Tools.Refactor.Utils.Maybe</td></tr><tr><td class="src">maybe</td><td class="module">Language.Haskell.Tools.Refactor.Utils.Maybe</td></tr><tr><td class="src">MaybeClassBody</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeConlikeAnnot</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeContext</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeDeriveStrategy</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeDeriving</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeExportSpecs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeExpr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeFunDeps</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeImportModifier</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeImportQualified</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeImportRenaming</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeImportSafe</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeImportSource</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeImportSpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeInstBody</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeKindConstraint</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeLocalBinds</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeModuleHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeModulePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybePhaseControl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeSafety</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeStringNode</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeSubSpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MaybeT</td><td>&nbsp;</td></tr><tr><td class="alt">1 (Type/Class)</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Maybe.html#t:MaybeT">Language.Haskell.Tools.Refactor.Utils.Maybe</a></td></tr><tr><td class="alt">2 (Data Constructor)</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Maybe.html#v:MaybeT">Language.Haskell.Tools.Refactor.Utils.Maybe</a></td></tr><tr><td class="src">maybeT</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Maybe.html#v:maybeT">Language.Haskell.Tools.Refactor.Utils.Maybe</a></td></tr><tr><td class="src">maybeTM</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Maybe.html#v:maybeTM">Language.Haskell.Tools.Refactor.Utils.Maybe</a></td></tr><tr><td class="src">maybeToList</td><td class="module">Language.Haskell.Tools.Refactor.Utils.Maybe</td></tr><tr><td class="src">MaybeTypeFamilySpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MDo</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MDoKeyword</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mhExports</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mhName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mhPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MinimalAnd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">minimalAnds</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MinimalFormula</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MinimalFormulaList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">minimalInner</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MinimalName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">minimalName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MinimalOr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">minimalOrs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MinimalParen</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkAlt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkAnnPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkAppCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkAppInstanceHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkAppPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkArrowApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkArrowAppCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkArrowFromCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkAsPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkBacktickOp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkBangPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkBangType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkBindCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkBindStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkBracketExpr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCApi</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCase</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCaseCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCaseRhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCCall</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCharLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassAssert</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassBody</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassElemDataFam</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassElemDef</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassElemSig</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClassElemTypeFam</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClosedTypeFamily</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClsDefaultSig</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClsDefaultType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkClsMinimal</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCompStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkConDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkConKind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkConlikeAnnotation</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkConPatSyn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkContext</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCorePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkCtxType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDataDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDataFamily</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDataInstance</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDataKeyword</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDeclHeadApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDeclsBracket</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDefaultDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDeprPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDeriving</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDisableOverlap</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDoBlock</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkDoCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkEnableOverlap</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkEnum</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExplicitTypeApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExportSpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExportSpecs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExprBracket</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExprCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExprPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExprStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkExprTypeSig</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFieldDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFieldPun</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFieldPunPattern</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFieldUpdate</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFieldWildcard</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFieldWildcardPattern</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFilePragmas</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFixityDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkForallType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkForeignExport</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkForeignImport</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFracLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFunctionBind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFunctionBind'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFunctionType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkFunDep</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGadtConDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGADTDataDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGadtDataInstance</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGadtRecordConDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGeneratedPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGroupStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardBind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardCheck</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardedCaseRhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardedCaseRhss</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardedRhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardedRhss</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkGuardLet</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkHole</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIdSplice</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIESpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIf</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIfCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkImplicitAssert</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkImplicitName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkImportDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkImportHidingList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkImportSpecList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIncoherentOverlap</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfix</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixAppPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixAssert</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixConDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixDeclHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixInstanceHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixL</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixLhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixPatSyn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixR</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInfixTypeApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInlinablePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInlinePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceBind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceBody</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceDataFamilyDef</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceDataFamilyGADTDef</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceRule</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceSpecializePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceTypeFamilyDef</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkInstanceTypeSig</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIntKind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIntLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkIrrefutablePat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindConstraint</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindedType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindedTypeVar</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindFun</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindParen</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindStar</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindUnbox</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkKindVar</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLambda</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLambdaCase</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLambdaCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLanguagePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLazyType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLeftAppl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLeftHighAppl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLeftSection</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLet</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLetCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLetStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLetStmtCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLinePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkListComp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkListCompBody</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkListKind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkListPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkListType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLitPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLocalBinds</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLocalBinds'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLocalFixity</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLocalTypeSig</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkLocalValBind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMatch</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMatchLhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMDoBlock</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMinimalAnd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMinimalName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMinimalOr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMinimalParen</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModule</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModuleAnnotation</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModuleDeprecatedPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModuleExport</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModuleHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModuleName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkModuleWarningPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkMultiIf</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNameAnnotation</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNameDeclHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNamedWildcardType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNamePart</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNewtypeKeyword</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNoInlinePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNominalRole</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNormalName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkNoUnpackType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkOneWayPatSyn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkOptionsGHC</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkOverlappable</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkOverlapping</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkOverlaps</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParArray</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParArrayComp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParArrayEnum</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParArrayPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParArrayType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParen</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenDeclHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenInstanceHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenSplice</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkParenType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPatternBracket</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPatternField</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPatternIESpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPatternSignature</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPatternSignatureDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPatternSynonym</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPhantomRole</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPhaseControlFrom</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPhaseControlUntil</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPragmaDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrefixApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrimCharLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrimDoubleLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrimFloatLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrimIntLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrimStringLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPrimWordLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkProcExpr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPromotedConType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPromotedIntType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPromotedListType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPromotedStringType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPromotedTupleType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkPromotedUnitType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQualifiedName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQualifiedName'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQualName'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQualOp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQualOp'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQuasiQuote</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQuasiQuoteExpr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQuasiQuotePat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkQuasiQuoteType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecCmd</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecCon</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecordConDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecordPatSyn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRecUpdate</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRepresentationalRole</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRewriteRule</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRightAppl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRightHighAppl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRightSection</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRoleDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRulePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkRuleVar</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSccPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSimpleBind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSimpleBind'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSimpleName</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSimpleName'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSourceRange</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSpecializePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSpliceDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSpliceExpr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSplicePat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSpliceType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkStandaloneDeriving</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkStaticPointer</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkStdCall</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkStringKind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkStringLit</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkStringNode</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSubAll</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSubList</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkSymmetricPatSyn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkThenStmt</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTuple</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTupleAssertion</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTupleKind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTuplePat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTupleSection</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTupleType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTupleUnboxedSection</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTwoWayPatSyn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeAnnotation</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeApp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeBracket</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeEqn</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeFamily</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeFamilyInjectivitySpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeFamilyKindSpec</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeInstance</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeQuote</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeSigDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeSignature</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeSigPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeVar</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkTypeVar'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnboxedTuple</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnboxedTupleType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnboxTuplePat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnguardedRhs</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnitKind</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnpackType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnqualName'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnqualOp</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnqualOp'</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkUnsafe</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkValueBinding</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkVar</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkVarPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkVarQuote</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkVarType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkViewPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkWarningPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkWildcardType</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">mkWildPat</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">modDecl</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">modDeprecatedPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">modHead</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">modImports</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">modSumNormalizeFlags</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Prepare.html#v:modSumNormalizeFlags">Language.Haskell.Tools.Refactor.Prepare</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">Module</td><td>&nbsp;</td></tr><tr><td class="alt">1 (Data Constructor)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="alt">2 (Type/Class)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleAnnotation</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleCreated</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Representation.html#v:ModuleCreated">Language.Haskell.Tools.Refactor.Representation</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleDeprecatedPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleDom</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Representation.html#t:ModuleDom">Language.Haskell.Tools.Refactor.Representation</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleExport</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleHead</td><td>&nbsp;</td></tr><tr><td class="alt">1 (Data Constructor)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="alt">2 (Type/Class)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleName</td><td>&nbsp;</td></tr><tr><td class="alt">1 (Data Constructor)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="alt">2 (Type/Class)</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="alt">3 (Type/Class)</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Prepare.html#t:ModuleName">Language.Haskell.Tools.Refactor.Prepare</a></td></tr><tr><td class="src">moduleNameString</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModulePragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleRefactoring</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Refactoring.html#v:ModuleRefactoring">Language.Haskell.Tools.Refactor.Refactoring</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">moduleRefactoring</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Refactoring.html#v:moduleRefactoring">Language.Haskell.Tools.Refactor.Refactoring</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleRemoved</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Representation.html#v:ModuleRemoved">Language.Haskell.Tools.Refactor.Representation</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">moduleSourceFile</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Representation.html#v:moduleSourceFile">Language.Haskell.Tools.Refactor.Representation</a>, Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">ModuleWarningPragma</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">modWarningStr</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MonadComprehensions</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MonadComprehensions">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">MonadFailDesugaring</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MonadFailDesugaring">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">MonoLocalBinds</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MonoLocalBinds">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">MonomorphismRestriction</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MonomorphismRestriction">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">MonoPatBinds</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MonoPatBinds">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">MultiIf</td><td class="module">Language.Haskell.Tools.Refactor</td></tr><tr><td class="src">MultiParamTypeClasses</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MultiParamTypeClasses">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr><tr><td class="src">MultiWayIf</td><td class="module"><a href="Language-Haskell-Tools-Refactor-Utils-Extensions.html#v:MultiWayIf">Language.Haskell.Tools.Refactor.Utils.Extensions</a></td></tr></table></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>