<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ConstraintKinds, FlexibleContexts, MultiWayIf, ScopedTypeVariables, TupleSections, TypeApplications, TypeFamilies, ViewPatterns #-}
<span class="lineno">    2 </span>module Language.Haskell.Tools.Refactor.Builtin.RenameDefinition
<span class="lineno">    3 </span>  (renameDefinition, renameDefinition', renameDefinitionRefactoring) where
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>import DataCon (dataConFieldLabels, FieldLbl(..), dataConFieldType)
<span class="lineno">    6 </span>import qualified GHC
<span class="lineno">    7 </span>import Id
<span class="lineno">    8 </span>import IdInfo (RecSelParent(..))
<span class="lineno">    9 </span>import Name (OccName(..), NamedThing(..), occNameString)
<span class="lineno">   10 </span>import SrcLoc (RealSrcSpan)
<span class="lineno">   11 </span>import TyCon (tyConDataCons)
<span class="lineno">   12 </span>import Type (funResultTy, eqType)
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>import Control.Monad.State
<span class="lineno">   15 </span>import Control.Reference as Ref
<span class="lineno">   16 </span>import Data.Generics.Uniplate.Data ()
<span class="lineno">   17 </span>import Data.List
<span class="lineno">   18 </span>import Data.List.Split (splitOn)
<span class="lineno">   19 </span>import Data.Maybe
<span class="lineno">   20 </span>import Language.Haskell.Tools.Refactor
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>renameDefinitionRefactoring :: RefactoringChoice
<span class="lineno">   23 </span><span class="decl"><span class="istickedoff">renameDefinitionRefactoring = NamingRefactoring &quot;RenameDefinition&quot; renameDefinition'</span></span>
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>renameDefinition' :: RealSrcSpan -&gt; String -&gt; Refactoring
<span class="lineno">   26 </span><span class="decl"><span class="istickedoff">renameDefinition' sp str mod mods</span>
<span class="lineno">   27 </span><span class="spaces">  </span><span class="istickedoff">= case (getNodeContaining sp (snd mod) :: Maybe QualifiedName) &gt;&gt;= (fmap getName . semanticsName) of</span>
<span class="lineno">   28 </span><span class="spaces">      </span><span class="istickedoff">Just name -&gt; do let sameNames = bindsWithSameName name (snd mod ^? biplateRef)</span>
<span class="lineno">   29 </span><span class="spaces">                      </span><span class="istickedoff">renameDefinition name sameNames str mod mods</span>
<span class="lineno">   30 </span><span class="spaces">        </span><span class="istickedoff">where bindsWithSameName :: GHC.Name -&gt; [FieldWildcard] -&gt; [GHC.Name]</span>
<span class="lineno">   31 </span><span class="spaces">              </span><span class="istickedoff">bindsWithSameName name wcs = catMaybes $ map ((lookup name) . semanticsImplicitFlds) wcs</span>
<span class="lineno">   32 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; case getNodeContaining sp (snd mod) of</span>
<span class="lineno">   33 </span><span class="spaces">                   </span><span class="istickedoff">Just modName -&gt; renameModule (any @[] (sp `isInside`) ((snd mod) ^? modImports&amp;annList&amp;importAs))</span>
<span class="lineno">   34 </span><span class="spaces">                                                </span><span class="istickedoff">(modName ^. moduleNameString) str mod mods</span>
<span class="lineno">   35 </span><span class="spaces">                   </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">refactError &quot;No name is selected&quot;</span></span></span>
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>renameModule :: Bool -&gt; String -&gt; String -&gt; Refactoring
<span class="lineno">   38 </span><span class="decl"><span class="istickedoff">renameModule isAlias from to m mods</span>
<span class="lineno">   39 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">any (nameConflict to) (map snd $ m:mods)</span> = <span class="nottickedoff">refactError &quot;Name conflict when renaming module&quot;</span></span>
<span class="lineno">   40 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">isJust (validModuleName to)</span> = <span class="nottickedoff">refactError $ &quot;The given name is not a valid module name: &quot; ++ fromJust (validModuleName to)</span></span>
<span class="lineno">   41 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = -- here it is important that the delete is the last, because rename</span>
<span class="lineno">   42 </span><span class="spaces">                  </span><span class="istickedoff">-- can still use the info about the deleted module</span>
<span class="lineno">   43 </span><span class="spaces">                  </span><span class="istickedoff">(if isAlias then id else (fmap (\ls -&gt; map (alterChange from to) ls ++ [ModuleRemoved from])))</span>
<span class="lineno">   44 </span><span class="spaces">                    </span><span class="istickedoff">$ mapM (\(name,mod) -&gt; ContentChanged . (name,) &lt;$&gt; localRefactoringRes id <span class="nottickedoff">mod</span> (replaceModuleNames =&lt;&lt; alterNormalNames mod)) (m:mods)</span>
<span class="lineno">   45 </span><span class="spaces">  </span><span class="istickedoff">where alterChange from to (ContentChanged (mod,res))</span>
<span class="lineno">   46 </span><span class="spaces">          </span><span class="istickedoff">| (mod ^. sfkModuleName) == from</span>
<span class="lineno">   47 </span><span class="spaces">          </span><span class="istickedoff">= ModuleCreated to res mod</span>
<span class="lineno">   48 </span><span class="spaces">        </span><span class="istickedoff">alterChange _ _ c = c</span>
<span class="lineno">   49 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   50 </span><span class="spaces">        </span><span class="istickedoff">replaceModuleNames :: LocalRefactoring</span>
<span class="lineno">   51 </span><span class="spaces">        </span><span class="istickedoff">replaceModuleNames = modNames &amp; filtered (\e -&gt; (e ^. moduleNameString) == from) != mkModuleName to</span>
<span class="lineno">   52 </span><span class="spaces">          </span><span class="istickedoff">where modNames = modHead &amp; annJust &amp; (mhName &amp;+&amp; mhExports &amp; annJust &amp; <span class="nottickedoff">espExports</span> &amp; <span class="nottickedoff">annList</span> &amp; <span class="nottickedoff">exportModuleName</span>)</span>
<span class="lineno">   53 </span><span class="spaces">                             </span><span class="istickedoff">&amp;+&amp; modImports &amp; annList &amp; ( importModule</span>
<span class="lineno">   54 </span><span class="spaces">                                                            </span><span class="istickedoff">&amp;+&amp; importAs &amp; annJust &amp; importRename )</span>
<span class="lineno">   55 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   56 </span><span class="spaces">        </span><span class="istickedoff">alterNormalNames :: LocalRefactoring</span>
<span class="lineno">   57 </span><span class="spaces">        </span><span class="istickedoff">alterNormalNames mod =</span>
<span class="lineno">   58 </span><span class="spaces">           </span><span class="istickedoff">biplateRef @_ @QualifiedName &amp; filtered (\e -&gt; concat (intersperse <span class="nottickedoff">&quot;.&quot;</span> (e ^? qualifiers&amp;annList&amp;simpleNameStr)) == from)</span>
<span class="lineno">   59 </span><span class="spaces">             </span><span class="istickedoff">!- (\e -&gt; mkQualifiedName (splitOn &quot;.&quot; to) (e ^. unqualifiedName&amp;simpleNameStr)) $ mod</span>
<span class="lineno">   60 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   61 </span><span class="spaces">        </span><span class="istickedoff">nameConflict :: String -&gt; Module -&gt; Bool</span>
<span class="lineno">   62 </span><span class="spaces">        </span><span class="istickedoff">nameConflict to mod</span>
<span class="lineno">   63 </span><span class="spaces">          </span><span class="istickedoff">= let modName = mod ^? modHead&amp;annJust&amp;mhName&amp;moduleNameString</span>
<span class="lineno">   64 </span><span class="spaces">                </span><span class="istickedoff">imports = mod ^? modImports&amp;annList</span>
<span class="lineno">   65 </span><span class="spaces">                </span><span class="istickedoff">importNames = map (\imp -&gt; fromMaybe (imp ^. importModule) (imp ^? importAs&amp;annJust&amp;importRename) ^. moduleNameString) imports</span>
<span class="lineno">   66 </span><span class="spaces">             </span><span class="istickedoff">in modName == Just to || to `elem` importNames</span></span>
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>renameDefinition :: GHC.Name -&gt; [GHC.Name] -&gt; String -&gt; Refactoring
<span class="lineno">   69 </span><span class="decl"><span class="istickedoff">renameDefinition toChangeOrig toChangeWith newName mod mods</span>
<span class="lineno">   70 </span><span class="spaces">    </span><span class="istickedoff">= do nameCls &lt;- classifyName toChangeOrig</span>
<span class="lineno">   71 </span><span class="spaces">         </span><span class="istickedoff">(changedModules,defFound) &lt;- runStateT (catMaybes &lt;$&gt; mapM (renameInAModule toChangeOrig toChangeWith newName) (mod:mods)) False</span>
<span class="lineno">   72 </span><span class="spaces">         </span><span class="istickedoff">if | isJust (nameValid nameCls newName) -&gt; refactError $ <span class="nottickedoff">&quot;The new name is not valid: &quot; ++ fromJust (nameValid nameCls newName)</span></span>
<span class="lineno">   73 </span><span class="spaces">            </span><span class="istickedoff">| not defFound -&gt; refactError <span class="nottickedoff">&quot;The definition to rename was not found. Maybe it is in another package.&quot;</span></span>
<span class="lineno">   74 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; return $ map ContentChanged changedModules</span>
<span class="lineno">   75 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="istickedoff">renameInAModule :: GHC.Name -&gt; [GHC.Name] -&gt; String -&gt; ModuleDom -&gt; StateT Bool Refactor (Maybe ModuleDom)</span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="istickedoff">renameInAModule toChangeOrig toChangeWith newName (name, mod)</span>
<span class="lineno">   78 </span><span class="spaces">      </span><span class="istickedoff">= mapStateT (localRefactoringRes (\f (a,s) -&gt; (fmap (\(n,r) -&gt; (n, f r)) a,s)) <span class="nottickedoff">mod</span>) $</span>
<span class="lineno">   79 </span><span class="spaces">          </span><span class="istickedoff">do origTT &lt;- GHC.lookupName toChangeOrig</span>
<span class="lineno">   80 </span><span class="spaces">             </span><span class="istickedoff">let origId = case origTT of</span>
<span class="lineno">   81 </span><span class="spaces">                            </span><span class="istickedoff">Just (GHC.AnId id) -&gt; Just id</span>
<span class="lineno">   82 </span><span class="spaces">                            </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno">   83 </span><span class="spaces">             </span><span class="istickedoff">(res, isChanged) &lt;- runStateT (biplateRef !~ changeName toChangeOrig origId toChangeWith newName $ mod) False</span>
<span class="lineno">   84 </span><span class="spaces">             </span><span class="istickedoff">if isChanged then return $ Just (name, res)</span>
<span class="lineno">   85 </span><span class="spaces">                          </span><span class="istickedoff">else return Nothing</span>
<span class="lineno">   86 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">changeName :: GHC.Name -&gt; Maybe Id -&gt; [GHC.Name] -&gt; String -&gt; QualifiedName</span>
<span class="lineno">   88 </span><span class="spaces">                           </span><span class="istickedoff">-&gt; StateT Bool (StateT Bool LocalRefactor) QualifiedName</span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">changeName toChangeOrig origId toChangeWith str name</span>
<span class="lineno">   90 </span><span class="spaces">      </span><span class="istickedoff">| maybe <span class="nottickedoff">False</span> (`elem` toChange) actualName</span>
<span class="lineno">   91 </span><span class="spaces">          </span><span class="istickedoff">&amp;&amp; semanticsDefining name == False</span>
<span class="lineno">   92 </span><span class="spaces">          </span><span class="istickedoff">&amp;&amp; any @[] (\n -&gt; str == occNameString (getOccName (n ^. _1)) &amp;&amp; not (mergeableFields origId (n ^. _1))</span>
<span class="lineno">   93 </span><span class="spaces">                              </span><span class="istickedoff">&amp;&amp; notQualified (n ^. _2))</span>
<span class="lineno">   94 </span><span class="spaces">                     </span><span class="istickedoff">(scopeUpToDef (semanticsScope name) ^? traversal &amp; traversal &amp; filtered (sameNamespace toChangeOrig . (^. _1)))</span>
<span class="lineno">   95 </span><span class="spaces">      </span><span class="istickedoff">= refactError $ <span class="nottickedoff">&quot;The definition clashes with an existing one at: &quot; ++ shortShowSpanWithFile (getRange name)</span> -- name clash with an external definition</span>
<span class="lineno">   96 </span><span class="spaces">      </span><span class="istickedoff">| maybe <span class="nottickedoff">False</span> (`elem` toChange) actualName</span>
<span class="lineno">   97 </span><span class="spaces">      </span><span class="istickedoff">= do put True -- state that something is changed in the local state</span>
<span class="lineno">   98 </span><span class="spaces">           </span><span class="istickedoff">when (actualName == Just toChangeOrig)</span>
<span class="lineno">   99 </span><span class="spaces">             </span><span class="istickedoff">$ lift $ modify (|| semanticsDefining name) -- state that the definition is renamed in the global state</span>
<span class="lineno">  100 </span><span class="spaces">           </span><span class="istickedoff">return $ unqualifiedName .= mkNamePart str $ name -- found the changed name (or a name that have to be changed too)</span>
<span class="lineno">  101 </span><span class="spaces">      </span><span class="istickedoff">| let namesInScope = map (map (^. _1)) $ semanticsScope name</span>
<span class="lineno">  102 </span><span class="spaces">         </span><span class="istickedoff">in case semanticsName name of</span>
<span class="lineno">  103 </span><span class="spaces">              </span><span class="istickedoff">Just (getName -&gt; exprName) -&gt; str == occNameString (getOccName exprName)</span>
<span class="lineno">  104 </span><span class="spaces">                                              </span><span class="istickedoff">&amp;&amp; sameNamespace toChangeOrig exprName</span>
<span class="lineno">  105 </span><span class="spaces">                                              </span><span class="istickedoff">&amp;&amp; conflicts toChangeOrig exprName namesInScope</span>
<span class="lineno">  106 </span><span class="spaces">                                              </span><span class="istickedoff">&amp;&amp; not (mergeableFields origId exprName)</span>
<span class="lineno">  107 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">False</span> -- ambiguous names</span>
<span class="lineno">  108 </span><span class="spaces">      </span><span class="istickedoff">= refactError $ <span class="nottickedoff">&quot;The definition clashes with an existing one: &quot; ++ shortShowSpanWithFile (getRange name)</span> -- local name clash</span>
<span class="lineno">  109 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return name -- not the changed name, leave as before</span>
<span class="lineno">  110 </span><span class="spaces">      </span><span class="istickedoff">where toChange = toChangeOrig : toChangeWith</span>
<span class="lineno">  111 </span><span class="spaces">            </span><span class="istickedoff">actualName = fmap getName (semanticsName name)</span>
<span class="lineno">  112 </span><span class="spaces">            </span><span class="istickedoff">scopeUpToDef sc = let (inside, outside) = span (null . (toChange `intersect`) . map (^. _1)) sc</span>
<span class="lineno">  113 </span><span class="spaces">                               </span><span class="istickedoff">in inside ++ take 1 outside</span>
<span class="lineno">  114 </span><span class="spaces">            </span><span class="istickedoff">mergeableFields (Just orig) conflict</span>
<span class="lineno">  115 </span><span class="spaces">              </span><span class="istickedoff">| isRecordSelector orig</span>
<span class="lineno">  116 </span><span class="spaces">              </span><span class="istickedoff">, RecSelData tc &lt;- recordSelectorTyCon orig</span>
<span class="lineno">  117 </span><span class="spaces">              </span><span class="istickedoff">= let selectorsWithTypes = concatMap (\dc -&gt; map (\fld -&gt; (flSelector fld, dataConFieldType dc (flLabel fld))) (dataConFieldLabels dc))</span>
<span class="lineno">  118 </span><span class="spaces">                                                   </span><span class="istickedoff">(filter (\dc -&gt; toChangeOrig `notElem` map flSelector (dataConFieldLabels dc)) (tyConDataCons tc))</span>
<span class="lineno">  119 </span><span class="spaces">                 </span><span class="istickedoff">in maybe False (`eqType` funResultTy (idType orig)) (lookup conflict selectorsWithTypes)</span>
<span class="lineno">  120 </span><span class="spaces">            </span><span class="istickedoff">mergeableFields _ _ = False</span>
<span class="lineno">  121 </span><span class="spaces">            </span><span class="istickedoff">notQualified usage = isNothing usage || any @[] (not . usageQualified) (usage ^? just &amp; traversal)</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>conflicts :: GHC.Name -&gt; GHC.Name -&gt; [[GHC.Name]] -&gt; Bool
<span class="lineno">  124 </span><span class="decl"><span class="istickedoff">conflicts overwrites overwritten (scopeBlock : scope)</span>
<span class="lineno">  125 </span><span class="spaces">  </span><span class="istickedoff">| overwritten `elem` scopeBlock &amp;&amp; overwrites `notElem` scopeBlock = False</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="istickedoff">| overwrites `elem` scopeBlock = True</span>
<span class="lineno">  127 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = conflicts overwrites overwritten scope</span>
<span class="lineno">  128 </span><span class="spaces"></span><span class="istickedoff">conflicts _ _ [] = False</span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>sameNamespace :: GHC.Name -&gt; GHC.Name -&gt; Bool
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">sameNamespace n1 n2 = occNameSpace (getOccName n1) == occNameSpace (getOccName n2)</span></span>

</pre>
</body>
</html>
