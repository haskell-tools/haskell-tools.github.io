<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- | Generation of expression-level AST fragments for refactorings.
<span class="lineno">    2 </span>-- The bindings defined here create a the annotated version of the AST constructor with the same name.
<span class="lineno">    3 </span>-- For example, @mkApp@ creates the annotated version of the @App@ AST constructor.
<span class="lineno">    4 </span>{-# LANGUAGE MonoLocalBinds, OverloadedStrings #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>module Language.Haskell.Tools.Rewrite.Create.Exprs where
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import Language.Haskell.Tools.AST
<span class="lineno">    9 </span>import Language.Haskell.Tools.PrettyPrint.Prepare
<span class="lineno">   10 </span>import Language.Haskell.Tools.Rewrite.Create.Utils (mkAnn, mkAnnList, mkAnnMaybe)
<span class="lineno">   11 </span>import Language.Haskell.Tools.Rewrite.ElementTypes
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>-- * Expressions
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>-- | Create a expression for a variable or a data constructor (@ a @)
<span class="lineno">   16 </span>mkVar :: Name -&gt; Expr
<span class="lineno">   17 </span><span class="decl"><span class="istickedoff">mkVar = mkAnn child . UVar</span></span>
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>-- | Create a literal expression (@ 42 @)
<span class="lineno">   20 </span>mkLit :: Literal -&gt; Expr
<span class="lineno">   21 </span><span class="decl"><span class="istickedoff">mkLit = mkAnn child . ULit</span></span>
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>-- | Create a infix operator application expression (@ a + b @)
<span class="lineno">   24 </span>mkInfixApp :: Expr -&gt; Operator -&gt; Expr -&gt; Expr
<span class="lineno">   25 </span><span class="decl"><span class="istickedoff">mkInfixApp lhs op rhs = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot; &quot; &lt;&gt; child) $ UInfixApp lhs op rhs</span></span>
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>-- | Create a prefix operator application expression (@ -x @)
<span class="lineno">   28 </span>mkPrefixApp :: Operator -&gt; Expr -&gt; Expr
<span class="lineno">   29 </span><span class="decl"><span class="istickedoff">mkPrefixApp op rhs = mkAnn (child &lt;&gt; child) $ UPrefixApp op rhs</span></span>
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>-- | Create a function application expression (@ f 4 @)
<span class="lineno">   32 </span>mkApp :: Expr -&gt; Expr -&gt; Expr
<span class="lineno">   33 </span><span class="decl"><span class="istickedoff">mkApp f e = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child) (UApp f e)</span></span>
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>-- | Create a lambda expression (@ \\a b -&gt; a + b @)
<span class="lineno">   36 </span>mkLambda :: [Pattern] -&gt; Expr -&gt; Expr
<span class="lineno">   37 </span><span class="decl"><span class="istickedoff">mkLambda pats rhs = mkAnn (&quot;\\&quot; &lt;&gt; child &lt;&gt; &quot; -&gt; &quot; &lt;&gt; child) $ ULambda (mkAnnList (separatedBy &quot; &quot; list) pats) rhs</span></span>
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>-- | Create a local binding (@ let x = 2; y = 3 in e x y @)
<span class="lineno">   40 </span>mkLet :: [LocalBind] -&gt; Expr -&gt; Expr
<span class="lineno">   41 </span><span class="decl"><span class="istickedoff">mkLet pats expr = mkAnn (&quot;let &quot; &lt;&gt; child &lt;&gt; &quot; in &quot; &lt;&gt; child) $ ULet (mkAnnList (indented list) pats) expr</span></span>
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>-- | Create a if expression (@ if a then b else c @)
<span class="lineno">   44 </span>mkIf :: Expr -&gt; Expr -&gt; Expr -&gt; Expr
<span class="lineno">   45 </span><span class="decl"><span class="istickedoff">mkIf cond then_ else_ = mkAnn (&quot;if &quot; &lt;&gt; child &lt;&gt; &quot; then &quot; &lt;&gt; child &lt;&gt; &quot; else &quot; &lt;&gt; child) $ UIf cond then_ else_</span></span>
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>-- | Create a multi way if expressions with @MultiWayIf@ extension (@ if | guard1 -&gt; expr1; guard2 -&gt; expr2 @)
<span class="lineno">   48 </span>mkMultiIf :: [GuardedCaseRhs] -&gt; Expr
<span class="lineno">   49 </span><span class="decl"><span class="istickedoff">mkMultiIf cases = mkAnn (&quot;if&quot; &lt;&gt; child) $ UMultiIf (mkAnnList (indented list) cases)</span></span>
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>-- | Create a pattern matching expression (@ case expr of pat1 -&gt; expr1; pat2 -&gt; expr2 @)
<span class="lineno">   52 </span>mkCase :: Expr -&gt; [Alt] -&gt; Expr
<span class="lineno">   53 </span><span class="decl"><span class="istickedoff">mkCase expr cases = mkAnn (&quot;case &quot; &lt;&gt; child &lt;&gt; &quot; of &quot; &lt;&gt; child) $ UCase expr (mkAnnList (indented list) cases)</span></span>
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>-- | Create a do-notation expressions (@ do x &lt;- act1; act2 @)
<span class="lineno">   56 </span>mkDoBlock :: [Stmt] -&gt; Expr
<span class="lineno">   57 </span><span class="decl"><span class="istickedoff">mkDoBlock stmts = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child) $ UDo (mkAnn &quot;do&quot; UDoKeyword) (mkAnnList (indented list) stmts)</span></span>
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>-- | Create a mdo-notation expressions (@ mdo x &lt;- act1; act2 @)
<span class="lineno">   60 </span>mkMDoBlock :: [Stmt] -&gt; Expr
<span class="lineno">   61 </span><span class="decl"><span class="nottickedoff">mkMDoBlock stmts = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child) $ UDo (mkAnn &quot;mdo&quot; UMDoKeyword) (mkAnnList (indented list) stmts)</span></span>
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- | Create a tuple expression (@ (e1, e2, e3) @)
<span class="lineno">   65 </span>mkTuple :: [Expr] -&gt; Expr
<span class="lineno">   66 </span><span class="decl"><span class="istickedoff">mkTuple exprs = mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) $ UTuple (mkAnnList (separatedBy &quot;, &quot; list) exprs)</span></span>
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>-- | Create a unboxed tuple expression (@ (\# e1, e2, e3 \#) @)
<span class="lineno">   69 </span>mkUnboxedTuple :: [Expr] -&gt; Expr
<span class="lineno">   70 </span><span class="decl"><span class="nottickedoff">mkUnboxedTuple exprs = mkAnn (&quot;(# &quot; &lt;&gt; child &lt;&gt; &quot; #)&quot;) $ UTuple (mkAnnList (separatedBy &quot;, &quot; list) exprs)</span></span>
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>-- | Create a tuple section, enabled with @TupleSections@ (@ (a,,b) @). One of the elements must be missing.
<span class="lineno">   73 </span>mkTupleSection :: [Maybe Expr] -&gt; Expr
<span class="lineno">   74 </span><span class="decl"><span class="nottickedoff">mkTupleSection elems</span>
<span class="lineno">   75 </span><span class="spaces">  </span><span class="nottickedoff">= let tupSecs = map (maybe (mkAnn &quot;&quot; Missing) (mkAnn child . Present)) elems</span>
<span class="lineno">   76 </span><span class="spaces">     </span><span class="nottickedoff">in mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) $ UTupleSection (mkAnnList (separatedBy &quot;, &quot; list) tupSecs)</span></span>
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- | Create a unboxed tuple section, enabled with @TupleSections@ (@ (\#a,,b\#) @). One of the elements must be missing.
<span class="lineno">   79 </span>mkTupleUnboxedSection :: [Maybe Expr] -&gt; Expr
<span class="lineno">   80 </span><span class="decl"><span class="nottickedoff">mkTupleUnboxedSection elems</span>
<span class="lineno">   81 </span><span class="spaces">  </span><span class="nottickedoff">= let tupSecs = map (maybe (mkAnn &quot;&quot; Missing) (mkAnn child . Present)) elems</span>
<span class="lineno">   82 </span><span class="spaces">     </span><span class="nottickedoff">in mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) $ UTupleSection (mkAnnList (separatedBy &quot;, &quot; list) tupSecs)</span></span>
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>-- | Create a list expression: @[1,2,3]@
<span class="lineno">   85 </span>mkList :: [Expr] -&gt; Expr
<span class="lineno">   86 </span><span class="decl"><span class="istickedoff">mkList exprs = mkAnn (&quot;[&quot; &lt;&gt; child &lt;&gt; &quot;]&quot;) $ UList (mkAnnList (separatedBy &quot;, &quot; list) exprs)</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>-- | Create a parallel array expression: @[: 1,2,3 :]@
<span class="lineno">   89 </span>mkParArray :: [Expr] -&gt; Expr
<span class="lineno">   90 </span><span class="decl"><span class="nottickedoff">mkParArray exprs = mkAnn (&quot;[: &quot; &lt;&gt; child &lt;&gt; &quot; :]&quot;) $ UParArray (mkAnnList (separatedBy &quot;, &quot; list) exprs)</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>-- | Create a parenthesized expression: @( a + b )@
<span class="lineno">   93 </span>mkParen :: Expr -&gt; Expr
<span class="lineno">   94 </span><span class="decl"><span class="istickedoff">mkParen = mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) . UParen</span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- | Create a left operator section: @(1+)@
<span class="lineno">   97 </span>mkLeftSection :: Expr -&gt; Operator -&gt; Expr
<span class="lineno">   98 </span><span class="decl"><span class="istickedoff">mkLeftSection lhs op = mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) $ ULeftSection lhs op</span></span>
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>-- | Create a right operator section: @(+1)@
<span class="lineno">  101 </span>mkRightSection :: Operator -&gt; Expr -&gt; Expr
<span class="lineno">  102 </span><span class="decl"><span class="istickedoff">mkRightSection op rhs = mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) $ URightSection op rhs</span></span>
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- | Create a record value construction: @Point { x = 3, y = -2 }@
<span class="lineno">  105 </span>mkRecCon :: Name -&gt; [FieldUpdate] -&gt; Expr
<span class="lineno">  106 </span><span class="decl"><span class="istickedoff">mkRecCon name flds = mkAnn (child &lt;&gt; &quot; { &quot; &lt;&gt; child &lt;&gt; &quot; }&quot;) $ URecCon name (mkAnnList (separatedBy <span class="nottickedoff">&quot;, &quot;</span> list) flds)</span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- | Create a record value  update: @p1 { x = 3, y = -2 }@
<span class="lineno">  109 </span>mkRecUpdate :: Expr -&gt; [FieldUpdate] -&gt; Expr
<span class="lineno">  110 </span><span class="decl"><span class="nottickedoff">mkRecUpdate expr flds = mkAnn (child &lt;&gt; &quot; { &quot; &lt;&gt; child &lt;&gt; &quot; }&quot;) $ URecUpdate expr (mkAnnList (separatedBy &quot;, &quot; list) flds)</span></span>
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- | Create a enumeration expression (@ [1,3..10] @)
<span class="lineno">  113 </span>mkEnum :: Expr -&gt; Maybe (Expr) -&gt; Maybe (Expr) -&gt; Expr
<span class="lineno">  114 </span><span class="decl"><span class="istickedoff">mkEnum from step to = mkAnn (&quot;[&quot; &lt;&gt; child &lt;&gt; child &lt;&gt; &quot;..&quot; &lt;&gt; child &lt;&gt; &quot;]&quot;) $ UEnum from (mkAnnMaybe (after <span class="nottickedoff">&quot;,&quot;</span> opt) step) (mkAnnMaybe (after <span class="nottickedoff">&quot;,&quot;</span> opt) to)</span></span>
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>-- | Create a parallel array enumeration (@ [: 1,3 .. 10 :] @)
<span class="lineno">  117 </span>mkParArrayEnum :: Expr -&gt; Maybe (Expr) -&gt; Expr -&gt; Expr
<span class="lineno">  118 </span><span class="decl"><span class="nottickedoff">mkParArrayEnum from step to</span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;[: &quot; &lt;&gt; child &lt;&gt; child &lt;&gt; &quot;..&quot; &lt;&gt; child &lt;&gt; &quot; :]&quot;)</span>
<span class="lineno">  120 </span><span class="spaces">      </span><span class="nottickedoff">$ UParArrayEnum from (mkAnnMaybe (after &quot;,&quot; opt) step) to</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>-- | Create a list comprehension (@ [ (x, y) | x &lt;- xs | y &lt;- ys ] @)
<span class="lineno">  123 </span>mkListComp :: Expr -&gt; [ListCompBody] -&gt; Expr
<span class="lineno">  124 </span><span class="decl"><span class="nottickedoff">mkListComp expr stmts</span>
<span class="lineno">  125 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;[ &quot; &lt;&gt; child &lt;&gt; &quot; | &quot; &lt;&gt; child &lt;&gt; &quot; ]&quot;)</span>
<span class="lineno">  126 </span><span class="spaces">      </span><span class="nottickedoff">$ UListComp expr $ mkAnnList (separatedBy &quot; | &quot; list) stmts</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- | Create a parallel array comprehensions @ [: (x, y) | x &lt;- xs , y &lt;- ys :] @ enabled by @ParallelArrays@
<span class="lineno">  129 </span>mkParArrayComp :: Expr -&gt; [ListCompBody] -&gt; Expr
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">mkParArrayComp expr stmts</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;[: &quot; &lt;&gt; child &lt;&gt; &quot; | &quot; &lt;&gt; child &lt;&gt; &quot; :]&quot;)</span>
<span class="lineno">  132 </span><span class="spaces">      </span><span class="nottickedoff">$ UParArrayComp expr $ mkAnnList (separatedBy &quot; | &quot; list) stmts</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- | Create a explicit type signature (@ x :: Int @)
<span class="lineno">  135 </span>mkExprTypeSig :: Expr -&gt; Type -&gt; Expr
<span class="lineno">  136 </span><span class="decl"><span class="nottickedoff">mkExprTypeSig lhs typ = mkAnn (child &lt;&gt; &quot; :: &quot; &lt;&gt; child) $ UTypeSig lhs typ</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | Create a explicit type application (@ show \@Integer (read &quot;5&quot;) @)
<span class="lineno">  139 </span>mkExplicitTypeApp :: Expr -&gt; Type -&gt; Expr
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">mkExplicitTypeApp expr typ = mkAnn (child &lt;&gt; &quot; @&quot; &lt;&gt; child) $ UExplTypeApp expr typ</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>-- | @'x@ for template haskell reifying of expressions
<span class="lineno">  143 </span>mkVarQuote :: Name -&gt; Expr
<span class="lineno">  144 </span><span class="decl"><span class="nottickedoff">mkVarQuote = mkAnn (&quot;'&quot; &lt;&gt; child) . UVarQuote</span></span>
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>-- | @''T@ for template haskell reifying of types
<span class="lineno">  147 </span>mkTypeQuote :: Name -&gt; Expr
<span class="lineno">  148 </span><span class="decl"><span class="nottickedoff">mkTypeQuote = mkAnn (&quot;''&quot; &lt;&gt; child) . UTypeQuote</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>-- | Create a template haskell bracket expression
<span class="lineno">  151 </span>mkBracketExpr :: Bracket -&gt; Expr
<span class="lineno">  152 </span><span class="decl"><span class="nottickedoff">mkBracketExpr = mkAnn child . UBracketExpr</span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>-- | Create a template haskell splice expression, for example: @$(gen a)@ or @$x@
<span class="lineno">  155 </span>mkSpliceExpr :: Splice -&gt; Expr
<span class="lineno">  156 </span><span class="decl"><span class="nottickedoff">mkSpliceExpr = mkAnn child . USplice</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- | Create a template haskell quasi quote expression, for example: @[quoter| a + b ]@
<span class="lineno">  159 </span>mkQuasiQuoteExpr :: QuasiQuote -&gt; Expr
<span class="lineno">  160 </span><span class="decl"><span class="nottickedoff">mkQuasiQuoteExpr = mkAnn child . UQuasiQuoteExpr</span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>-- | Creates a pragma that marks an expression.
<span class="lineno">  163 </span>mkExprPragma :: ExprPragma -&gt; Expr -&gt; Expr
<span class="lineno">  164 </span><span class="decl"><span class="nottickedoff">mkExprPragma pragma expr = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child) $ UExprPragma pragma expr</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | Create a arrow definition: @proc a -&gt; f -&lt; a+1@
<span class="lineno">  167 </span>mkProcExpr :: Pattern -&gt; Cmd -&gt; Expr
<span class="lineno">  168 </span><span class="decl"><span class="nottickedoff">mkProcExpr pat cmd = mkAnn (&quot;proc &quot; &lt;&gt; child &lt;&gt; &quot; -&gt; &quot; &lt;&gt; child) $ UProc pat cmd</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>-- | Create a arrow definition: @proc a -&gt; f -&lt; a+1@
<span class="lineno">  171 </span>mkArrowApp :: Expr -&gt; ArrowApp -&gt; Expr -&gt; Expr
<span class="lineno">  172 </span><span class="decl"><span class="nottickedoff">mkArrowApp lhs arrow rhs = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot; &quot; &lt;&gt; child) $ UArrowApp lhs arrow rhs</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- | Create a lambda case ( @\case 0 -&gt; 1; 1 -&gt; 2@ )
<span class="lineno">  175 </span>mkLambdaCase :: [Alt] -&gt; Expr
<span class="lineno">  176 </span><span class="decl"><span class="nottickedoff">mkLambdaCase = mkAnn (&quot;\\case&quot; &lt;&gt; child) . ULamCase . mkAnnList (indented list)</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Create a static pointer expression (@ static e @). The inner expression must be closed (cannot have variables bound outside)
<span class="lineno">  179 </span>mkStaticPointer :: Expr -&gt; Expr
<span class="lineno">  180 </span><span class="decl"><span class="nottickedoff">mkStaticPointer = mkAnn (&quot;static&quot; &lt;&gt; child) . UStaticPtr</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- * Field updates
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>-- | Create a update of a field (@ x = 1 @)
<span class="lineno">  187 </span>mkFieldUpdate :: Name -&gt; Expr -&gt; FieldUpdate
<span class="lineno">  188 </span><span class="decl"><span class="istickedoff">mkFieldUpdate name val = mkAnn (child &lt;&gt; &quot; = &quot; &lt;&gt; child) $ UNormalFieldUpdate name val</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | Create a update the field to the value of the same name (@ x @)
<span class="lineno">  191 </span>mkFieldPun :: Name -&gt; FieldUpdate
<span class="lineno">  192 </span><span class="decl"><span class="nottickedoff">mkFieldPun name = mkAnn child $ UFieldPun name</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>-- | Create a update the fields of the bounded names to their values (@ .. @). Must be the last initializer. Cannot be used in a record update expression.
<span class="lineno">  195 </span>mkFieldWildcard :: FieldUpdate
<span class="lineno">  196 </span><span class="decl"><span class="nottickedoff">mkFieldWildcard = mkAnn child $ UFieldWildcard $ mkAnn &quot;..&quot; FldWildcard</span></span>
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>-- * Pattern matching and guards
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>-- | Create a clause of case expression (@ Just x -&gt; x + 1 @)
<span class="lineno">  202 </span>mkAlt :: Pattern -&gt; CaseRhs -&gt; Maybe LocalBinds -&gt; Alt
<span class="lineno">  203 </span><span class="decl"><span class="istickedoff">mkAlt pat rhs locals = mkAnn (child &lt;&gt; child &lt;&gt; child) $ UAlt pat rhs (mkAnnMaybe (after <span class="nottickedoff">&quot; where &quot;</span> opt) locals)</span></span>
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>-- | Create a unguarded right-hand side a pattern match (@ -&gt; 3 @)
<span class="lineno">  206 </span>mkCaseRhs :: Expr -&gt; CaseRhs
<span class="lineno">  207 </span><span class="decl"><span class="istickedoff">mkCaseRhs = mkAnn (&quot; -&gt; &quot; &lt;&gt; child) . UUnguardedCaseRhs</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>-- | Create a guarded right-hand sides of a pattern match (@ | x == 1 -&gt; 3; | otherwise -&gt; 4 @)
<span class="lineno">  210 </span>mkGuardedCaseRhss :: [GuardedCaseRhs] -&gt; CaseRhs
<span class="lineno">  211 </span><span class="decl"><span class="istickedoff">mkGuardedCaseRhss = mkAnn child . UGuardedCaseRhss . mkAnnList (indented list)</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>-- | Creates a guarded right-hand side of pattern matches binding (@ | x &gt; 3 -&gt; 2 @)
<span class="lineno">  214 </span>mkGuardedCaseRhs :: [RhsGuard] -&gt; Expr -&gt; GuardedCaseRhs
<span class="lineno">  215 </span><span class="decl"><span class="istickedoff">mkGuardedCaseRhs guards expr = mkAnn (&quot; | &quot; &lt;&gt; child &lt;&gt; &quot; -&gt; &quot; &lt;&gt; child) $ UGuardedCaseRhs (mkAnnList (separatedBy <span class="nottickedoff">&quot;, &quot;</span> list) guards) expr</span></span>
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- * Pragmas that can be applied to expressions
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>-- | Creates a @CORE@ pragma for adding notes to expressions.
<span class="lineno">  220 </span>mkCorePragma :: String -&gt; ExprPragma
<span class="lineno">  221 </span><span class="decl"><span class="nottickedoff">mkCorePragma = mkAnn (&quot;{-# CORE &quot; &lt;&gt; child &lt;&gt; &quot; #-}&quot;) . UCorePragma</span>
<span class="lineno">  222 </span><span class="spaces">                 </span><span class="nottickedoff">. mkAnn (&quot;\&quot;&quot; &lt;&gt; child &lt;&gt; &quot;\&quot;&quot;) . UStringNode</span></span>
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | Creates an @SCC@ pragma for defining cost centers for profiling
<span class="lineno">  225 </span>mkSccPragma :: String -&gt; ExprPragma
<span class="lineno">  226 </span><span class="decl"><span class="nottickedoff">mkSccPragma = mkAnn (&quot;{-# SCC &quot; &lt;&gt; child &lt;&gt; &quot; #-}&quot;) . USccPragma</span>
<span class="lineno">  227 </span><span class="spaces">                </span><span class="nottickedoff">. mkAnn (&quot;\&quot;&quot; &lt;&gt; child &lt;&gt; &quot;\&quot;&quot;) . UStringNode</span></span>
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>-- | Creates a pragma that describes if an expression was generated from a code fragment by an external tool (@ {-\# GENERATED &quot;Happy.y&quot; 1:15-1:25 \#-} @)
<span class="lineno">  230 </span>mkGeneratedPragma :: SourceRange -&gt; ExprPragma
<span class="lineno">  231 </span><span class="decl"><span class="nottickedoff">mkGeneratedPragma = mkAnn (&quot;{-# GENERATED &quot; &lt;&gt; child &lt;&gt; &quot; #-}&quot;) . UGeneratedPragma</span></span>
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>-- | Create a in-AST source ranges (for generated pragmas)
<span class="lineno">  234 </span>mkSourceRange :: String -&gt; Integer -&gt; Integer -&gt; Integer -&gt; Integer -&gt; SourceRange
<span class="lineno">  235 </span><span class="decl"><span class="nottickedoff">mkSourceRange file fromLine fromCol toLine toCol</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot;:&quot; &lt;&gt; child &lt;&gt; &quot;-&quot; &lt;&gt; child &lt;&gt; &quot;:&quot; &lt;&gt; child)</span>
<span class="lineno">  237 </span><span class="spaces">      </span><span class="nottickedoff">$ USourceRange (mkAnn (&quot;\&quot;&quot; &lt;&gt; child &lt;&gt; &quot;\&quot;&quot;) $ UStringNode file)</span>
<span class="lineno">  238 </span><span class="spaces">          </span><span class="nottickedoff">(mkNumber fromLine) (mkNumber fromCol) (mkNumber toLine) (mkNumber toCol)</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="nottickedoff">where mkNumber = mkAnn child . Number</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>-- * Commands
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>-- | An arrow application command (@ f -&lt; x + 1 @)
<span class="lineno">  244 </span>mkArrowAppCmd :: Expr -&gt; ArrowApp -&gt; Expr -&gt; Cmd
<span class="lineno">  245 </span><span class="decl"><span class="nottickedoff">mkArrowAppCmd lhs arrow rhs</span>
<span class="lineno">  246 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot; &quot; &lt;&gt; child)</span>
<span class="lineno">  247 </span><span class="spaces">      </span><span class="nottickedoff">$ UArrowAppCmd lhs arrow rhs</span></span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>-- | A form command (@ (|untilA (increment -&lt; x+y) (within 0.5 -&lt; x)|) @)
<span class="lineno">  250 </span>mkArrowFromCmd :: Expr -&gt; [Cmd] -&gt; Cmd
<span class="lineno">  251 </span><span class="decl"><span class="nottickedoff">mkArrowFromCmd expr cmds</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;(| &quot; &lt;&gt; child &lt;&gt; child &lt;&gt; &quot; |)&quot;)</span>
<span class="lineno">  253 </span><span class="spaces">      </span><span class="nottickedoff">$ UArrowFormCmd expr $ mkAnnList (after &quot; &quot; $ separatedBy &quot; &quot; list) cmds</span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>-- | A function application command
<span class="lineno">  256 </span>mkAppCmd :: Cmd -&gt; Expr -&gt; Cmd
<span class="lineno">  257 </span><span class="decl"><span class="nottickedoff">mkAppCmd cmd expr = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child)</span>
<span class="lineno">  258 </span><span class="spaces">                      </span><span class="nottickedoff">$ UAppCmd cmd expr</span></span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>-- | An infix command application
<span class="lineno">  261 </span>mkInfixCmd :: Cmd -&gt; Name -&gt; Cmd -&gt; Cmd
<span class="lineno">  262 </span><span class="decl"><span class="nottickedoff">mkInfixCmd lhs op rhs = mkAnn (child &lt;&gt; &quot; &quot; &lt;&gt; child &lt;&gt; &quot; &quot; &lt;&gt; child)</span>
<span class="lineno">  263 </span><span class="spaces">                          </span><span class="nottickedoff">$ UInfixCmd lhs op rhs</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>-- | A lambda command
<span class="lineno">  266 </span>mkLambdaCmd :: [Pattern] -&gt; Cmd -&gt; Cmd
<span class="lineno">  267 </span><span class="decl"><span class="nottickedoff">mkLambdaCmd args cmd = mkAnn (&quot;\\&quot; &lt;&gt; child &lt;&gt; &quot; -&gt; &quot; &lt;&gt; child)</span>
<span class="lineno">  268 </span><span class="spaces">                         </span><span class="nottickedoff">$ ULambdaCmd (mkAnnList (separatedBy &quot; &quot; list) args) cmd</span></span>
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>-- | A parenthesized command
<span class="lineno">  271 </span>mkParenCmd :: Cmd -&gt; Cmd
<span class="lineno">  272 </span><span class="decl"><span class="nottickedoff">mkParenCmd cmd = mkAnn (&quot;(&quot; &lt;&gt; child &lt;&gt; &quot;)&quot;) $ UParenCmd cmd</span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>-- | A pattern match command
<span class="lineno">  275 </span>mkCaseCmd :: Expr -&gt; [CmdAlt] -&gt; Cmd
<span class="lineno">  276 </span><span class="decl"><span class="nottickedoff">mkCaseCmd expr alts</span>
<span class="lineno">  277 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;case &quot; &lt;&gt; child &lt;&gt; &quot; of &quot; &lt;&gt; child)</span>
<span class="lineno">  278 </span><span class="spaces">      </span><span class="nottickedoff">$ UCaseCmd expr $ mkAnnList (indented list) alts</span></span>
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>-- | An if command (@ if f x y then g -&lt; x+1 else h -&lt; y+2 @)
<span class="lineno">  281 </span>mkIfCmd :: Expr -&gt; Cmd -&gt; Cmd -&gt; Cmd
<span class="lineno">  282 </span><span class="decl"><span class="nottickedoff">mkIfCmd pred then_ else_</span>
<span class="lineno">  283 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;if &quot; &lt;&gt; child &lt;&gt; &quot; then &quot; &lt;&gt; child &lt;&gt; &quot; else &quot; &lt;&gt; child)</span>
<span class="lineno">  284 </span><span class="spaces">      </span><span class="nottickedoff">$ UIfCmd pred then_ else_</span></span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>-- | A local binding command (@ let z = x+y @)
<span class="lineno">  287 </span>mkLetCmd :: [LocalBind] -&gt; Cmd -&gt; Cmd
<span class="lineno">  288 </span><span class="decl"><span class="nottickedoff">mkLetCmd binds cmd</span>
<span class="lineno">  289 </span><span class="spaces">  </span><span class="nottickedoff">= mkAnn (&quot;let &quot; &lt;&gt; child &lt;&gt; &quot; in &quot; &lt;&gt; child)</span>
<span class="lineno">  290 </span><span class="spaces">      </span><span class="nottickedoff">$ ULetCmd (mkAnnList (indented list) binds) cmd</span></span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>-- | A do-notation in a command
<span class="lineno">  293 </span>mkDoCmd :: [CmdStmt] -&gt; Cmd
<span class="lineno">  294 </span><span class="decl"><span class="nottickedoff">mkDoCmd stmts = mkAnn (&quot;do &quot; &lt;&gt; child) $ UDoCmd (mkAnnList (indented list) stmts)</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Left arrow application: @-&lt;@
<span class="lineno">  297 </span>mkLeftAppl :: ArrowApp
<span class="lineno">  298 </span><span class="decl"><span class="nottickedoff">mkLeftAppl = mkAnn &quot;-&lt;&quot; ULeftAppl</span></span>
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- | Right arrow application: @&gt;-@
<span class="lineno">  301 </span>mkRightAppl :: ArrowApp
<span class="lineno">  302 </span><span class="decl"><span class="nottickedoff">mkRightAppl = mkAnn &quot;&gt;-&quot; URightAppl</span></span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>-- | Left arrow high application: @-&lt;&lt;@
<span class="lineno">  305 </span>mkLeftHighAppl :: ArrowApp
<span class="lineno">  306 </span><span class="decl"><span class="nottickedoff">mkLeftHighAppl = mkAnn &quot;-&lt;&lt;&quot; ULeftHighApp</span></span>
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>-- | Right arrow high application: @&gt;&gt;-@
<span class="lineno">  309 </span>mkRightHighAppl :: ArrowApp
<span class="lineno">  310 </span><span class="decl"><span class="nottickedoff">mkRightHighAppl = mkAnn &quot;&gt;&gt;-&quot; URightHighApp</span></span>
<span class="lineno">  311 </span>
<span class="lineno">  312 </span>-- | A hole expression @_@
<span class="lineno">  313 </span>mkHole :: Expr
<span class="lineno">  314 </span><span class="decl"><span class="nottickedoff">mkHole = mkAnn &quot;_&quot; UHole</span></span>

</pre>
</body>
</html>
