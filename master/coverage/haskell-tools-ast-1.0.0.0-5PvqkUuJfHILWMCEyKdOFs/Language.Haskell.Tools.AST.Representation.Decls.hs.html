<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- | Representation of Haskell AST definitions. These include definition of data types, classes, instances and so on.
<span class="lineno">    2 </span>-- The definition of value bindings are in the Binds module.
<span class="lineno">    3 </span>module Language.Haskell.Tools.AST.Representation.Decls where
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>import Language.Haskell.Tools.AST.Ann (Ann, AnnListG, AnnMaybeG)
<span class="lineno">    6 </span>import Language.Haskell.Tools.AST.Representation.Binds
<span class="lineno">    7 </span>import Language.Haskell.Tools.AST.Representation.Exprs (UExpr)
<span class="lineno">    8 </span>import Language.Haskell.Tools.AST.Representation.Kinds (UKindConstraint)
<span class="lineno">    9 </span>import Language.Haskell.Tools.AST.Representation.Names
<span class="lineno">   10 </span>import Language.Haskell.Tools.AST.Representation.Patterns (UPattern)
<span class="lineno">   11 </span>import {-# SOURCE #-} Language.Haskell.Tools.AST.Representation.TH (USplice)
<span class="lineno">   12 </span>import Language.Haskell.Tools.AST.Representation.Types (UContext, UType, UTyVar)
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>-- * Declarations
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>-- | Haskell declarationw
<span class="lineno">   17 </span>data UDecl dom stage
<span class="lineno">   18 </span>  = UTypeDecl             { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declHead</span></span></span> :: Ann UDeclHead dom stage
<span class="lineno">   19 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declType</span></span></span> :: Ann UType dom stage
<span class="lineno">   20 </span>                          } -- ^ A type synonym ( @type String = [Char]@ )
<span class="lineno">   21 </span>  | UTypeFamilyDecl       { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declTypeFamily</span></span></span> :: Ann UTypeFamily dom stage
<span class="lineno">   22 </span>                          } -- ^ A type family declaration ( @type family F x@ )
<span class="lineno">   23 </span>  | UClosedTypeFamilyDecl { _declHead :: Ann UDeclHead dom stage
<span class="lineno">   24 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declSpec</span></span></span> :: AnnMaybeG UTypeFamilySpec dom stage
<span class="lineno">   25 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declDecl</span></span></span> :: AnnListG UTypeEqn dom stage -- ^ cannot be empty
<span class="lineno">   26 </span>                          } -- ^ A closed type family declaration
<span class="lineno">   27 </span>  | UDataDecl             { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declNewtype</span></span></span> :: Ann UDataOrNewtypeKeyword dom stage
<span class="lineno">   28 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declCtx</span></span></span>  :: AnnMaybeG UContext dom stage
<span class="lineno">   29 </span>                          , _declHead :: Ann UDeclHead dom stage
<span class="lineno">   30 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declCons</span></span></span> :: AnnListG UConDecl dom stage
<span class="lineno">   31 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declDeriving</span></span></span> :: AnnListG UDeriving dom stage
<span class="lineno">   32 </span>                          } -- ^ A data or newtype declaration. Empty data type declarations without
<span class="lineno">   33 </span>                            -- where keyword are always belong to DataDecl.
<span class="lineno">   34 </span>  | UGDataDecl            { _declNewtype :: Ann UDataOrNewtypeKeyword dom stage
<span class="lineno">   35 </span>                          , _declCtx  :: AnnMaybeG UContext dom stage
<span class="lineno">   36 </span>                          , _declHead :: Ann UDeclHead dom stage
<span class="lineno">   37 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declKind</span></span></span> :: AnnMaybeG UKindConstraint dom stage
<span class="lineno">   38 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declGadt</span></span></span> :: AnnListG UGadtConDecl dom stage
<span class="lineno">   39 </span>                          , _declDeriving :: AnnListG UDeriving dom stage
<span class="lineno">   40 </span>                          } -- ^ A GADT-style data or newtype declaration.
<span class="lineno">   41 </span>  | UTypeInstDecl         { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declInstance</span></span></span> :: Ann UInstanceRule dom stage
<span class="lineno">   42 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declAssignedType</span></span></span> :: Ann UType dom stage
<span class="lineno">   43 </span>                          } -- ^ Type family instance declaration (@ type instance Fam T = AssignedT @)
<span class="lineno">   44 </span>  | UDataInstDecl         { _declNewtype :: Ann UDataOrNewtypeKeyword dom stage
<span class="lineno">   45 </span>                          , _declInstance :: Ann UInstanceRule dom stage
<span class="lineno">   46 </span>                          , _declCons :: AnnListG UConDecl dom stage
<span class="lineno">   47 </span>                          , _declDeriving :: AnnListG UDeriving dom stage
<span class="lineno">   48 </span>                          } -- ^ Data instance declaration (@ data instance Fam T = Con1 | Con2 @)
<span class="lineno">   49 </span>  | UGDataInstDecl        { _declNewtype :: Ann UDataOrNewtypeKeyword dom stage
<span class="lineno">   50 </span>                          , _declInstance :: Ann UInstanceRule dom stage
<span class="lineno">   51 </span>                          , _declKind :: AnnMaybeG UKindConstraint dom stage
<span class="lineno">   52 </span>                          , _declGadt :: AnnListG UGadtConDecl dom stage
<span class="lineno">   53 </span>                          } -- ^ GADT-style data instance declaration (@ data instance Fam T where ... @)
<span class="lineno">   54 </span>  | UClassDecl            { _declCtx :: AnnMaybeG UContext dom stage
<span class="lineno">   55 </span>                          , _declHead :: Ann UDeclHead dom stage
<span class="lineno">   56 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declFunDeps</span></span></span> :: AnnMaybeG UFunDeps dom stage
<span class="lineno">   57 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declBody</span></span></span> :: AnnMaybeG UClassBody dom stage
<span class="lineno">   58 </span>                          } -- ^ Type class declaration (@ class X a [where f = ...] @)
<span class="lineno">   59 </span>  | UInstDecl             { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declOverlap</span></span></span> :: AnnMaybeG UOverlapPragma dom stage
<span class="lineno">   60 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declInstRule</span></span></span> :: Ann UInstanceRule dom stage
<span class="lineno">   61 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declInstDecl</span></span></span> :: AnnMaybeG UInstBody dom stage
<span class="lineno">   62 </span>                          } -- ^ Instance declaration (@ instance X T [where f = ...] @)
<span class="lineno">   63 </span>  | UPatternSynonymDecl   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declPatSyn</span></span></span> :: Ann UPatternSynonym dom stage
<span class="lineno">   64 </span>                          } -- ^ Pattern synonyms (@ pattern Arrow t1 t2 = App &quot;-&gt;&quot; [t1, t2] @)
<span class="lineno">   65 </span>  | UDerivDecl            { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declDerivStrat</span></span></span> :: AnnMaybeG UDeriveStrategy dom stage
<span class="lineno">   66 </span>                          , _declOverlap :: AnnMaybeG UOverlapPragma dom stage
<span class="lineno">   67 </span>                          , _declInstRule :: Ann UInstanceRule dom stage
<span class="lineno">   68 </span>                          } -- ^ Standalone deriving declaration (@ deriving instance X T @)
<span class="lineno">   69 </span>  | UFixityDecl           { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declFixity</span></span></span> :: Ann UFixitySignature dom stage
<span class="lineno">   70 </span>                          } -- ^ Fixity declaration (@ infixl 5 +, - @)
<span class="lineno">   71 </span>  | UDefaultDecl          { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declTypes</span></span></span> :: AnnListG UType dom stage
<span class="lineno">   72 </span>                          } -- ^ Default types (@ default (T1, T2) @)
<span class="lineno">   73 </span>  | UTypeSigDecl          { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declTypeSig</span></span></span> :: Ann UTypeSignature dom stage
<span class="lineno">   74 </span>                          } -- ^ Type signature declaration (@ f :: Int -&gt; Int @)
<span class="lineno">   75 </span>  | UPatTypeSigDecl       { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declPatTypeSig</span></span></span> :: Ann UPatternTypeSignature dom stage
<span class="lineno">   76 </span>                          } -- ^ Pattern type signature declaration (@ pattern Succ :: Int -&gt; Int @)
<span class="lineno">   77 </span>  | UValueBinding         { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declValBind</span></span></span> :: Ann UValueBind dom stage
<span class="lineno">   78 </span>                          } -- ^ Function or value binding (@ f x = 12 @)
<span class="lineno">   79 </span>  | UForeignImport        { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declCallConv</span></span></span> :: Ann UCallConv dom stage
<span class="lineno">   80 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declSafety</span></span></span> :: AnnMaybeG USafety dom stage
<span class="lineno">   81 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declName</span></span></span> :: Ann UName dom stage
<span class="lineno">   82 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declForeignType</span></span></span> :: Ann UType dom stage
<span class="lineno">   83 </span>                          } -- ^ Foreign import (@ foreign import _foo :: Int -&gt; IO Int @)
<span class="lineno">   84 </span>  | UForeignExport        { _declCallConv :: Ann UCallConv dom stage
<span class="lineno">   85 </span>                          , _declName :: Ann UName dom stage
<span class="lineno">   86 </span>                          , _declForeignType :: Ann UType dom stage
<span class="lineno">   87 </span>                          } -- ^ Foreign export (@ foreign export ccall _foo :: Int -&gt; IO Int @)
<span class="lineno">   88 </span>  | UPragmaDecl           { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declPragma</span></span></span> :: Ann UTopLevelPragma dom stage
<span class="lineno">   89 </span>                          } -- ^ Top-level pragmas
<span class="lineno">   90 </span>  | URoleDecl             { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declRoleType</span></span></span> :: Ann UQualifiedName dom stage
<span class="lineno">   91 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declRoles</span></span></span> :: AnnListG URole dom stage
<span class="lineno">   92 </span>                          } -- ^ Role annotations (@ type role Ptr representational @)
<span class="lineno">   93 </span>  | USpliceDecl           { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_declSplice</span></span></span> :: Ann USplice dom stage
<span class="lineno">   94 </span>                          } -- ^ A Template Haskell splice declaration (@ $(generateDecls) @)
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- The declared (possibly parameterized) type (@ A x :+: B y @).
<span class="lineno">   97 </span>data UDeclHead dom stage
<span class="lineno">   98 </span>  = UDeclHead { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhName</span></span></span> :: Ann UName dom stage
<span class="lineno">   99 </span>              } -- ^ Type or class name
<span class="lineno">  100 </span>  | UDHParen  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhBody</span></span></span> :: Ann UDeclHead dom stage
<span class="lineno">  101 </span>              } -- ^ Parenthesized type
<span class="lineno">  102 </span>  | UDHApp    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhAppFun</span></span></span> :: Ann UDeclHead dom stage
<span class="lineno">  103 </span>              , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhAppOperand</span></span></span> :: Ann UTyVar dom stage
<span class="lineno">  104 </span>              } -- ^ Type application
<span class="lineno">  105 </span>  | UDHInfix  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhLeft</span></span></span> :: Ann UTyVar dom stage
<span class="lineno">  106 </span>              , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhOperator</span></span></span> :: Ann UOperator dom stage
<span class="lineno">  107 </span>              , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_dhRight</span></span></span> :: Ann UTyVar dom stage
<span class="lineno">  108 </span>              } -- ^ Infix application of the type/class name to the left operand
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>-- * Type class definitions
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- | The list of declarations that can appear in a typeclass
<span class="lineno">  113 </span>data UClassBody dom stage
<span class="lineno">  114 </span>  = UClassBody { <span class="istickedoff"><span class="decl"><span class="istickedoff">_cbElements</span></span></span> :: AnnListG UClassElement dom stage
<span class="lineno">  115 </span>               }
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- | Members of a class declaration
<span class="lineno">  118 </span>data UClassElement dom stage
<span class="lineno">  119 </span>  = UClsSig     { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceTypeSig</span></span></span> :: Ann UTypeSignature dom stage
<span class="lineno">  120 </span>                } -- ^ Signature: @ f :: A -&gt; B @
<span class="lineno">  121 </span>  | UClsFixity  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_clsFixity</span></span></span> :: Ann UFixitySignature dom stage
<span class="lineno">  122 </span>                } -- ^ Fixity signature in class: @ infixl 1 &gt;&gt;- @
<span class="lineno">  123 </span>  | UClsDef     { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceBind</span></span></span> :: Ann UValueBind dom stage
<span class="lineno">  124 </span>                } -- ^ Default binding: @ f x = &quot;aaa&quot; @
<span class="lineno">  125 </span>  | UClsTypeFam { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceTypeFam</span></span></span> :: Ann UTypeFamily dom stage
<span class="lineno">  126 </span>                } -- ^ Declaration of an associated type synonym: @ type T x :: * @
<span class="lineno">  127 </span>  | UClsTypeDef { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceHead</span></span></span> :: Ann UDeclHead dom stage
<span class="lineno">  128 </span>                , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceKind</span></span></span> :: Ann UType dom stage
<span class="lineno">  129 </span>                } -- ^ Default choice for type synonym: @ type T x = TE @ or @ type instance T x = TE @
<span class="lineno">  130 </span>  | UClsDefSig  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceName</span></span></span> :: Ann UName dom stage
<span class="lineno">  131 </span>                , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ceType</span></span></span> :: Ann UType dom stage
<span class="lineno">  132 </span>                } -- ^ Default signature (by using @DefaultSignatures@): @ default _enum :: (Generic a, GEnum (Rep a)) =&gt; [a] @
<span class="lineno">  133 </span>  | UClsMinimal { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaFormula</span></span></span> :: Ann UMinimalFormula dom stage
<span class="lineno">  134 </span>                } -- ^ Minimal pragma: @ {-# MINIMAL (==) | (/=) #-} @
<span class="lineno">  135 </span>  | UClsInline  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_clsInline</span></span></span> :: Ann UInlinePragma dom stage
<span class="lineno">  136 </span>                } -- ^ Inline-like pragma in class definition
<span class="lineno">  137 </span>  -- not supported yet (GHC 8.0.1)
<span class="lineno">  138 </span>-- | UClsPatSig  { _cePatSig :: Ann UPatternTypeSignature dom stage
<span class="lineno">  139 </span>  --               } -- ^ Pattern signature in a class declaration (by using @PatternSynonyms@)
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- * Type class instances
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- | The instance declaration rule, which is, roughly, the part of the instance declaration before the where keyword.
<span class="lineno">  144 </span>data UInstanceRule dom stage
<span class="lineno">  145 </span>  = UInstanceRule  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_irVars</span></span></span> :: AnnMaybeG (AnnListG UTyVar) dom stage
<span class="lineno">  146 </span>                   , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_irCtx</span></span></span> :: AnnMaybeG UContext dom stage
<span class="lineno">  147 </span>                   , <span class="istickedoff"><span class="decl"><span class="istickedoff">_irHead</span></span></span> :: Ann UInstanceHead dom stage
<span class="lineno">  148 </span>                   } -- ^ Instance head as an instance rule (@ X a =&gt; Y a @)
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>-- | The specification of the class instance declaration
<span class="lineno">  151 </span>data UInstanceHead dom stage
<span class="lineno">  152 </span>  = UInstanceHeadCon   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ihConName</span></span></span> :: Ann UName dom stage
<span class="lineno">  153 </span>                       } -- ^ Type or class name
<span class="lineno">  154 </span>  | UInstanceHeadInfix { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ihLeftOp</span></span></span> :: Ann UType dom stage
<span class="lineno">  155 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ihOperator</span></span></span> :: Ann UOperator dom stage
<span class="lineno">  156 </span>                       } -- ^ Infix application of the type/class name to the left operand
<span class="lineno">  157 </span>  | UInstanceHeadParen { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ihHead</span></span></span> :: Ann UInstanceHead dom stage
<span class="lineno">  158 </span>                       } -- ^ Parenthesized instance head
<span class="lineno">  159 </span>  | UInstanceHeadApp   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ihFun</span></span></span> :: Ann UInstanceHead dom stage
<span class="lineno">  160 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ihType</span></span></span> :: Ann UType dom stage
<span class="lineno">  161 </span>                       } -- ^ Application to one more type
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>-- | Instance body is the implementation of the class functions (@ where a x = 1; b x = 2 @)
<span class="lineno">  164 </span>data UInstBody dom stage
<span class="lineno">  165 </span>  = UInstBody { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyDecls</span></span></span> :: AnnListG UInstBodyDecl dom stage
<span class="lineno">  166 </span>              }
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- | Declarations inside an instance declaration.
<span class="lineno">  169 </span>data UInstBodyDecl dom stage
<span class="lineno">  170 </span>  = UInstBodyNormalDecl   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyDeclFunbind</span></span></span> :: Ann UValueBind dom stage
<span class="lineno">  171 </span>                          } -- ^ A normal value binding (@ f x = 12 @)
<span class="lineno">  172 </span>  | UInstBodyTypeSig      { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyTypeSig</span></span></span> :: Ann UTypeSignature dom stage
<span class="lineno">  173 </span>                          } -- ^ Type signature in instance definition with @InstanceSigs@
<span class="lineno">  174 </span>  | UInstBodyTypeDecl     { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyTypeEqn</span></span></span> :: Ann UTypeEqn dom stage
<span class="lineno">  175 </span>                          } -- ^ An associated type definition (@ type A X = B @)
<span class="lineno">  176 </span>  | UInstBodyDataDecl     { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyDataNew</span></span></span> :: Ann UDataOrNewtypeKeyword dom stage
<span class="lineno">  177 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyLhsType</span></span></span> :: Ann UInstanceRule dom stage
<span class="lineno">  178 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyDataCons</span></span></span> :: AnnListG UConDecl dom stage
<span class="lineno">  179 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyDerivings</span></span></span> :: AnnListG UDeriving dom stage
<span class="lineno">  180 </span>                          } -- ^ An associated data type implementation (@ data A X = C1 | C2 @)
<span class="lineno">  181 </span>  | UInstBodyGadtDataDecl { _instBodyDataNew :: Ann UDataOrNewtypeKeyword dom stage
<span class="lineno">  182 </span>                          , _instBodyLhsType :: Ann UInstanceRule dom stage
<span class="lineno">  183 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyDataKind</span></span></span> :: AnnMaybeG UKindConstraint dom stage
<span class="lineno">  184 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instBodyGadtCons</span></span></span> :: AnnListG UGadtConDecl dom stage
<span class="lineno">  185 </span>                          , _instBodyDerivings :: AnnListG UDeriving dom stage
<span class="lineno">  186 </span>                          } -- ^ An associated data type implemented using GADT style
<span class="lineno">  187 </span>  | USpecializeInstance   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_specializeInstanceType</span></span></span> :: Ann UType dom stage
<span class="lineno">  188 </span>                          } -- ^ Specialize instance pragma (no phase selection is allowed)
<span class="lineno">  189 </span>  | UInlineInstance       { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_instanceInline</span></span></span> :: Ann UInlinePragma dom stage
<span class="lineno">  190 </span>                          } -- ^ Inline-like pragma in a class instance
<span class="lineno">  191 </span>  | UInstanceSpecialize   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_specializeInstance</span></span></span> :: Ann USpecializePragma dom stage
<span class="lineno">  192 </span>                          } -- ^ Specialize pragma
<span class="lineno">  193 </span>  -- not supported yet
<span class="lineno">  194 </span>-- | UInstBodyPatSyn       { _instBodyPatSyn :: Ann UPatternSynonym dom stage
<span class="lineno">  195 </span>  --                         } -- ^ A pattern synonym in a class instance
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>-- | Overlap pragmas. Can be applied to class declarations and class instance declarations.
<span class="lineno">  198 </span>data UOverlapPragma dom stage
<span class="lineno">  199 </span>  = UEnableOverlap     -- ^ @OVERLAP@ pragma
<span class="lineno">  200 </span>  | UDisableOverlap    -- ^ @NO_OVERLAP@ pragma
<span class="lineno">  201 </span>  | UOverlappable      -- ^ @OVERLAPPABLE@ pragma
<span class="lineno">  202 </span>  | UOverlapping       -- ^ @OVERLAPPING@ pragma
<span class="lineno">  203 </span>  | UOverlaps          -- ^ @OVERLAPS@ pragma
<span class="lineno">  204 </span>  | UIncoherentOverlap -- ^ @INCOHERENT@ pragma
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>-- * Type families
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | Open type and data families
<span class="lineno">  209 </span>data UTypeFamily dom stage
<span class="lineno">  210 </span>  = UTypeFamily { <span class="istickedoff"><span class="decl"><span class="istickedoff">_tfHead</span></span></span> :: Ann UDeclHead dom stage
<span class="lineno">  211 </span>                , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_tfSpec</span></span></span> :: AnnMaybeG UTypeFamilySpec dom stage
<span class="lineno">  212 </span>                } -- ^ Type family declaration (@ type family A a :: * -&gt; * @)
<span class="lineno">  213 </span>  | UDataFamily { _tfHead :: Ann UDeclHead dom stage
<span class="lineno">  214 </span>                , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_tfKind</span></span></span> :: AnnMaybeG UKindConstraint dom stage
<span class="lineno">  215 </span>                } -- ^ Data family declaration (@ data family A a :: * -&gt; * @)
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- | Type family specification with kinds specification and injectivity.
<span class="lineno">  218 </span>data UTypeFamilySpec dom stage
<span class="lineno">  219 </span>  = UTypeFamilyKind { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_tfSpecKind</span></span></span> :: Ann UKindConstraint dom stage
<span class="lineno">  220 </span>                    } -- ^ Specifies the kind of a type family (@ :: * -&gt; * @)
<span class="lineno">  221 </span>  | UTypeFamilyTyVar { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_tfTypeVar</span></span></span> :: Ann UTyVar dom stage
<span class="lineno">  222 </span>                     } -- ^ Specifies the kind of a type family (@ = t :: * -&gt; * @)
<span class="lineno">  223 </span>  | UTypeFamilyInjectivity { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_tfInjectivity</span></span></span> :: Ann UInjectivityAnn dom stage
<span class="lineno">  224 </span>                           } -- ^ Specifies the injectivity of a type family (@ = r | r -&gt; a @)
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>-- | Injectivity annotation for type families (@ = r | r -&gt; a @)
<span class="lineno">  227 </span>data UInjectivityAnn dom stage
<span class="lineno">  228 </span>  = UInjectivityAnn { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_injAnnRes</span></span></span> :: Ann UTyVar dom stage
<span class="lineno">  229 </span>                    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_injAnnDeps</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  230 </span>                    }
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>-- | Type equations as found in closed type families (@ T A = S @)
<span class="lineno">  233 </span>data UTypeEqn dom stage
<span class="lineno">  234 </span>  = UTypeEqn { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_teLhs</span></span></span> :: Ann UType dom stage
<span class="lineno">  235 </span>             , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_teRhs</span></span></span> :: Ann UType dom stage
<span class="lineno">  236 </span>             }
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>-- * Type definitions
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>-- | GADT constructor declaration (@ D1 :: { val :: Int } -&gt; T String @)
<span class="lineno">  241 </span>data UGadtConDecl dom stage
<span class="lineno">  242 </span>  = UGadtConDecl { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_gadtConNames</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  243 </span>                 , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_gadtConTypeArgs</span></span></span> :: AnnListG UTyVar dom stage
<span class="lineno">  244 </span>                 , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_gadtConTypeCtx</span></span></span> :: AnnMaybeG UContext dom stage
<span class="lineno">  245 </span>                 , <span class="istickedoff"><span class="decl"><span class="istickedoff">_gadtConType</span></span></span> :: Ann UGadtConType dom stage
<span class="lineno">  246 </span>                 }
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>-- | The @data@ or the @newtype@ keyword to define ADTs.
<span class="lineno">  249 </span>data UDataOrNewtypeKeyword dom stage
<span class="lineno">  250 </span>  = UDataKeyword
<span class="lineno">  251 </span>  | UNewtypeKeyword
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>-- | Type of GADT constructors (can be record types: @{ val :: Int }@)
<span class="lineno">  254 </span>data UGadtConType dom stage
<span class="lineno">  255 </span>  = UGadtNormalType { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_gadtConNormalType</span></span></span> :: Ann UType dom stage
<span class="lineno">  256 </span>                    }
<span class="lineno">  257 </span>  | UGadtRecordType { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_gadtConRecordFields</span></span></span> :: AnnListG UFieldDecl dom stage
<span class="lineno">  258 </span>                    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_gadtConResultType</span></span></span> :: Ann UType dom stage
<span class="lineno">  259 </span>                    }
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>-- | A list of functional dependencies: @ | a -&gt; b, c -&gt; d @ separated by commas
<span class="lineno">  262 </span>data UFunDeps dom stage
<span class="lineno">  263 </span>  = UFunDeps { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_funDeps</span></span></span> :: AnnListG UFunDep dom stage
<span class="lineno">  264 </span>             }
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>-- | A functional dependency, given on the form @l1 ... ln -&gt; r1 ... rn@
<span class="lineno">  267 </span>data UFunDep dom stage
<span class="lineno">  268 </span>  = UFunDep { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_funDepLhs</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  269 </span>            , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_funDepRhs</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  270 </span>            }
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>-- | A constructor declaration for a datatype
<span class="lineno">  273 </span>data UConDecl dom stage
<span class="lineno">  274 </span>  = UConDecl      { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conTypeArgs</span></span></span> :: AnnListG UTyVar dom stage
<span class="lineno">  275 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conTypeCtx</span></span></span> :: AnnMaybeG UContext dom stage
<span class="lineno">  276 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conDeclName</span></span></span> :: Ann UName dom stage
<span class="lineno">  277 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conDeclArgs</span></span></span> :: AnnListG UType dom stage
<span class="lineno">  278 </span>                  } -- ^ Ordinary data constructor (@ C t1 t2 @)
<span class="lineno">  279 </span>  | URecordDecl   { _conTypeArgs :: AnnListG UTyVar dom stage
<span class="lineno">  280 </span>                  , _conTypeCtx :: AnnMaybeG UContext dom stage
<span class="lineno">  281 </span>                  , _conDeclName :: Ann UName dom stage
<span class="lineno">  282 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conDeclFields</span></span></span> :: AnnListG UFieldDecl dom stage
<span class="lineno">  283 </span>                  } -- ^ Record data constructor (@ C { _n1 :: t1, _n2 :: t2 } @)
<span class="lineno">  284 </span>  | UInfixConDecl { _conTypeArgs :: AnnListG UTyVar dom stage
<span class="lineno">  285 </span>                  , _conTypeCtx :: AnnMaybeG UContext dom stage
<span class="lineno">  286 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conDeclLhs</span></span></span> :: Ann UType dom stage
<span class="lineno">  287 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conDeclOp</span></span></span> :: Ann UOperator dom stage
<span class="lineno">  288 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_conDeclRhs</span></span></span> :: Ann UType dom stage
<span class="lineno">  289 </span>                  } -- ^ Infix data constructor (@ t1 :+: t2 @)
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>-- | Field declaration (@ fld :: Int @)
<span class="lineno">  292 </span>data UFieldDecl dom stage
<span class="lineno">  293 </span>  = UFieldDecl { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fieldNames</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  294 </span>               , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fieldType</span></span></span> :: Ann UType dom stage
<span class="lineno">  295 </span>               }
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>-- | A deriving clause following a data type declaration. (@ deriving Show @ or @ deriving (Show, Eq) @)
<span class="lineno">  298 </span>data UDeriving dom stage
<span class="lineno">  299 </span>  = UDerivingOne { <span class="istickedoff"><span class="decl"><span class="istickedoff">_deriveStrategy</span></span></span> :: AnnMaybeG UDeriveStrategy dom stage
<span class="lineno">  300 </span>                 , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_oneDerived</span></span></span> :: Ann UInstanceHead dom stage
<span class="lineno">  301 </span>                 }
<span class="lineno">  302 </span>  | UDerivings { _deriveStrategy :: AnnMaybeG UDeriveStrategy dom stage
<span class="lineno">  303 </span>               , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allDerived</span></span></span> :: AnnListG UInstanceHead dom stage
<span class="lineno">  304 </span>               }
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>data UDeriveStrategy dom stage
<span class="lineno">  307 </span>  = UStockStrategy
<span class="lineno">  308 </span>  | UAnyClassStrategy
<span class="lineno">  309 </span>  | UNewtypeStrategy
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>-- * Pattern synonyms
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>-- | Pattern type signature declaration (@ pattern Succ :: Int -&gt; Int @)
<span class="lineno">  314 </span>data UPatternTypeSignature dom stage
<span class="lineno">  315 </span>  = UPatternTypeSignature { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patSigName</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  316 </span>                          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patSigType</span></span></span> :: Ann UType dom stage
<span class="lineno">  317 </span>                          }
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>-- | Pattern synonyms: @ pattern Arrow t1 t2 = App &quot;-&gt;&quot; [t1, t2] @
<span class="lineno">  320 </span>data UPatternSynonym dom stage
<span class="lineno">  321 </span>  = UPatternSynonym { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patLhs</span></span></span> :: Ann UPatSynLhs dom stage
<span class="lineno">  322 </span>                    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patRhs</span></span></span> :: Ann UPatSynRhs dom stage
<span class="lineno">  323 </span>                    }
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>-- | Left hand side of a pattern synonym
<span class="lineno">  326 </span>data UPatSynLhs dom stage
<span class="lineno">  327 </span>  = UNormalPatSyn { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patName</span></span></span> :: Ann UName dom stage
<span class="lineno">  328 </span>                  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patArgs</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  329 </span>                  } -- ^ A left hand side with a constructor name and arguments (@ Arrow t1 t2 @)
<span class="lineno">  330 </span>  | UInfixPatSyn { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patSynLhs</span></span></span> :: Ann UName dom stage
<span class="lineno">  331 </span>                 , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patSynOp</span></span></span> :: Ann UOperator dom stage
<span class="lineno">  332 </span>                 , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patSynRhs</span></span></span> :: Ann UName dom stage
<span class="lineno">  333 </span>                 } -- ^ An infix pattern synonym left-hand side (@ t1 :+: t2 @)
<span class="lineno">  334 </span>  | URecordPatSyn { _patName :: Ann UName dom stage
<span class="lineno">  335 </span>                  , _patArgs :: AnnListG UName dom stage
<span class="lineno">  336 </span>                  } -- ^ A record-style pattern synonym left-hand side (@ Arrow { arrowFrom, arrowTo } @)
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>-- | Right-hand side of pattern synonym
<span class="lineno">  339 </span>data UPatSynRhs dom stage
<span class="lineno">  340 </span>  -- TODO: this feels bad, changing _patRhsOpposite may switch between &lt;- and =
<span class="lineno">  341 </span>  = UBidirectionalPatSyn { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patRhsPat</span></span></span> :: Ann UPattern dom stage
<span class="lineno">  342 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patRhsOpposite</span></span></span> :: AnnMaybeG UPatSynWhere dom stage
<span class="lineno">  343 </span>                         } -- ^ @ pattern Int = App &quot;Int&quot; [] @ or @ pattern Int &lt;- App &quot;Int&quot; [] where Int = App &quot;Int&quot; [] @
<span class="lineno">  344 </span>  | UOneDirectionalPatSyn { _patRhsPat :: Ann UPattern dom stage
<span class="lineno">  345 </span>                          } -- ^ @ pattern Int &lt;- App &quot;Int&quot; [] @
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>-- | Where clause of pattern synonym (explicit expression direction)
<span class="lineno">  348 </span>data UPatSynWhere dom stage
<span class="lineno">  349 </span>  = UPatSynWhere { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_patOpposite</span></span></span> :: AnnListG UMatch dom stage }
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>-- * Foreign imports
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>-- | Call conventions of foreign functions
<span class="lineno">  354 </span>data UCallConv dom stage
<span class="lineno">  355 </span>  = UStdCall
<span class="lineno">  356 </span>  | UCCall
<span class="lineno">  357 </span>  | UCPlusPlus
<span class="lineno">  358 </span>  | UDotNet
<span class="lineno">  359 </span>  | UJvm
<span class="lineno">  360 </span>  | UJs
<span class="lineno">  361 </span>  | UJavaScript
<span class="lineno">  362 </span>  | UCApi
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>-- | Safety annotations for foreign calls
<span class="lineno">  365 </span>data USafety dom stage
<span class="lineno">  366 </span>  = USafe
<span class="lineno">  367 </span>  | UThreadSafe
<span class="lineno">  368 </span>  | UUnsafe
<span class="lineno">  369 </span>  | UInterruptible
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>-- * Role annotations
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | Role annotations for types
<span class="lineno">  374 </span>data URole dom stage
<span class="lineno">  375 </span>  = UNominal
<span class="lineno">  376 </span>  | URepresentational
<span class="lineno">  377 </span>  | UPhantom
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>-- * Pragmas
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>-- | Top level pragmas
<span class="lineno">  382 </span>data UTopLevelPragma dom stage
<span class="lineno">  383 </span>  = URulePragma       { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaRule</span></span></span> :: AnnListG URule dom stage
<span class="lineno">  384 </span>                      } -- ^ A pragma that introduces source rewrite rules (@ {-# RULES &quot;map/map&quot; [2]  forall f g xs. map f (map g xs) = map (f.g) xs #-} @)
<span class="lineno">  385 </span>  | UDeprPragma       { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaObjects</span></span></span> :: AnnListG UName dom stage
<span class="lineno">  386 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_deprMessage</span></span></span> :: AnnListG UStringNode dom stage
<span class="lineno">  387 </span>                      } -- ^ A pragma that marks definitions as deprecated (@ {-# DEPRECATED f &quot;f will be replaced by g&quot; @)
<span class="lineno">  388 </span>  | UWarningPragma    { _pragmaObjects :: AnnListG UName dom stage
<span class="lineno">  389 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_warnMessage</span></span></span> :: AnnListG UStringNode dom stage
<span class="lineno">  390 </span>                      } -- ^ A pragma that marks definitions as deprecated (@ {-# WARNING unsafePerformIO &quot;you should know what you are doing&quot; @)
<span class="lineno">  391 </span>  | UAnnPragma        { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_annotationSubject</span></span></span> :: Ann UAnnotationSubject dom stage
<span class="lineno">  392 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_annotateExpr</span></span></span> :: Ann UExpr dom stage
<span class="lineno">  393 </span>                      } -- ^ A pragma that annotates a definition with an arbitrary value (@ {-# ANN f 42 @)
<span class="lineno">  394 </span>  -- TODO: extract pragmas that appear both in top-level and in instances (inline, inlinable, noinline)
<span class="lineno">  395 </span>  | UInlinePragmaDecl { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaInline</span></span></span> :: Ann UInlinePragma dom stage }
<span class="lineno">  396 </span>  | ULinePragma       { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaLineNum</span></span></span> :: Ann LineNumber dom stage
<span class="lineno">  397 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaFileName</span></span></span> :: AnnMaybeG UStringNode dom stage
<span class="lineno">  398 </span>                      } -- ^ A pragma for maintaining line numbers in generated sources (@ {-# LINE 123 &quot;somefile&quot; #-} @)
<span class="lineno">  399 </span>  | USpecializeDecl   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_specializePragma</span></span></span> :: Ann USpecializePragma dom stage }
<span class="lineno">  400 </span>  | UCompletePragma   { _pragmaObjects :: AnnListG UName dom stage
<span class="lineno">  401 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaSignature</span></span></span> :: AnnMaybeG UName dom stage
<span class="lineno">  402 </span>                      } -- ^ The COMPLETE pragma is used to inform the pattern match checker that a certain set of patterns is complete (@ {-# COMPLETE T :: [] #-} @).
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>data USpecializePragma dom stage
<span class="lineno">  405 </span>  = USpecializePragma { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_pragmaPhase</span></span></span> :: AnnMaybeG UPhaseControl dom stage
<span class="lineno">  406 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_specializeDef</span></span></span> :: Ann UName dom stage
<span class="lineno">  407 </span>                      , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_specializeType</span></span></span> :: AnnListG UType dom stage
<span class="lineno">  408 </span>                      } -- ^ A pragma that tells the compiler that a polymorph function should be optimized for a given type (@ {-# SPECIALISE f :: Int -&gt; b -&gt; b #-} @)
<span class="lineno">  409 </span>
<span class="lineno">  410 </span>-- | A rewrite rule (@ &quot;map/map&quot; forall f g xs. map f (map g xs) = map (f.g) xs @)
<span class="lineno">  411 </span>data URule dom stage
<span class="lineno">  412 </span>  = URule { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ruleName</span></span></span> :: Ann UStringNode dom stage -- ^ User name of the rule
<span class="lineno">  413 </span>          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_rulePhase</span></span></span> :: AnnMaybeG UPhaseControl dom stage -- ^ The compilation phases in which the rule can be applied
<span class="lineno">  414 </span>          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ruleBounded</span></span></span> :: AnnListG URuleVar dom stage -- ^ Variables bound in the rule
<span class="lineno">  415 </span>          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ruleLhs</span></span></span> :: Ann UExpr dom stage -- ^ The transformed expression
<span class="lineno">  416 </span>          , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ruleRhs</span></span></span> :: Ann UExpr dom stage -- ^ The resulting expression
<span class="lineno">  417 </span>          }
<span class="lineno">  418 </span>
<span class="lineno">  419 </span>-- | A variable for a rewrite rule. With or without type signature.
<span class="lineno">  420 </span>data URuleVar dom stage
<span class="lineno">  421 </span>  = URuleVar { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ruleVarName</span></span></span> :: Ann UName dom stage
<span class="lineno">  422 </span>             } -- ^ A simple rule variable
<span class="lineno">  423 </span>  | USigRuleVar { _ruleVarName :: Ann UName dom stage
<span class="lineno">  424 </span>                , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ruleVarType</span></span></span> :: Ann UType dom stage
<span class="lineno">  425 </span>                } -- ^ A rule variable with signature
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>-- | Annotation allows you to connect an expression to any declaration.
<span class="lineno">  428 </span>data UAnnotationSubject dom stage
<span class="lineno">  429 </span>  = UNameAnnotation { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_annotateName</span></span></span> :: Ann UName dom stage
<span class="lineno">  430 </span>                    } -- ^ The definition with the given name is annotated
<span class="lineno">  431 </span>  | UTypeAnnotation { _annotateName :: Ann UName dom stage
<span class="lineno">  432 </span>                    } -- ^ A type with the given name is annotated
<span class="lineno">  433 </span>  | UModuleAnnotation -- ^ The whole module is annotated
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>-- | Formulas of minimal annotations declaring which functions should be defined.
<span class="lineno">  436 </span>data UMinimalFormula dom stage
<span class="lineno">  437 </span>  = UMinimalName  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_minimalName</span></span></span> :: Ann UName dom stage
<span class="lineno">  438 </span>                  }
<span class="lineno">  439 </span>  | UMinimalParen { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_minimalInner</span></span></span> :: Ann UMinimalFormula dom stage
<span class="lineno">  440 </span>                  }
<span class="lineno">  441 </span>  | UMinimalOr    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_minimalOrs</span></span></span> :: AnnListG UMinimalFormula dom stage
<span class="lineno">  442 </span>                  } -- ^ One of the minimal formulas are needed (@ min1 | min2 @)
<span class="lineno">  443 </span>  | UMinimalAnd   { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_minimalAnds</span></span></span> :: AnnListG UMinimalFormula dom stage
<span class="lineno">  444 </span>                  } -- ^ Both of the minimal formulas are needed (@ min1 , min2 @)
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>-- | A line number for a line pragma.
<span class="lineno">  447 </span>data LineNumber dom stage
<span class="lineno">  448 </span>  = LineNumber { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lineNumber</span></span></span> :: Int }

</pre>
</body>
</html>
