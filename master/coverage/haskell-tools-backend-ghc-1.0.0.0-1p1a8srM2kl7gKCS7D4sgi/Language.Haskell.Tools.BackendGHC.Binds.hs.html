<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE LambdaCase, ViewPatterns #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>-- | Functions that convert the value and function definitions of the GHC AST to corresponding elements in the Haskell-tools AST representation
<span class="lineno">    4 </span>module Language.Haskell.Tools.BackendGHC.Binds where
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>import ApiAnnotation as GHC (AnnKeywordId(..))
<span class="lineno">    7 </span>import Bag as GHC (bagToList)
<span class="lineno">    8 </span>import BasicTypes as GHC
<span class="lineno">    9 </span>import HsBinds as GHC
<span class="lineno">   10 </span>import HsExpr as GHC
<span class="lineno">   11 </span>import HsPat as GHC (LPat)
<span class="lineno">   12 </span>import HsTypes as GHC (SrcStrictness(..), HsWildCardBndrs(..), HsImplicitBndrs(..))
<span class="lineno">   13 </span>import Name as GHC (isSymOcc)
<span class="lineno">   14 </span>import PlaceHolder as GHC (NameOrRdrName)
<span class="lineno">   15 </span>import SrcLoc as GHC
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>import Control.Monad.Reader (Monad(..), mapM, asks)
<span class="lineno">   18 </span>import Data.List
<span class="lineno">   19 </span>import Data.Function (on)
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>import Language.Haskell.Tools.BackendGHC.Exprs (trfExpr)
<span class="lineno">   22 </span>import Language.Haskell.Tools.BackendGHC.GHCUtils (occName, fromSrcText)
<span class="lineno">   23 </span>import Language.Haskell.Tools.BackendGHC.Monad
<span class="lineno">   24 </span>import Language.Haskell.Tools.BackendGHC.Names
<span class="lineno">   25 </span>import Language.Haskell.Tools.BackendGHC.Patterns (trfPattern)
<span class="lineno">   26 </span>import Language.Haskell.Tools.BackendGHC.Types (trfType)
<span class="lineno">   27 </span>import Language.Haskell.Tools.BackendGHC.Utils
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>import Language.Haskell.Tools.AST (Ann, AnnMaybeG, AnnListG, Dom, RangeStage)
<span class="lineno">   30 </span>import qualified Language.Haskell.Tools.AST as AST
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>trfBind :: TransformName n r =&gt; Located (HsBind n) -&gt; Trf (Ann AST.UValueBind (Dom r) RangeStage)
<span class="lineno">   33 </span><span class="decl"><span class="istickedoff">trfBind = trfLocNoSema trfBind'</span></span>
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>trfBind' :: TransformName n r =&gt; HsBind n -&gt; Trf (AST.UValueBind (Dom r) RangeStage)
<span class="lineno">   36 </span>-- A value binding with a strcitness annotation
<span class="lineno">   37 </span><span class="decl"><span class="istickedoff">trfBind' (FunBind { fun_id = id, fun_matches = MG { mg_alts = L _ [L _ (Match { m_ctxt = FunRhs { mc_strictness = SrcStrict }, m_pats = [], m_grhss = GRHSs [L _ (GRHS [] expr)] (L _ locals) })]} })</span>
<span class="lineno">   38 </span><span class="spaces">  </span><span class="istickedoff">= do bangLoc &lt;- focusBeforeLoc (srcSpanStart $ getLoc id) $ tokenLoc AnnBang</span>
<span class="lineno">   39 </span><span class="spaces">       </span><span class="istickedoff">AST.USimpleBind &lt;$&gt; annLocNoSema (pure $ combineSrcSpans bangLoc (getLoc id))</span>
<span class="lineno">   40 </span><span class="spaces">                             </span><span class="istickedoff">(AST.UBangPat &lt;$&gt; copyAnnot AST.UVarPat (define $ trfName id))</span>
<span class="lineno">   41 </span><span class="spaces">                       </span><span class="istickedoff">&lt;*&gt; addEmptyScope (addToScope <span class="nottickedoff">locals</span> (annLocNoSema (combineSrcSpans (getLoc expr) &lt;$&gt; tokenLoc AnnEqual) (AST.UUnguardedRhs &lt;$&gt; trfExpr expr)))</span>
<span class="lineno">   42 </span><span class="spaces">                       </span><span class="istickedoff">&lt;*&gt; addEmptyScope (trfWhereLocalBinds <span class="nottickedoff">(getLoc expr)</span> locals)</span>
<span class="lineno">   43 </span><span class="spaces"></span><span class="istickedoff">-- A value binding (not a function)</span>
<span class="lineno">   44 </span><span class="spaces"></span><span class="istickedoff">trfBind' (FunBind { fun_id = id, fun_matches = MG { mg_alts = L _ [L _ (Match { m_pats = [], m_grhss = GRHSs [L _ (GRHS [] expr)] (L _ locals) })]} })</span>
<span class="lineno">   45 </span><span class="spaces">  </span><span class="istickedoff">= AST.USimpleBind &lt;$&gt; copyAnnot AST.UVarPat (define $ trfName id)</span>
<span class="lineno">   46 </span><span class="spaces">                    </span><span class="istickedoff">&lt;*&gt; addEmptyScope (addToScope locals (annLocNoSema (combineSrcSpans (getLoc expr) &lt;$&gt; tokenLoc AnnEqual) (AST.UUnguardedRhs &lt;$&gt; trfExpr expr)))</span>
<span class="lineno">   47 </span><span class="spaces">                    </span><span class="istickedoff">&lt;*&gt; addEmptyScope (trfWhereLocalBinds (getLoc expr) locals)</span>
<span class="lineno">   48 </span><span class="spaces"></span><span class="istickedoff">trfBind' (FunBind id (MG (unLoc -&gt; matches) _ _ _) _ _ _)</span>
<span class="lineno">   49 </span><span class="spaces">  </span><span class="istickedoff">= AST.UFunBind &lt;$&gt; makeNonemptyIndentedList (mapM (trfMatch <span class="nottickedoff">(unLoc id)</span>) matches)</span>
<span class="lineno">   50 </span><span class="spaces"></span><span class="istickedoff">trfBind' (PatBind pat (GRHSs rhs (unLoc -&gt; locals)) _ _ _)</span>
<span class="lineno">   51 </span><span class="spaces">  </span><span class="istickedoff">= AST.USimpleBind &lt;$&gt; trfPattern pat</span>
<span class="lineno">   52 </span><span class="spaces">                    </span><span class="istickedoff">&lt;*&gt; addEmptyScope (addToScope <span class="nottickedoff">locals</span> (trfRhss rhs))</span>
<span class="lineno">   53 </span><span class="spaces">                    </span><span class="istickedoff">&lt;*&gt; addEmptyScope (trfWhereLocalBinds <span class="nottickedoff">(collectLocs rhs)</span> locals)</span>
<span class="lineno">   54 </span><span class="spaces"></span><span class="istickedoff">trfBind' (PatSynBind _) = <span class="nottickedoff">convertionProblem &quot;Pattern synonym bindings should be recognized on the declaration level&quot;</span></span>
<span class="lineno">   55 </span><span class="spaces"></span><span class="istickedoff">trfBind' b = <span class="nottickedoff">unhandledElement &quot;binding&quot; b</span></span></span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>trfMatch :: TransformName n r =&gt; n -&gt; Located (Match n (LHsExpr n)) -&gt; Trf (Ann AST.UMatch (Dom r) RangeStage)
<span class="lineno">   58 </span><span class="decl"><span class="istickedoff">trfMatch id = trfLocNoSema (trfMatch' <span class="nottickedoff">id</span>)</span></span>
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>trfMatch' :: TransformName n r =&gt; n -&gt; Match n (LHsExpr n) -&gt; Trf (AST.UMatch (Dom r) RangeStage)
<span class="lineno">   61 </span><span class="decl"><span class="istickedoff">trfMatch' name (Match funid pats _ (GRHSs rhss (unLoc -&gt; locBinds)))</span>
<span class="lineno">   62 </span><span class="spaces">  </span><span class="istickedoff">-- TODO: add the optional typ to pats</span>
<span class="lineno">   63 </span><span class="spaces">  </span><span class="istickedoff">= AST.UMatch &lt;$&gt; trfMatchLhs <span class="nottickedoff">name</span> funid pats</span>
<span class="lineno">   64 </span><span class="spaces">               </span><span class="istickedoff">&lt;*&gt; addToScope pats (addToScope locBinds (trfRhss rhss))</span>
<span class="lineno">   65 </span><span class="spaces">               </span><span class="istickedoff">&lt;*&gt; addToScope pats (trfWhereLocalBinds (collectLocs rhss) locBinds)</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>trfMatchLhs :: TransformName n r =&gt; n -&gt; HsMatchContext (NameOrRdrName n) -&gt; [LPat n] -&gt; Trf (Ann AST.UMatchLhs (Dom r) RangeStage)
<span class="lineno">   68 </span><span class="decl"><span class="istickedoff">trfMatchLhs name fb pats</span>
<span class="lineno">   69 </span><span class="spaces">  </span><span class="istickedoff">= do implicitIdLoc &lt;- <span class="nottickedoff">mkSrcSpan</span> &lt;$&gt; atTheStart &lt;*&gt; atTheStart</span>
<span class="lineno">   70 </span><span class="spaces">       </span><span class="istickedoff">parenOpLoc &lt;- tokensLoc [<span class="nottickedoff">AnnOpenP</span>, <span class="nottickedoff">AnnVal</span>, <span class="nottickedoff">AnnCloseP</span>]</span>
<span class="lineno">   71 </span><span class="spaces">       </span><span class="istickedoff">nonFunOpLoc &lt;- tokenLoc <span class="nottickedoff">AnnVal</span></span>
<span class="lineno">   72 </span><span class="spaces">       </span><span class="istickedoff">let <span class="nottickedoff">infixLoc = case (parenOpLoc, nonFunOpLoc) of</span></span>
<span class="lineno">   73 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">(RealSrcSpan rsp1, RealSrcSpan rsp2)</span></span>
<span class="lineno">   74 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">| srcLocCol (realSrcSpanStart rsp2) == srcLocCol (realSrcSpanStart rsp1) + 1</span></span>
<span class="lineno">   75 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">&amp;&amp; srcLocCol (realSrcSpanEnd rsp2) == srcLocCol (realSrcSpanEnd rsp1) - 1 -&gt; parenOpLoc</span></span>
<span class="lineno">   76 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; nonFunOpLoc</span> -- sometimes parenOpLoc is not an actual operator in parentheses, it just grabs</span>
<span class="lineno">   77 </span><span class="spaces">                                         </span><span class="istickedoff">-- a paren, so we need to check that it is actually what we seek</span>
<span class="lineno">   78 </span><span class="spaces">       </span><span class="istickedoff">closeLoc &lt;- srcSpanStart &lt;$&gt; (combineSrcSpans &lt;$&gt; tokenLoc AnnEqual &lt;*&gt; tokenLoc AnnVbar)</span>
<span class="lineno">   79 </span><span class="spaces">       </span><span class="istickedoff">args &lt;- mapM trfPattern pats</span>
<span class="lineno">   80 </span><span class="spaces">       </span><span class="istickedoff">let (n, isInfix) = case fb of FunRhs n inf _ -&gt; (n, inf == Infix)</span>
<span class="lineno">   81 </span><span class="spaces">                                     </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">let token = if isSymOcc (occName name) &amp;&amp; isGoodSrcSpan infixLoc then infixLoc else implicitIdLoc</span></span>
<span class="lineno">   82 </span><span class="spaces">                                           </span><span class="istickedoff"><span class="nottickedoff">in (L token name, length pats &gt; 0 &amp;&amp; srcSpanStart token &gt;= srcSpanEnd (getLoc (pats !! 0)))</span></span>
<span class="lineno">   83 </span><span class="spaces">       </span><span class="istickedoff">annLocNoSema (mkSrcSpan &lt;$&gt; atTheStart &lt;*&gt; (pure closeLoc)) $</span>
<span class="lineno">   84 </span><span class="spaces">        </span><span class="istickedoff">case (args, isInfix) of</span>
<span class="lineno">   85 </span><span class="spaces">           </span><span class="istickedoff">(left:right:rest, True) -&gt; AST.UInfixLhs left &lt;$&gt; define (trfOperator n) &lt;*&gt; pure right &lt;*&gt; makeList <span class="nottickedoff">&quot; &quot;</span> (pure closeLoc) (pure rest)</span>
<span class="lineno">   86 </span><span class="spaces">           </span><span class="istickedoff">_                       -&gt; AST.UNormalLhs &lt;$&gt; define (trfName n) &lt;*&gt; makeList <span class="nottickedoff">&quot; &quot;</span> (pure closeLoc) (pure args)</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>trfRhss :: TransformName n r =&gt; [Located (GRHS n (LHsExpr n))] -&gt; Trf (Ann AST.URhs (Dom r) RangeStage)
<span class="lineno">   89 </span>-- the original location on the GRHS misleadingly contains the local bindings
<span class="lineno">   90 </span><span class="decl"><span class="istickedoff">trfRhss [unLoc -&gt; GRHS [] body] = annLocNoSema (combineSrcSpans (getLoc body) &lt;$&gt; tokenBefore (srcSpanStart $ getLoc body) AnnEqual)</span>
<span class="lineno">   91 </span><span class="spaces">                                         </span><span class="istickedoff">(AST.UUnguardedRhs &lt;$&gt; trfExpr body)</span>
<span class="lineno">   92 </span><span class="spaces"></span><span class="istickedoff">trfRhss rhss = annLocNoSema (pure $ collectLocs rhss)</span>
<span class="lineno">   93 </span><span class="spaces">                      </span><span class="istickedoff">(AST.UGuardedRhss . nonemptyAnnList &lt;$&gt; mapM trfGuardedRhs rhss)</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>trfGuardedRhs :: TransformName n r =&gt; Located (GRHS n (LHsExpr n)) -&gt; Trf (Ann AST.UGuardedRhs (Dom r) RangeStage)
<span class="lineno">   96 </span><span class="decl"><span class="istickedoff">trfGuardedRhs = trfLocNoSema $ \(GRHS guards body)</span>
<span class="lineno">   97 </span><span class="spaces">  </span><span class="istickedoff">-&gt; AST.UGuardedRhs . nonemptyAnnList &lt;$&gt; trfScopedSequence trfRhsGuard guards &lt;*&gt; addToScope <span class="nottickedoff">guards</span> (trfExpr body)</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>trfRhsGuard :: TransformName n r =&gt; Located (Stmt n (LHsExpr n)) -&gt; Trf (Ann AST.URhsGuard (Dom r) RangeStage)
<span class="lineno">  100 </span><span class="decl"><span class="istickedoff">trfRhsGuard = trfLocNoSema trfRhsGuard'</span></span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>trfRhsGuard' :: TransformName n r =&gt; Stmt n (LHsExpr n) -&gt; Trf (AST.URhsGuard (Dom r) RangeStage)
<span class="lineno">  103 </span><span class="decl"><span class="istickedoff">trfRhsGuard' (BindStmt pat body _ _ _) = AST.UGuardBind &lt;$&gt; trfPattern pat &lt;*&gt; trfExpr body</span>
<span class="lineno">  104 </span><span class="spaces"></span><span class="istickedoff">trfRhsGuard' (BodyStmt body _ _ _) = AST.UGuardCheck &lt;$&gt; trfExpr body</span>
<span class="lineno">  105 </span><span class="spaces"></span><span class="istickedoff">trfRhsGuard' (LetStmt (unLoc -&gt; binds)) = AST.UGuardLet &lt;$&gt; trfLocalBinds AnnLet binds</span>
<span class="lineno">  106 </span><span class="spaces"></span><span class="istickedoff">trfRhsGuard' d = <span class="nottickedoff">unhandledElement &quot;guard&quot; d</span></span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>trfWhereLocalBinds :: TransformName n r =&gt; SrcSpan -&gt; HsLocalBinds n -&gt; Trf (AnnMaybeG AST.ULocalBinds (Dom r) RangeStage)
<span class="lineno">  109 </span><span class="decl"><span class="istickedoff">trfWhereLocalBinds _ EmptyLocalBinds = nothing <span class="nottickedoff">&quot;&quot;</span> <span class="nottickedoff">&quot;&quot;</span> atTheEnd</span>
<span class="lineno">  110 </span><span class="spaces"></span><span class="istickedoff">trfWhereLocalBinds bef binds</span>
<span class="lineno">  111 </span><span class="spaces">  </span><span class="istickedoff">= makeJust &lt;$&gt; annLocNoSema (combineSrcSpans (srcLocSpan (srcSpanEnd bef) `combineSrcSpans` getBindLocs binds) &lt;$&gt; tokenLocBack AnnWhere)</span>
<span class="lineno">  112 </span><span class="spaces">                              </span><span class="istickedoff">(AST.ULocalBinds &lt;$&gt; addToScope binds (trfLocalBinds AnnWhere binds))</span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>getBindLocs :: HsLocalBinds n -&gt; SrcSpan
<span class="lineno">  115 </span><span class="decl"><span class="istickedoff">getBindLocs (HsValBinds (ValBindsIn binds sigs)) = <span class="nottickedoff">foldLocs $ map getLoc (bagToList binds) ++ map getLoc sigs</span></span>
<span class="lineno">  116 </span><span class="spaces"></span><span class="istickedoff">getBindLocs (HsValBinds (ValBindsOut binds sigs)) = foldLocs $ map getLoc (concatMap (bagToList . snd) binds) ++ map getLoc sigs</span>
<span class="lineno">  117 </span><span class="spaces"></span><span class="istickedoff">getBindLocs (HsIPBinds (IPBinds binds _)) = <span class="nottickedoff">foldLocs $ map getLoc binds</span></span>
<span class="lineno">  118 </span><span class="spaces"></span><span class="istickedoff">getBindLocs EmptyLocalBinds = <span class="nottickedoff">noSrcSpan</span></span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>trfLocalBinds :: TransformName n r =&gt; AnnKeywordId -&gt; HsLocalBinds n -&gt; Trf (AnnListG AST.ULocalBind (Dom r) RangeStage)
<span class="lineno">  121 </span><span class="decl"><span class="istickedoff">trfLocalBinds token (HsValBinds (ValBindsIn binds sigs))</span>
<span class="lineno">  122 </span><span class="spaces">  </span><span class="istickedoff">= makeIndentedListBefore <span class="nottickedoff">&quot; &quot;</span> (after <span class="nottickedoff">token</span>)</span>
<span class="lineno">  123 </span><span class="spaces">      </span><span class="istickedoff">(orderDefs &lt;$&gt; ((++) &lt;$&gt; mapM (copyAnnot AST.ULocalValBind . trfBind) (bagToList binds)</span>
<span class="lineno">  124 </span><span class="spaces">                           </span><span class="istickedoff">&lt;*&gt; mapM trfLocalSig sigs))</span>
<span class="lineno">  125 </span><span class="spaces"></span><span class="istickedoff">trfLocalBinds token (HsValBinds (ValBindsOut binds sigs))</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="istickedoff">= makeIndentedListBefore &quot; &quot; (after token)</span>
<span class="lineno">  127 </span><span class="spaces">      </span><span class="istickedoff">(orderDefs &lt;$&gt; ((++) &lt;$&gt; (concat &lt;$&gt; mapM (mapM (copyAnnot AST.ULocalValBind . trfBind) . bagToList . snd) binds)</span>
<span class="lineno">  128 </span><span class="spaces">                           </span><span class="istickedoff">&lt;*&gt; mapM trfLocalSig sigs))</span>
<span class="lineno">  129 </span><span class="spaces"></span><span class="istickedoff">trfLocalBinds token (HsIPBinds (IPBinds binds _))</span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="istickedoff">= <span class="nottickedoff">makeIndentedListBefore &quot; &quot; (after token) (mapM trfIpBind binds)</span></span>
<span class="lineno">  131 </span><span class="spaces"></span><span class="istickedoff">trfLocalBinds _ b = <span class="nottickedoff">unhandledElement &quot;local binds&quot; b</span></span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>trfIpBind :: TransformName n r =&gt; Located (IPBind n) -&gt; Trf (Ann AST.ULocalBind (Dom r) RangeStage)
<span class="lineno">  134 </span><span class="decl"><span class="nottickedoff">trfIpBind = trfLocNoSema $ \case</span>
<span class="lineno">  135 </span><span class="spaces">  </span><span class="nottickedoff">IPBind (Left (L l ipname)) expr</span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="nottickedoff">-&gt; AST.ULocalValBind</span>
<span class="lineno">  137 </span><span class="spaces">         </span><span class="nottickedoff">&lt;$&gt; (annContNoSema $ AST.USimpleBind &lt;$&gt; focusOn l (annContNoSema (AST.UVarPat &lt;$&gt; define (trfImplicitName ipname)))</span>
<span class="lineno">  138 </span><span class="spaces">                                              </span><span class="nottickedoff">&lt;*&gt; annFromNoSema AnnEqual (AST.UUnguardedRhs &lt;$&gt; trfExpr expr)</span>
<span class="lineno">  139 </span><span class="spaces">                                              </span><span class="nottickedoff">&lt;*&gt; nothing &quot; &quot; &quot;&quot; atTheEnd)</span>
<span class="lineno">  140 </span><span class="spaces">  </span><span class="nottickedoff">IPBind (Right _) _ -&gt; convertionProblem &quot;trfIpBind: called on typechecked AST&quot;</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>trfLocalSig :: TransformName n r =&gt; Located (Sig n) -&gt; Trf (Ann AST.ULocalBind (Dom r) RangeStage)
<span class="lineno">  143 </span><span class="decl"><span class="istickedoff">trfLocalSig = trfLocNoSema $ \case</span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="istickedoff">ts@(TypeSig {}) -&gt; AST.ULocalSignature &lt;$&gt; annContNoSema (trfTypeSig' ts)</span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="istickedoff">(FixSig fs) -&gt; AST.ULocalFixity &lt;$&gt; annContNoSema (trfFixitySig fs)</span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="istickedoff">(InlineSig name prag) -&gt; <span class="nottickedoff">AST.ULocalInline &lt;$&gt; trfInlinePragma name prag</span></span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">d -&gt; <span class="nottickedoff">unhandledElement &quot;local signature&quot; d</span></span></span>
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>trfTypeSig :: TransformName n r =&gt; Located (Sig n) -&gt; Trf (Ann AST.UTypeSignature (Dom r) RangeStage)
<span class="lineno">  150 </span><span class="decl"><span class="nottickedoff">trfTypeSig = trfLocNoSema trfTypeSig'</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>trfTypeSig' :: TransformName n r =&gt; Sig n -&gt; Trf (AST.UTypeSignature (Dom r) RangeStage)
<span class="lineno">  153 </span><span class="decl"><span class="istickedoff">trfTypeSig' (TypeSig names typ)</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="istickedoff">= defineTypeVars $ AST.UTypeSignature &lt;$&gt; makeNonemptyList <span class="nottickedoff">&quot;, &quot;</span> (mapM trfName names) &lt;*&gt; trfType (hsib_body $ hswc_body typ)</span>
<span class="lineno">  155 </span><span class="spaces"></span><span class="istickedoff">trfTypeSig' ts = <span class="nottickedoff">unhandledElement &quot;type signature&quot; ts</span></span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>trfFixitySig :: TransformName n r =&gt; FixitySig n -&gt; Trf (AST.UFixitySignature (Dom r) RangeStage)
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">trfFixitySig (FixitySig names (Fixity _ prec dir))</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">= do precLoc &lt;- tokenLoc AnnVal -- the precedence token or one of the names</span>
<span class="lineno">  160 </span><span class="spaces">       </span><span class="istickedoff">AST.UFixitySignature &lt;$&gt; transformDir dir</span>
<span class="lineno">  161 </span><span class="spaces">                            </span><span class="istickedoff">&lt;*&gt; (if <span class="tickonlytrue">isGoodSrcSpan precLoc &amp;&amp; all (srcSpanEnd precLoc &lt;) (map (srcSpanStart . getLoc) names)</span></span>
<span class="lineno">  162 </span><span class="spaces">                                   </span><span class="istickedoff">then makeJust &lt;$&gt; (annLocNoSema (return precLoc) $ pure $ AST.Precedence <span class="nottickedoff">prec</span>)</span>
<span class="lineno">  163 </span><span class="spaces">                                                                                         </span><span class="istickedoff">-- names cannot be empty</span>
<span class="lineno">  164 </span><span class="spaces">                                   </span><span class="istickedoff">else <span class="nottickedoff">nothing &quot;&quot; &quot; &quot; (return $ srcSpanStart $ getLoc $ head names)</span>)</span>
<span class="lineno">  165 </span><span class="spaces">                            </span><span class="istickedoff">&lt;*&gt; (nonemptyAnnList . nubBy ((==) `on` AST.getRange) &lt;$&gt; mapM trfOperator names)</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="istickedoff">where transformDir InfixL = directionChar (pure AST.AssocLeft)</span>
<span class="lineno">  167 </span><span class="spaces">        </span><span class="istickedoff">transformDir InfixR = <span class="nottickedoff">directionChar (pure AST.AssocRight)</span></span>
<span class="lineno">  168 </span><span class="spaces">        </span><span class="istickedoff">transformDir InfixN = <span class="nottickedoff">annLocNoSema (srcLocSpan . srcSpanEnd &lt;$&gt; tokenLoc AnnInfix) (pure AST.AssocNone)</span></span>
<span class="lineno">  169 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  170 </span><span class="spaces">        </span><span class="istickedoff">directionChar = annLocNoSema ((\l -&gt; mkSrcSpan (updateCol (subtract 1) l) l) . srcSpanEnd &lt;$&gt; tokenLoc AnnInfix)</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>trfInlinePragma :: TransformName n r =&gt; Located n -&gt; InlinePragma -&gt; Trf (Ann AST.UInlinePragma (Dom r) RangeStage)
<span class="lineno">  173 </span><span class="decl"><span class="nottickedoff">trfInlinePragma name (InlinePragma _ Inlinable _ phase _)</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="nottickedoff">= annContNoSema (AST.UInlinablePragma &lt;$&gt; trfPhase (pure $ srcSpanStart $ getLoc name) phase &lt;*&gt; trfName name)</span>
<span class="lineno">  175 </span><span class="spaces"></span><span class="nottickedoff">trfInlinePragma name (InlinePragma _ NoInline _ _ _) = annContNoSema (AST.UNoInlinePragma &lt;$&gt; trfName name)</span>
<span class="lineno">  176 </span><span class="spaces"></span><span class="nottickedoff">trfInlinePragma name (InlinePragma (fromSrcText -&gt; src) Inline _ phase cl)</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="nottickedoff">= annContNoSema $ do rng &lt;- asks contRange</span>
<span class="lineno">  178 </span><span class="spaces">                       </span><span class="nottickedoff">let parts = map getLoc $ splitLocated (L rng src)</span>
<span class="lineno">  179 </span><span class="spaces">                       </span><span class="nottickedoff">AST.UInlinePragma &lt;$&gt; trfConlike parts cl</span>
<span class="lineno">  180 </span><span class="spaces">                                         </span><span class="nottickedoff">&lt;*&gt; trfPhase (pure $ srcSpanStart (getLoc name)) phase</span>
<span class="lineno">  181 </span><span class="spaces">                                         </span><span class="nottickedoff">&lt;*&gt; trfName name</span></span>
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>trfPhase :: Trf SrcLoc -&gt; Activation -&gt; Trf (AnnMaybeG AST.UPhaseControl (Dom r) RangeStage)
<span class="lineno">  184 </span><span class="decl"><span class="nottickedoff">trfPhase l AlwaysActive = nothing &quot; &quot; &quot;&quot; l</span>
<span class="lineno">  185 </span><span class="spaces"></span><span class="nottickedoff">trfPhase _ (ActiveAfter _ pn) = makeJust &lt;$&gt; annLocNoSema (combineSrcSpans &lt;$&gt; tokenLoc AnnOpenS &lt;*&gt; tokenLoc AnnCloseS)</span>
<span class="lineno">  186 </span><span class="spaces">                                                          </span><span class="nottickedoff">(AST.UPhaseControl &lt;$&gt; nothing &quot;&quot; &quot;&quot; (before AnnCloseS) &lt;*&gt; (makeJust &lt;$&gt; trfPhaseNum pn))</span>
<span class="lineno">  187 </span><span class="spaces"></span><span class="nottickedoff">trfPhase _ (ActiveBefore _ pn) = makeJust &lt;$&gt; annLocNoSema (combineSrcSpans &lt;$&gt; tokenLoc AnnOpenS &lt;*&gt; tokenLoc AnnCloseS)</span>
<span class="lineno">  188 </span><span class="spaces">                                                           </span><span class="nottickedoff">(AST.UPhaseControl &lt;$&gt; (makeJust &lt;$&gt; annLocNoSema (tokenLoc AnnTilde) (pure AST.PhaseInvert)) &lt;*&gt; (makeJust &lt;$&gt; trfPhaseNum pn))</span>
<span class="lineno">  189 </span><span class="spaces"></span><span class="nottickedoff">trfPhase _ NeverActive = makeJust &lt;$&gt; annLocNoSema (combineSrcSpans &lt;$&gt; tokenLoc AnnOpenS &lt;*&gt; tokenLoc AnnCloseS)</span>
<span class="lineno">  190 </span><span class="spaces">                                                   </span><span class="nottickedoff">(AST.UPhaseControl &lt;$&gt; (makeJust &lt;$&gt; annLocNoSema (tokenLoc AnnTilde) (pure AST.PhaseInvert)) &lt;*&gt; nothing &quot; &quot; &quot;&quot; (after AnnTilde))</span></span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>trfPhaseNum ::  PhaseNum -&gt; Trf (Ann AST.PhaseNumber (Dom r) RangeStage)
<span class="lineno">  193 </span><span class="decl"><span class="nottickedoff">trfPhaseNum i = annLocNoSema (tokenLoc AnnVal) $ pure (AST.PhaseNumber $ fromIntegral i)</span></span>
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>trfConlike :: [SrcSpan] -&gt; RuleMatchInfo -&gt; Trf (AnnMaybeG AST.UConlikeAnnot (Dom r) RangeStage)
<span class="lineno">  196 </span><span class="decl"><span class="nottickedoff">trfConlike parts ConLike | length parts &gt; 2</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="nottickedoff">= makeJust &lt;$&gt; annLocNoSema (pure $ parts !! 2) (pure AST.UConlikeAnnot)</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = convertionProblem $ &quot;trfConlike: expected 3 parts, got: &quot; ++ show parts</span>
<span class="lineno">  199 </span><span class="spaces"></span><span class="nottickedoff">trfConlike (_:inlTok:_) FunLike = nothing &quot; &quot; &quot;&quot; (pure $ srcSpanEnd inlTok)</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="nottickedoff">trfConlike (combTok:_) FunLike = nothing &quot; &quot; &quot;&quot; (pure $ srcSpanEnd combTok)</span></span>

</pre>
</body>
</html>
